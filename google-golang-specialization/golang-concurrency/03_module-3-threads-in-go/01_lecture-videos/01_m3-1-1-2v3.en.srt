1
00:00:00,000 --> 00:00:02,135
Module three: Threads in Go.

2
00:00:02,135 --> 00:00:04,720
Topic one point one: Goroutines.

3
00:00:04,720 --> 00:00:09,585
So, in the previous modules we've been talking about concurrency and parallelism,

4
00:00:09,585 --> 00:00:12,145
and how processes work and threads work,

5
00:00:12,145 --> 00:00:17,260
how they execute concurrently at least and maybe in parallel if you have extra hardware.

6
00:00:17,260 --> 00:00:19,710
But we haven't really talked about how you

7
00:00:19,710 --> 00:00:22,400
actually implement that and certainly not in Go,

8
00:00:22,400 --> 00:00:24,180
but how you implement that in software.

9
00:00:24,180 --> 00:00:27,070
So, in order to get these multiple threads,

10
00:00:27,070 --> 00:00:29,045
we specifically focusing on threads.

11
00:00:29,045 --> 00:00:32,390
In order to create these threads of execution,

12
00:00:32,390 --> 00:00:34,565
you have to use certain programming constructs that are built

13
00:00:34,565 --> 00:00:37,145
into the Go language and this is one of the advantages of Go.

14
00:00:37,145 --> 00:00:39,750
That it has a lot of these constructs built right in,

15
00:00:39,750 --> 00:00:41,155
and they're easy to use.

16
00:00:41,155 --> 00:00:44,000
So, say you want to create a Goroutine, right?

17
00:00:44,000 --> 00:00:47,560
Which is a thread that can run concurrently with the other Goroutines.

18
00:00:47,560 --> 00:00:51,705
Now one Goroutine is always created automatically to execute the main.

19
00:00:51,705 --> 00:00:54,860
So, even if you don't do anything special you run a main,

20
00:00:54,860 --> 00:00:58,250
it will create a Goroutine execute the main inside that Goroutine.

21
00:00:58,250 --> 00:01:01,665
Other Goroutines are created using a Go keyword.

22
00:01:01,665 --> 00:01:05,195
So, as an example down here on the left,

23
00:01:05,195 --> 00:01:09,000
we have the on the left we have an example where there's just the one Goroutine main.

24
00:01:09,000 --> 00:01:11,070
Okay, this is some segment of main, right?

25
00:01:11,070 --> 00:01:13,355
A equals one you call foo equals two.

26
00:01:13,355 --> 00:01:16,505
Let's just make this one Goroutine the main Goroutine

27
00:01:16,505 --> 00:01:20,335
executing all three of those instruction the fact that foo is the function call.

28
00:01:20,335 --> 00:01:24,980
Now, on the right is the version where we actually create a new Goroutine.

29
00:01:24,980 --> 00:01:26,995
Just to execute that function foo.

30
00:01:26,995 --> 00:01:31,150
So, you can see on the right there's a equals one that's executing the main Goroutine.

31
00:01:31,150 --> 00:01:36,625
Then we say, go foo that creates a new Goroutine which will execute the code in foo,

32
00:01:36,625 --> 00:01:39,240
and then we say a equals two.

33
00:01:39,240 --> 00:01:42,090
Again is still in the main Goroutine.

34
00:01:42,090 --> 00:01:45,440
So, after you call gofoo there are now two Goroutines.

35
00:01:45,440 --> 00:01:49,720
The main Goroutine and this newly created this call subroutine,

36
00:01:49,720 --> 00:01:52,795
sub Goroutine that's created.

37
00:01:52,795 --> 00:01:56,830
So, and notice it on the right.

38
00:01:56,830 --> 00:01:59,590
So, on the left the main will block when it comes to foo.

39
00:01:59,590 --> 00:02:01,570
When I say block, the main will,

40
00:02:01,570 --> 00:02:04,180
so there's a equals one then foo then equals two.

41
00:02:04,180 --> 00:02:08,260
A equals two can't execute on the left until foo is complete.

42
00:02:08,260 --> 00:02:11,390
So, foo well it's non-blocking but foo has to completely

43
00:02:11,390 --> 00:02:14,955
execute before a two can happen and this is on the left.

44
00:02:14,955 --> 00:02:18,545
On the right where you have the extra Goroutine that you've created you say,

45
00:02:18,545 --> 00:02:21,465
a equals one in the main then go foo,

46
00:02:21,465 --> 00:02:24,950
it creates this new thread or new Goroutine to execute

47
00:02:24,950 --> 00:02:28,580
foo and then a equal to can execute while foo is going on,

48
00:02:28,580 --> 00:02:29,840
or before foods even started.

49
00:02:29,840 --> 00:02:31,730
We don't know the timing it depends on

50
00:02:31,730 --> 00:02:35,015
the scheduler,on the runtime Go runtime scheduling.

51
00:02:35,015 --> 00:02:38,900
How that's going to be scheduled but a equals two does not,

52
00:02:38,900 --> 00:02:40,250
it can execute immediately.

53
00:02:40,250 --> 00:02:43,460
It doesn't have to wait for foo to complete or anything like that because

54
00:02:43,460 --> 00:02:47,730
foo is being executed in a in a concurrent Goroutine.

55
00:02:47,820 --> 00:02:53,805
So, I just showed you how to start a Goroutine it is pretty simple you say go,

56
00:02:53,805 --> 00:02:56,510
and then give the name of the function that you want to execute,

57
00:02:56,510 --> 00:02:58,550
or define the function you want to execute and

58
00:02:58,550 --> 00:03:02,390
the Goroutine will execute the code associated with that function.

59
00:03:02,390 --> 00:03:06,510
A Goroutine generally exits when its code is complete.

60
00:03:06,510 --> 00:03:10,270
Okay. Whenever it's done with whatever function is

61
00:03:10,270 --> 00:03:14,280
executing it's done it returns from that then the Goroutine just exits.

62
00:03:14,280 --> 00:03:19,805
Now, when the main Go routines complete all other Go routines are forced to exit.

63
00:03:19,805 --> 00:03:24,425
So, that means, if you start with the main you can make several Goroutines from the main,

64
00:03:24,425 --> 00:03:28,290
but if even if these other Goroutines are not finished with their code,

65
00:03:28,290 --> 00:03:30,330
if the main Goroutine ends,

66
00:03:30,330 --> 00:03:35,160
then all the other Goroutines will be forced to end and will be forced to exit.

67
00:03:35,160 --> 00:03:37,065
This is important to understand,

68
00:03:37,065 --> 00:03:41,170
to think about when you're writing your routines because what'll happen is,

69
00:03:41,170 --> 00:03:44,230
the Goroutine that you create may not

70
00:03:44,230 --> 00:03:47,485
complete its execution because the main completes first.

71
00:03:47,485 --> 00:03:50,080
So, you might get this behavior where you say,

72
00:03:50,080 --> 00:03:52,180
"Look I wrote this code and this code

73
00:03:52,180 --> 00:03:54,690
to execute and it doesn't seem like it's executing."

74
00:03:54,690 --> 00:03:57,380
That might be because the main is completing

75
00:03:57,380 --> 00:04:01,240
before the Goroutine ever got to finish its own code.

76
00:04:01,240 --> 00:04:05,285
So that's something to watch out for. Thank you.

77
00:04:05,285 --> 00:04:07,540
Module three: Threads in Go.

78
00:04:07,540 --> 00:04:10,910
Topic one point: Exiting Goroutines.

79
00:04:10,910 --> 00:04:17,160
So, we already described how Goroutines will exit when they complete their code,

80
00:04:17,160 --> 00:04:22,445
but also Goroutines will be forced to exit if the main Goroutine exits early.

81
00:04:22,445 --> 00:04:25,865
Then the all the Goroutines that are created they all are forced to exit.

82
00:04:25,865 --> 00:04:28,770
So, they might exit early before they do their job, right?

83
00:04:28,770 --> 00:04:32,355
Before they finish the job. So, I'll give a little example a piece of code here.

84
00:04:32,355 --> 00:04:34,210
By the way in these code segments,

85
00:04:34,210 --> 00:04:38,990
I'm generally clipping out the importing the packages, right?

86
00:04:38,990 --> 00:04:42,530
In order to use this program I have a print f right and I'm using

87
00:04:42,530 --> 00:04:46,710
the fmt package so I haven't put the part in there where I import that.

88
00:04:46,710 --> 00:04:51,795
But assume that's there I just want to get right to the Goroutines.

89
00:04:51,795 --> 00:04:54,650
So, in this main is pretty simple,

90
00:04:54,650 --> 00:04:59,835
first thing it does is it creates a new Goroutine which had just exit just do a printf,

91
00:04:59,835 --> 00:05:05,320
rather and print a new routine and then after that or not we don't know the order

92
00:05:05,320 --> 00:05:11,135
but at some other point in the main Goroutine format.print.f, main routine.

93
00:05:11,135 --> 00:05:14,150
So, you expect to see two things printed on the screen,

94
00:05:14,150 --> 00:05:16,360
main routine and new routine and you

95
00:05:16,360 --> 00:05:18,950
wouldn't necessarily know what order these two are going to get printed in.

96
00:05:18,950 --> 00:05:22,285
Right? Because when the Goroutine is created,

97
00:05:22,285 --> 00:05:26,640
we don't know how the scheduler is going to schedule the main routine in a Goroutine.

98
00:05:26,640 --> 00:05:29,600
Maybe it schedules the Goroutine first the new Goroutine first

99
00:05:29,600 --> 00:05:32,955
maybe it schedules the main Goroutine first, we can't really tell.

100
00:05:32,955 --> 00:05:35,650
But at a glance, you would expect it to print main routine

101
00:05:35,650 --> 00:05:38,685
and print new routine at some point in some order.

102
00:05:38,685 --> 00:05:40,035
But when I execute this,

103
00:05:40,035 --> 00:05:42,265
only main routine is printed.

104
00:05:42,265 --> 00:05:44,930
Why does this happen? Is because

105
00:05:44,930 --> 00:05:51,180
the main Goroutine is finishing before the other new Goroutine starts.

106
00:05:51,180 --> 00:05:53,310
Okay. This happens consistently.

107
00:05:53,310 --> 00:05:57,500
So, theoretically we don't know how the schedule is going to work.

108
00:05:57,500 --> 00:05:58,840
The Go runtime scheduler.

109
00:05:58,840 --> 00:06:02,910
We don't know is it going to let the main Goroutine run first,

110
00:06:02,910 --> 00:06:04,935
or the new Goroutine run first we don't know.

111
00:06:04,935 --> 00:06:07,595
Theoretically, if you ran this over and over,

112
00:06:07,595 --> 00:06:09,480
you could get different ordering, right?

113
00:06:09,480 --> 00:06:11,650
You would think well, sometimes the main goes first,

114
00:06:11,650 --> 00:06:13,415
so it does main routine and then it quits.

115
00:06:13,415 --> 00:06:17,800
Sometimes it does the new Goroutine then prints a new routine and main routine.

116
00:06:17,800 --> 00:06:20,740
Right? Maybe. Actually what happens is,

117
00:06:20,740 --> 00:06:22,175
when I run this anyway,

118
00:06:22,175 --> 00:06:24,825
every time it just prints main routine and quits.

119
00:06:24,825 --> 00:06:27,705
So, what I presume from this is,

120
00:06:27,705 --> 00:06:30,065
what I assume from this rather is that,

121
00:06:30,065 --> 00:06:33,780
the scheduler, the Go runtime scheduler is giving preference to the main routine.

122
00:06:33,780 --> 00:06:37,125
So it's always lighting the main routine go first before the new Goroutine.

123
00:06:37,125 --> 00:06:38,950
I don't know that for a fact,

124
00:06:38,950 --> 00:06:40,685
but it seems like that's how it's implemented.

125
00:06:40,685 --> 00:06:44,700
But even if that's how it's implemented we have no definite knowledge of that.

126
00:06:44,700 --> 00:06:48,615
Meaning, maybe it's implemented in that way right now,

127
00:06:48,615 --> 00:06:50,130
but then in the next version of Go,

128
00:06:50,130 --> 00:06:52,435
they might change the scheduler so it does something different.

129
00:06:52,435 --> 00:06:55,750
Okay.? So, that's not something that ordering, we can rely on.

130
00:06:55,750 --> 00:07:00,500
We have to assume that we have no idea what order the scheduler is going to work in,

131
00:07:00,500 --> 00:07:02,975
what order is going to execute these Goroutines in.

132
00:07:02,975 --> 00:07:07,820
So, definitely- but definitely though what's happening here is not what I wanted, right?

133
00:07:07,820 --> 00:07:10,430
It just print out main routine never print out new routine.

134
00:07:10,430 --> 00:07:15,395
So, what- so I got to get this this main so that it doesn't exit so early.

135
00:07:15,395 --> 00:07:18,800
Right? I don't need- I don't want main to somehow

136
00:07:18,800 --> 00:07:22,455
wait for the other Goroutine to execute- exit before,

137
00:07:22,455 --> 00:07:25,260
it so that I can get the new routine to be printed out, right?

138
00:07:25,260 --> 00:07:27,465
So, how should I do this?

139
00:07:27,465 --> 00:07:30,595
First, I'm going to show you this one way which is really a hack,

140
00:07:30,595 --> 00:07:31,750
but I'm going to show it to you anyway.

141
00:07:31,750 --> 00:07:33,580
Okay. Just so you know what not to do.

142
00:07:33,580 --> 00:07:39,315
But it works sometimes but it's not a safe thing to do. So, here's what I do.

143
00:07:39,315 --> 00:07:42,695
What I do is I just add this line that I highlighted in red,

144
00:07:42,695 --> 00:07:46,950
time.sleep and I give it 100 milliseconds.

145
00:07:46,950 --> 00:07:50,355
So, what I'm doing is I'm and notice that that time that sleep,

146
00:07:50,355 --> 00:07:52,575
it executes in the main Goroutine.

147
00:07:52,575 --> 00:07:55,805
Not in the new Goroutine that I created in the main Goroutine.

148
00:07:55,805 --> 00:07:58,900
I create the new Goroutine call and go,

149
00:07:58,900 --> 00:08:02,700
then I put the main Goroutine to sleep for a little while,

150
00:08:02,700 --> 00:08:06,695
100 milliseconds and then I have the main Goroutine print main routine.

151
00:08:06,695 --> 00:08:08,435
Now what that does is,

152
00:08:08,435 --> 00:08:11,095
in that time that the main goal routine is sleeping,

153
00:08:11,095 --> 00:08:13,475
the Go runtime scheduler isn't stupid,

154
00:08:13,475 --> 00:08:15,460
it's not going to just let the machine sit like that

155
00:08:15,460 --> 00:08:17,555
when it knows it has another Goroutine available.

156
00:08:17,555 --> 00:08:20,470
Right? Because remember a big benefit of doing

157
00:08:20,470 --> 00:08:23,630
concurrent programming is that when one routine,

158
00:08:23,630 --> 00:08:27,560
one Goroutine or one thread is waiting is blocked and waiting for something,

159
00:08:27,560 --> 00:08:30,350
then the scheduler can just move in another one.

160
00:08:30,350 --> 00:08:32,240
So, it doesn't have to waste time it could say look,

161
00:08:32,240 --> 00:08:35,130
I've got another available Goroutine let me schedule that.

162
00:08:35,130 --> 00:08:37,215
So that's exactly what's happening here.

163
00:08:37,215 --> 00:08:39,565
When you put the main Goroutine to sleep,

164
00:08:39,565 --> 00:08:41,630
the main can't run so the scheduler,

165
00:08:41,630 --> 00:08:44,990
the Goruntime scheduler schedules in the the new Goroutine that it

166
00:08:44,990 --> 00:08:48,920
created that i created just before it prints out new routine,

167
00:08:48,920 --> 00:08:50,250
and then main routine printed out.

168
00:08:50,250 --> 00:08:52,590
So, what I get printed now is new routine,

169
00:08:52,590 --> 00:08:54,860
main routine just like that with no space because I didn't put

170
00:08:54,860 --> 00:08:57,540
a space or carriage return or anything. But that's what I get.

171
00:08:57,540 --> 00:09:02,960
So, this is my hacky attempt to get the Goroutine,

172
00:09:02,960 --> 00:09:05,510
the main Goroutine to stay alive long

173
00:09:05,510 --> 00:09:09,725
enough for the new Goroutine to actually complete its execution.

174
00:09:09,725 --> 00:09:13,180
It works. It works pretty consistently on my machine.

175
00:09:13,180 --> 00:09:14,660
But this is not what you should do,

176
00:09:14,660 --> 00:09:17,070
but this this worked you can see how this worked.

177
00:09:17,070 --> 00:09:22,255
To do what I did adding a delay like that to wait for Goroutine is bad, bad, bad.

178
00:09:22,255 --> 00:09:24,890
Reason why is because you're making assumptions about

179
00:09:24,890 --> 00:09:28,105
the timing and your timing assumptions may be wrong.

180
00:09:28,105 --> 00:09:31,610
So, in this case,, the big assumption I'm making is that the

181
00:09:31,610 --> 00:09:35,345
delay of 100 milliseconds which I injected in there in the main Goroutine,

182
00:09:35,345 --> 00:09:40,510
I assumed that that will be enough to ensure that the new Go routine has time to execute.

183
00:09:40,510 --> 00:09:44,240
So, I assumed look if- I assumed that certain behavior of the scheduler to.

184
00:09:44,240 --> 00:09:48,890
I said, look if I'm going to- if I force the main to delay for a 100 milliseconds,

185
00:09:48,890 --> 00:09:51,005
the Go runtime scheduler of course it's going to

186
00:09:51,005 --> 00:09:53,430
schedule this other Goroutine that I've created.

187
00:09:53,430 --> 00:09:55,825
I assume that. I don't know that.

188
00:09:55,825 --> 00:09:58,720
I don't know how they've implemented that but I assume that.

189
00:09:58,720 --> 00:10:02,600
So, I assume that the Go runtime scheduler is going to

190
00:10:02,600 --> 00:10:06,380
schedule a particular Goroutine that I had in my mind.

191
00:10:06,380 --> 00:10:11,240
Also, I'm assuming something about the operating system too because for all I know,

192
00:10:11,240 --> 00:10:14,360
the operating system which is running above the Go runtime.

193
00:10:14,360 --> 00:10:18,700
It could take that 100 milliseconds and move in another thread entirely.

194
00:10:18,700 --> 00:10:22,900
It might just- so right now I've got- if you remember it there's a thread in OS,

195
00:10:22,900 --> 00:10:24,220
an operating system thread,

196
00:10:24,220 --> 00:10:26,570
that all the Go code is running in.

197
00:10:26,570 --> 00:10:29,630
Right, all the Go threads are running within this one operating system thread.

198
00:10:29,630 --> 00:10:31,660
The operating system might just say look,

199
00:10:31,660 --> 00:10:35,540
I'm going to take that thread and swap it put it out of context switch it and

200
00:10:35,540 --> 00:10:37,460
bring it in an entirely different thread and maybe it'll bring in

201
00:10:37,460 --> 00:10:39,590
PowerPoint or something which is running on this machine.

202
00:10:39,590 --> 00:10:44,680
Right! So that it might use that 100 milliseconds in a way that I don't anticipate.

203
00:10:44,680 --> 00:10:46,710
Now, it doesn't.

204
00:10:46,710 --> 00:10:48,110
There are reasons why it doesn't,

205
00:10:48,110 --> 00:10:52,220
but I'm making certain assumptions about how the operating system scheduler works and

206
00:10:52,220 --> 00:10:56,290
about how the Go runtime scheduler works and these assumptions are not safe to make.

207
00:10:56,290 --> 00:10:58,070
Right? I have to- because they could these

208
00:10:58,070 --> 00:10:59,860
can change in different version of the operating system.

209
00:10:59,860 --> 00:11:03,300
So, relying on timing like this, is not safe.

210
00:11:03,300 --> 00:11:06,840
The timing is non-deterministic meaning every time you run the program,

211
00:11:06,840 --> 00:11:08,880
the timing might be different,

212
00:11:08,880 --> 00:11:10,415
and you have to assume that.

213
00:11:10,415 --> 00:11:12,230
So, because if you don't,

214
00:11:12,230 --> 00:11:16,555
what will happen is at some point you get these really bad intermittent errors.

215
00:11:16,555 --> 00:11:18,230
Where most of the time it'll work,

216
00:11:18,230 --> 00:11:20,120
but sometimes that you're timing assumption will be

217
00:11:20,120 --> 00:11:22,505
violated and sometimes the error will happen.

218
00:11:22,505 --> 00:11:25,550
These are the worst- these are one of the worst types of errors because then

219
00:11:25,550 --> 00:11:28,430
you get these intermittent errors which the only happened occasionally.

220
00:11:28,430 --> 00:11:30,920
So, you run it and you say I found a bug let me

221
00:11:30,920 --> 00:11:33,615
run it again to reproduce it so I can debug it and you can't.

222
00:11:33,615 --> 00:11:36,625
Right, you run it again and again the bug doesn't happen again.

223
00:11:36,625 --> 00:11:39,480
Those are terrible types of errors to have to debug.

224
00:11:39,480 --> 00:11:41,440
So, this is not what you want to do.

225
00:11:41,440 --> 00:11:45,020
You don't want to rely on timing.l have a long story which I could talk

226
00:11:45,020 --> 00:11:49,465
about where I rely on timing as an undergrad and failed badly in a big assignment.

227
00:11:49,465 --> 00:11:52,360
I won't bring that up is interesting but it's sort of attract.

228
00:11:52,360 --> 00:11:55,310
Still you can't rely on the timing so you need

229
00:11:55,310 --> 00:11:59,520
formal synchronization constructs and we'll talk about those. Thank you