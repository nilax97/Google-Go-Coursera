1
00:00:00,000 --> 00:00:05,250
Module 2; Concurrency basics, topic 2.1, interleaving.

2
00:00:05,250 --> 00:00:09,015
So, writing concurrent code is hard.

3
00:00:09,015 --> 00:00:10,825
Part of the reason why it's hard,

4
00:00:10,825 --> 00:00:12,540
a big chunk of the reason why it's hard,

5
00:00:12,540 --> 00:00:15,010
is because it's hard to have a mental model

6
00:00:15,010 --> 00:00:18,045
of the state of the program at any particular time.

7
00:00:18,045 --> 00:00:21,270
So, what do I mean by that is if you're writing sequential code,

8
00:00:21,270 --> 00:00:24,730
regular old code and it crashes on line 10,

9
00:00:24,730 --> 00:00:26,680
then you know what's been executed before that,

10
00:00:26,680 --> 00:00:29,470
you know it must execute line 9,8,7,6,

11
00:00:29,470 --> 00:00:32,080
and so on, and you know basically what order, right?

12
00:00:32,080 --> 00:00:36,730
So, it helps you figure out what the state of the program should be where it crashed.

13
00:00:36,730 --> 00:00:39,490
You implicitly depend on that when you're debugging.

14
00:00:39,490 --> 00:00:41,485
You say, "Well, I know I got to hear,

15
00:00:41,485 --> 00:00:43,670
so it must have done that, right?"

16
00:00:43,670 --> 00:00:46,025
That helps you zero knowing what the problem is.

17
00:00:46,025 --> 00:00:50,915
With concurrent code, is much harder to get a bead on the state of the machine.

18
00:00:50,915 --> 00:00:54,745
So, when it crashes, maybe crashes on line 10 in task one,

19
00:00:54,745 --> 00:00:57,910
but where is it in test 2, 3,4,5, right?

20
00:00:57,910 --> 00:00:59,410
It can be in different places.

21
00:00:59,410 --> 00:01:04,025
So, the state, the overall state of the machine is as not deterministic.

22
00:01:04,025 --> 00:01:05,805
Meaning, so by that I mean,

23
00:01:05,805 --> 00:01:09,320
say you got a crash, you crash on line 10 and task one every time.

24
00:01:09,320 --> 00:01:13,815
But every time it can be at a different point and test two or three or four, right?

25
00:01:13,815 --> 00:01:15,265
So, every time you run it,

26
00:01:15,265 --> 00:01:17,570
even though it crashed at the same line in task one,

27
00:01:17,570 --> 00:01:21,570
it may be a different overall system states every time.

28
00:01:21,570 --> 00:01:26,300
So, it makes it confusing to keep in your mind this variable should be that,

29
00:01:26,300 --> 00:01:29,390
and this variable should be that because maybe this task has done something or

30
00:01:29,390 --> 00:01:32,860
maybe it hasn't and you don't know what's been done what hasn't, okay?

31
00:01:32,860 --> 00:01:35,135
So, this is really, to me,

32
00:01:35,135 --> 00:01:40,450
the hardest part about programming concurrent or writing concurrent code in any language.

33
00:01:40,450 --> 00:01:44,390
So, just to show you what the complexity is here,

34
00:01:44,390 --> 00:01:46,040
you have what are called these interleaving,

35
00:01:46,040 --> 00:01:50,040
the interleaving are the instructions in two different tasks.

36
00:01:50,040 --> 00:01:53,745
So, the order of execution of statements in the task is known.

37
00:01:53,745 --> 00:01:55,670
So, for instance, I got task one test two,

38
00:01:55,670 --> 00:01:58,090
and each one has three instructions in order one,

39
00:01:58,090 --> 00:02:02,190
two and three, and these are just random instructions, it doesn't matter what they do.

40
00:02:02,190 --> 00:02:05,850
But you know that in task one the instructions are executed in order one,

41
00:02:05,850 --> 00:02:08,930
two, three, test two there execute in order one, two, three,

42
00:02:08,930 --> 00:02:13,360
but the order of execution between concurrent tasks is not known,

43
00:02:13,360 --> 00:02:16,220
is not determined, meaning it is not deterministic,

44
00:02:16,220 --> 00:02:17,965
it could be different every time.

45
00:02:17,965 --> 00:02:22,550
So, what that means is these instructions can be interleaved in different ways.

46
00:02:22,550 --> 00:02:25,275
So, I might execute the first instruction for test one,

47
00:02:25,275 --> 00:02:27,000
then the first instruction for test two,

48
00:02:27,000 --> 00:02:28,480
then the second instruction for test one,

49
00:02:28,480 --> 00:02:30,970
then test two second instruction and so on.

50
00:02:30,970 --> 00:02:33,840
But that's one possible interleaving of instructions.

51
00:02:33,840 --> 00:02:38,540
But there are many possible interleavings and all of them could happen.

52
00:02:38,540 --> 00:02:40,490
So, every time you run it,

53
00:02:40,490 --> 00:02:42,190
you might get a different interleaving.

54
00:02:42,190 --> 00:02:45,040
So, it makes it harder for you for a program to keep in

55
00:02:45,040 --> 00:02:47,440
your mind because you have to consider all

56
00:02:47,440 --> 00:02:50,010
these interleaving when you're thinking about the correctness of the system.

57
00:02:50,010 --> 00:02:52,600
Now hopefully, not all, there're techniques to minimize it,

58
00:02:52,600 --> 00:02:54,895
but you have to consider many different interleaving

59
00:02:54,895 --> 00:02:57,735
in order to reason about how the system behaves.

60
00:02:57,735 --> 00:03:02,135
So, here's an example of a couple of possible interleavings.

61
00:03:02,135 --> 00:03:03,820
So, on the left, the left column.

62
00:03:03,820 --> 00:03:06,205
So, you got two little tables, one at the top one at the bottom.

63
00:03:06,205 --> 00:03:09,065
The top is showing one into leaving the bottom showing another.

64
00:03:09,065 --> 00:03:12,490
The left column are the instructions in the test one.

65
00:03:12,490 --> 00:03:14,995
The right column are the instructions in test two.

66
00:03:14,995 --> 00:03:16,950
Now, the top interleaving,

67
00:03:16,950 --> 00:03:20,110
the top one is showing is just alternating between

68
00:03:20,110 --> 00:03:22,900
instructions in one task versus the next.

69
00:03:22,900 --> 00:03:24,670
So, task one instruction one,

70
00:03:24,670 --> 00:03:26,235
task two instruction one.

71
00:03:26,235 --> 00:03:29,285
So, it's one instruction two, test two instruction two and so on.

72
00:03:29,285 --> 00:03:31,805
Now, the bottom interleaving is saying,

73
00:03:31,805 --> 00:03:34,755
look it fully execute task one, one, two and three,

74
00:03:34,755 --> 00:03:38,275
and then it fully execute test two, right? One, two and three.

75
00:03:38,275 --> 00:03:41,215
That is possible too, and there are many more.

76
00:03:41,215 --> 00:03:43,910
So, there are many interleavings that are possible

77
00:03:43,910 --> 00:03:46,550
and you have to consider all these possibilities,

78
00:03:46,550 --> 00:03:49,040
at least some subset of these possibilities when you're thinking about,

79
00:03:49,040 --> 00:03:51,850
does current code worked correctly or not.

80
00:03:51,850 --> 00:03:55,699
Now, one other thing that I'd like to mention is that these interleaving,

81
00:03:55,699 --> 00:03:59,990
the interleaving problem is even a little more difficult because the interleaving

82
00:03:59,990 --> 00:04:04,830
doesn't happen at the level of the sea and coders or Go Code, right?

83
00:04:04,830 --> 00:04:06,250
There so you write these instructions,

84
00:04:06,250 --> 00:04:08,150
let's say these are Go instructions, right?

85
00:04:08,150 --> 00:04:11,240
So, the interleaving isn't happening at the Go instruction level,

86
00:04:11,240 --> 00:04:13,815
is happening to the machine code instruction level.

87
00:04:13,815 --> 00:04:18,825
So, what I mean by that is that first instruction a equals b plus c. That,

88
00:04:18,825 --> 00:04:20,605
and Go, maybe that's all it is.

89
00:04:20,605 --> 00:04:22,340
But if I were to look at the machine code for that,

90
00:04:22,340 --> 00:04:25,000
that might be several four instructions long.

91
00:04:25,000 --> 00:04:27,670
I might be doing a load b from memory,

92
00:04:27,670 --> 00:04:29,090
load c from memory,

93
00:04:29,090 --> 00:04:32,650
add them together and then do our store a, right?

94
00:04:32,650 --> 00:04:35,485
So, it might be for machine code instructions long,

95
00:04:35,485 --> 00:04:37,920
and the same thing with each one of these instructions.

96
00:04:37,920 --> 00:04:41,705
So, the interleaving is happening even at the machine code level.

97
00:04:41,705 --> 00:04:45,550
So, what that means is you're not guaranteed that it

98
00:04:45,550 --> 00:04:51,865
finishes task one before it starts instruction one and test two.

99
00:04:51,865 --> 00:04:55,310
So, take that a equals b plus c and the top interleaving, right?

100
00:04:55,310 --> 00:04:57,070
The first line and task one.

101
00:04:57,070 --> 00:04:58,900
The essay that takes four instructions,

102
00:04:58,900 --> 00:05:00,330
for a machine code instructions.

103
00:05:00,330 --> 00:05:05,860
You might execute the first two and then it stops and goes to task two, right?

104
00:05:05,860 --> 00:05:07,910
So, you might not even finish the first instruction.

105
00:05:07,910 --> 00:05:09,580
So, these instructions, the interleaving is

106
00:05:09,580 --> 00:05:12,310
happening even in-between these instructions because it's

107
00:05:12,310 --> 00:05:14,410
happening at the machine code level rather than

108
00:05:14,410 --> 00:05:16,630
the source code level that we're looking at right here.

109
00:05:16,630 --> 00:05:21,600
So, that makes it even harder to get a handle on all the possibilities.

110
00:05:21,850 --> 00:05:24,760
Module two, concurrency basics,

111
00:05:24,760 --> 00:05:27,790
topic 2.2, race conditions.

112
00:05:27,790 --> 00:05:31,240
So, a race condition is a problem that can happen as

113
00:05:31,240 --> 00:05:34,975
a result of all these possible interleaving that you have to consider.

114
00:05:34,975 --> 00:05:38,205
Race condition is technically,

115
00:05:38,205 --> 00:05:42,190
is usually defined as a program that runs,

116
00:05:42,190 --> 00:05:47,440
a problem where the outcome of the program depends on the interleaving, right?

117
00:05:47,440 --> 00:05:49,745
Now, the interleaving, remember, is non-deterministic,

118
00:05:49,745 --> 00:05:52,440
it's determined by the operating system and the Go-runtime.

119
00:05:52,440 --> 00:05:55,880
So, the interleaving can change every time you run it,

120
00:05:55,880 --> 00:05:59,695
and in a lot of ways, it has a lot of freedom.

121
00:05:59,695 --> 00:06:03,090
So, you have basically a non-deterministic interleaving,

122
00:06:03,090 --> 00:06:05,995
but you never want to program or almost never,

123
00:06:05,995 --> 00:06:09,395
do you want a program that whose result is non-deterministic?

124
00:06:09,395 --> 00:06:13,245
Okay. You want to be that if you run a program and you give it a set of inputs,

125
00:06:13,245 --> 00:06:15,195
it always produces the same outputs,

126
00:06:15,195 --> 00:06:17,625
okay? That's determinism, right?

127
00:06:17,625 --> 00:06:19,720
If a program is non-deterministic,

128
00:06:19,720 --> 00:06:21,875
you take that program, you run it with a set of inputs,

129
00:06:21,875 --> 00:06:24,080
sometimes it gets one answer, sometimes gets another,

130
00:06:24,080 --> 00:06:26,980
that is almost always a failure, okay?

131
00:06:26,980 --> 00:06:29,360
That's non-determinism and you don't want that.

132
00:06:29,360 --> 00:06:32,335
But remember that the interleavings are not deterministic,

133
00:06:32,335 --> 00:06:34,355
you don't know what the interleaving are.

134
00:06:34,355 --> 00:06:37,340
So, you have to make sure that your program

135
00:06:37,340 --> 00:06:40,035
and it's outcome does not depend on these interleavings,

136
00:06:40,035 --> 00:06:42,195
if it does, that's called a race condition.

137
00:06:42,195 --> 00:06:45,775
So, what I'm showing here is a little example, just toys.

138
00:06:45,775 --> 00:06:49,770
We got these two tasks and we're showing two different interleaving two task.

139
00:06:49,770 --> 00:06:52,730
Now, the first task all it does is instruction one says,

140
00:06:52,730 --> 00:06:54,890
x equals one and instruction two says,

141
00:06:54,890 --> 00:06:56,375
x equals x plus one, okay?

142
00:06:56,375 --> 00:06:57,915
it's a real simple.

143
00:06:57,915 --> 00:06:59,685
On the right-hand side,

144
00:06:59,685 --> 00:07:02,025
you got test two and all it does is print x.

145
00:07:02,025 --> 00:07:04,560
Now, in the first interleaving on top,

146
00:07:04,560 --> 00:07:09,330
it's going to print a one because x is equal to one at the time when the print happens.

147
00:07:09,330 --> 00:07:10,890
While the second interleaving,

148
00:07:10,890 --> 00:07:12,030
x is going to print the two,

149
00:07:12,030 --> 00:07:15,575
x will be printed as two because it's a different interleaving.

150
00:07:15,575 --> 00:07:17,285
This is a race condition.

151
00:07:17,285 --> 00:07:21,680
The outcome depends on the interleaving and the interleaving is non-deterministic,

152
00:07:21,680 --> 00:07:25,690
so this thing has non-deterministic output and that's basically broken.

153
00:07:25,690 --> 00:07:27,890
So, this needs to be avoided,

154
00:07:27,890 --> 00:07:31,120
this is one of those complexities that happens because of all these interleavings.

155
00:07:31,120 --> 00:07:33,420
Now, race conditions, there are

156
00:07:33,420 --> 00:07:35,410
ways to avoid this type of thing to make sure it doesn't happen,

157
00:07:35,410 --> 00:07:37,010
and we will talk about that in Go.

158
00:07:37,010 --> 00:07:40,150
Race conditions occur due to communication.

159
00:07:40,150 --> 00:07:44,955
Communication between tasks or Goroutines that we're going to talk about.

160
00:07:44,955 --> 00:07:47,690
So, there's communication between these two tasks,

161
00:07:47,690 --> 00:07:50,925
I don't know if you see it, but they're communicating on variable x.

162
00:07:50,925 --> 00:07:54,760
So, the one task on the left is writing to x,

163
00:07:54,760 --> 00:07:56,185
is assigning x to one,

164
00:07:56,185 --> 00:07:58,665
is assigning x plus one to two.

165
00:07:58,665 --> 00:08:01,270
Where at the other task on the right is reading from x,

166
00:08:01,270 --> 00:08:03,200
is reading from it and then printing it.

167
00:08:03,200 --> 00:08:07,425
So, they are communicating through this shared variable called x,

168
00:08:07,425 --> 00:08:11,240
and that's communication, and that's where race conditions occur.

169
00:08:11,240 --> 00:08:14,940
See, if you had no communication between two different tasks you would never

170
00:08:14,940 --> 00:08:19,310
have a race condition because the ordering would be completely independent of each other.

171
00:08:19,310 --> 00:08:21,370
Meaning, when I say completely independent,

172
00:08:21,370 --> 00:08:24,795
the outcome would be completely independent of the ordering of the interleaving.

173
00:08:24,795 --> 00:08:29,650
But when you have some kind of communication going on between the two,

174
00:08:29,650 --> 00:08:33,680
then it matters which instructions in task one say,

175
00:08:33,680 --> 00:08:36,115
which instructions that write to this shared variable?

176
00:08:36,115 --> 00:08:40,405
Which ones happen before test two reads from the shared variable?

177
00:08:40,405 --> 00:08:43,650
So, communication is a source of race conditions,

178
00:08:43,650 --> 00:08:48,950
but communication is very common between these different Goroutines.

179
00:08:50,500 --> 00:08:54,820
So, different tasks they generally communicate.

180
00:08:54,820 --> 00:08:57,080
Now, threads in general,

181
00:08:57,080 --> 00:09:00,035
whatever language, threads are largely independent.

182
00:09:00,035 --> 00:09:02,695
They're independent of one another but not

183
00:09:02,695 --> 00:09:05,585
completely independent. So, what does that mean?

184
00:09:05,585 --> 00:09:08,225
They're largely independent, meaning,

185
00:09:08,225 --> 00:09:11,060
they mostly don't have to communicate with each other.

186
00:09:11,060 --> 00:09:13,820
The whole reason why you've made two different threads,

187
00:09:13,820 --> 00:09:15,785
or Goroutines is we're going to call them in Go.

188
00:09:15,785 --> 00:09:18,190
Reason why you've made two different threads is because you

189
00:09:18,190 --> 00:09:20,610
feel like these two things can be executed

190
00:09:20,610 --> 00:09:26,320
concurrently at the same time without caring which one to execute first,

191
00:09:26,320 --> 00:09:29,045
or second, they can just execute it at the same time.

192
00:09:29,045 --> 00:09:33,095
But they are never completely independent because if you've got

193
00:09:33,095 --> 00:09:37,000
multiple threads all in one process, they're sharing information.

194
00:09:37,000 --> 00:09:40,620
Remember how threads have they share common data.

195
00:09:40,620 --> 00:09:43,745
They share the virtual space and all these.

196
00:09:43,745 --> 00:09:47,715
The fact that they're different threads in the same process means that they are sharing.

197
00:09:47,715 --> 00:09:51,980
So, it's very common there's some level of sharing between threads,

198
00:09:51,980 --> 00:09:54,630
and the sharing of information is communication.

199
00:09:54,630 --> 00:10:01,210
So, for instance, web servers a really common multithreaded application.

200
00:10:01,210 --> 00:10:03,310
In this picture the web server,

201
00:10:03,310 --> 00:10:05,265
you got in the middle, you got this web server.

202
00:10:05,265 --> 00:10:07,495
Now, the right you've got these clients,

203
00:10:07,495 --> 00:10:09,345
these are web browsers.

204
00:10:09,345 --> 00:10:11,885
They're connecting to the web server over the network,

205
00:10:11,885 --> 00:10:14,575
and I'm showing three but there can be any number of them.

206
00:10:14,575 --> 00:10:17,100
Then, on the left I've got the web page data.

207
00:10:17,100 --> 00:10:19,755
So, this web server say it's UCI's webpage,

208
00:10:19,755 --> 00:10:21,275
is UCI web server.

209
00:10:21,275 --> 00:10:26,225
It's that orange data is all the data on all the pages that we have.

210
00:10:26,225 --> 00:10:31,015
That's going to be together with the web server and some disk or something.

211
00:10:31,015 --> 00:10:34,870
Now, as these clients come in, as they make connections,

212
00:10:34,870 --> 00:10:38,640
so one browser comes to the website it wants to look at one page.

213
00:10:38,640 --> 00:10:43,345
Another browser connects, it wants to look at a different page, different sub-UCI page.

214
00:10:43,345 --> 00:10:45,815
Another client comes in and wants to look at a different one.

215
00:10:45,815 --> 00:10:48,330
So, this web server program it makes a lot of

216
00:10:48,330 --> 00:10:51,975
sense for it to make a thread for every client that comes in.

217
00:10:51,975 --> 00:10:54,225
Because each one of these communications,

218
00:10:54,225 --> 00:10:57,515
like if this communication with one particular client,

219
00:10:57,515 --> 00:11:00,565
it's likely to do different things,

220
00:11:00,565 --> 00:11:02,460
its client maybe it wants to look at

221
00:11:02,460 --> 00:11:05,500
this web page where the next client wants to use another web page,

222
00:11:05,500 --> 00:11:08,270
all within UCI but different sub-pages.

223
00:11:08,270 --> 00:11:09,810
So, it makes a lot of sense,

224
00:11:09,810 --> 00:11:12,100
and to room in as multiple threads

225
00:11:12,100 --> 00:11:15,125
because these clients are all coming in at the same time.

226
00:11:15,125 --> 00:11:19,260
So, it's a type of thing where you have to handle all these clients all concurrently.

227
00:11:19,260 --> 00:11:23,455
You don't want to have a web page that handles one browser at a time.

228
00:11:23,455 --> 00:11:24,985
You got to handle them all concurrently.

229
00:11:24,985 --> 00:11:28,220
So, it makes a lot of sense to make this a multithreaded application,

230
00:11:28,220 --> 00:11:30,175
you got one thread for each client.

231
00:11:30,175 --> 00:11:34,270
Now, these threads are largely independent but they do share data sometimes.

232
00:11:34,270 --> 00:11:38,310
You can have two clients come in and look at the same web page.

233
00:11:38,310 --> 00:11:40,700
They might both be looking at the top of the web page.

234
00:11:40,700 --> 00:11:44,690
Also, you can have notice arrows between these blocks are two way.

235
00:11:44,690 --> 00:11:49,660
So, for instance, you can have web page where the client sends data,

236
00:11:49,660 --> 00:11:51,065
basing post data of the web page.

237
00:11:51,065 --> 00:11:53,560
We don't want to get into a web page too much but the client may

238
00:11:53,560 --> 00:11:56,290
posted to a web page actually changing the web page.

239
00:11:56,290 --> 00:11:58,405
Like the most obvious place where you see this is

240
00:11:58,405 --> 00:12:01,595
sometimes you see a web page where has a counter like a visit counter.

241
00:12:01,595 --> 00:12:06,050
That data is changed every time a client connects the counter goes up one.

242
00:12:06,050 --> 00:12:10,910
So, that counter value says there is other client who comes into that same page.

243
00:12:10,910 --> 00:12:13,700
He's got to see the updated counter value.

244
00:12:13,700 --> 00:12:17,775
So, in this way one client is writing to the web page increasing the counter value,

245
00:12:17,775 --> 00:12:20,865
and the next client is reading from that same page reading the new count value,

246
00:12:20,865 --> 00:12:23,795
and then writing back to it increasing the counter value again.

247
00:12:23,795 --> 00:12:28,045
So, the point though is that there is some level of communication between these clients,

248
00:12:28,045 --> 00:12:29,560
they are not completely independent,

249
00:12:29,560 --> 00:12:31,410
they can be looking at the same sub-page,

250
00:12:31,410 --> 00:12:33,725
look into same files and data and so on.

251
00:12:33,725 --> 00:12:37,160
So, periodically, they have to communicate with each other.

252
00:12:37,160 --> 00:12:39,215
Now, it shouldn't happen too often.

253
00:12:39,215 --> 00:12:40,880
If there's too much communication between

254
00:12:40,880 --> 00:12:43,775
two threads you probably don't have them in separate threads.

255
00:12:43,775 --> 00:12:45,285
If they're communicating all the time,

256
00:12:45,285 --> 00:12:49,005
then you should probably just make them one Goroutine, don't separate them.

257
00:12:49,005 --> 00:12:52,090
But if they're separate, mostly,

258
00:12:52,090 --> 00:12:54,795
but every once in while having communication then two Goroutines

259
00:12:54,795 --> 00:12:58,215
makes a lot of sense because they can execute concurrently most of the time.

260
00:12:58,215 --> 00:13:03,100
Now, another example I have is this image processing example.

261
00:13:03,200 --> 00:13:08,090
Image processing tasks are often what they call embarrassingly parallel.

262
00:13:08,090 --> 00:13:11,100
So, image processing, say you got some big image,

263
00:13:11,100 --> 00:13:14,140
you got some images, a megapixel.

264
00:13:14,140 --> 00:13:15,985
It's got a million pixels in it.

265
00:13:15,985 --> 00:13:17,770
You want to do some processing,

266
00:13:17,770 --> 00:13:20,245
you want to do a blur or something like this.

267
00:13:20,245 --> 00:13:22,295
Maybe you want to blur the pixels.

268
00:13:22,295 --> 00:13:25,815
So, with a blur is a pretty localize operation,

269
00:13:25,815 --> 00:13:27,660
you look at a pixel, you look at surrounding pixels,

270
00:13:27,660 --> 00:13:28,940
you average out the values.

271
00:13:28,940 --> 00:13:32,795
But this same task you going to do it on every single pixel.

272
00:13:32,795 --> 00:13:36,915
So, this type of thing it makes a lot of sense to have multiple threads.

273
00:13:36,915 --> 00:13:39,215
You got one thread dealing with some pixels,

274
00:13:39,215 --> 00:13:41,270
another thread dealing with the next set of pixels,

275
00:13:41,270 --> 00:13:44,445
another thread dealing with the next set I'm only showing two threads right here.

276
00:13:44,445 --> 00:13:46,170
Actually, this is an extreme,

277
00:13:46,170 --> 00:13:47,230
this is what a GPU does,

278
00:13:47,230 --> 00:13:48,300
a graphics processing unit,

279
00:13:48,300 --> 00:13:49,850
this is exactly what a GPU does.

280
00:13:49,850 --> 00:13:53,425
You might have a thousand cores on this GPU,

281
00:13:53,425 --> 00:13:55,860
and it'll take an image with a million pixels,

282
00:13:55,860 --> 00:13:58,485
and they'll just divide up all the pixels between

283
00:13:58,485 --> 00:14:02,115
the different cores that are all running on different threads on each core.

284
00:14:02,115 --> 00:14:06,505
So, this is the common thing where it's easily paralyzable,

285
00:14:06,505 --> 00:14:09,290
one thread can work on one set of pixels, one can work on another.

286
00:14:09,290 --> 00:14:12,815
But not completely paralyzable because take like a blur.

287
00:14:12,815 --> 00:14:15,760
A blur, you look at your analyzing a pixel you got

288
00:14:15,760 --> 00:14:18,510
to analyze the neighbouring pixels and average their values.

289
00:14:18,510 --> 00:14:21,455
So, you are not completely independent of the neighbor.

290
00:14:21,455 --> 00:14:23,715
If there's another thread working on your neighbor pixel,

291
00:14:23,715 --> 00:14:26,160
those two have to share information.

292
00:14:26,160 --> 00:14:28,505
This guy has to know the pixel value on the neighbor,

293
00:14:28,505 --> 00:14:30,180
this guy has to know the pixel value on the neighbour.

294
00:14:30,180 --> 00:14:32,815
So, there is some communication between these threads,

295
00:14:32,815 --> 00:14:36,285
they got to share what are the pixel values of the neighbors had to share.

296
00:14:36,285 --> 00:14:39,335
So, even though image processing is you

297
00:14:39,335 --> 00:14:42,345
can largely paralyze and shuffle it up amongst different threads,

298
00:14:42,345 --> 00:14:45,535
there's always some level communication between the threads,

299
00:14:45,535 --> 00:14:47,730
and you have to be able to support that.

300
00:14:47,730 --> 00:14:49,840
So, remember that this communication,

301
00:14:49,840 --> 00:14:51,160
if you don't support it correctly,

302
00:14:51,160 --> 00:14:53,075
it can be the source of race conditions.

303
00:14:53,075 --> 00:14:55,650
Where if one happens first before

304
00:14:55,650 --> 00:14:59,100
the other one is some weird interleaving you get different results.

305
00:14:59,100 --> 00:15:04,980
So, this is part of what makes concurrent programming very difficult. Thank you.