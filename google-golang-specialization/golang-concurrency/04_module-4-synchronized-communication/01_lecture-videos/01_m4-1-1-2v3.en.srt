1
00:00:01,830 --> 00:00:06,300
Module 4, Synchronized Communication,
Topic 1.1 Blocking on Channels.

2
00:00:08,330 --> 00:00:13,590
So a common operation on a channel
is to iterate through the channel,

3
00:00:13,590 --> 00:00:16,190
so iteratively read from the channel.

4
00:00:16,190 --> 00:00:18,790
So this would happen in a scenario
where you had a producer and

5
00:00:18,790 --> 00:00:23,370
consumer, the consumer is receiving
from a channel, and it just wants to

6
00:00:23,370 --> 00:00:27,270
continually receive data from the channel
and then process it in some way.

7
00:00:27,270 --> 00:00:30,591
Very common scenario, receive data
process, receive data process, and

8
00:00:30,591 --> 00:00:32,766
you just continue as long
as the code is running.

9
00:00:32,766 --> 00:00:39,600
So there's a concept made to do
specifically that, this for for range.

10
00:00:39,600 --> 00:00:41,560
So we've already seen for loops, but

11
00:00:41,560 --> 00:00:47,640
you can use this range keyword to
continually just read from a channel.

12
00:00:47,640 --> 00:00:51,850
So, for instance,
here we say for i = range c.

13
00:00:51,850 --> 00:00:56,510
What that'll do is, that for
loop will just continually

14
00:00:56,510 --> 00:01:00,810
iterate one path for every piece of
data that is received on that channel.

15
00:01:00,810 --> 00:01:03,270
So every time a piece of data
is received on that channel,

16
00:01:03,270 --> 00:01:07,575
i is assigned to that data, and what's in
the curly brackets is executed, right,

17
00:01:07,575 --> 00:01:09,610
the for loop is executed in one pass.

18
00:01:09,610 --> 00:01:13,850
And, it'll just continue forever, or
not forever, until a close happens,

19
00:01:13,850 --> 00:01:15,140
I'll talk about that in a second.

20
00:01:15,140 --> 00:01:18,363
But it'll just continually read
data off of that channel and

21
00:01:18,363 --> 00:01:22,230
assign it to this variable, i, or
whatever variable you want to call it.

22
00:01:22,230 --> 00:01:25,571
Now in this case, and to our example, I'm
not doing anything useful with the data,

23
00:01:25,571 --> 00:01:28,510
I'm just printing it, but you could
be doing anything in there, right?

24
00:01:28,510 --> 00:01:30,580
You just process the data and
use it in some way.

25
00:01:30,580 --> 00:01:33,070
So this is a very common thing to do.

26
00:01:33,070 --> 00:01:38,910
Now, this for loop,
it could be an infinite loop, right?

27
00:01:38,910 --> 00:01:44,580
So what has to happen is, in other to end
of this loop, when does it actually quit?

28
00:01:44,580 --> 00:01:46,980
It quits when you close the channel.

29
00:01:46,980 --> 00:01:49,380
So this is another method on a channel.

30
00:01:49,380 --> 00:01:51,380
You can close a channel,
so you can see it,

31
00:01:51,380 --> 00:01:54,440
I have it in the last line,
highlighted in red.

32
00:01:54,440 --> 00:01:59,850
The sender, the person who's doing the
sending, it can call close on the channel.

33
00:01:59,850 --> 00:02:04,930
And if they call close on the channel,
then the receiver realizes close,

34
00:02:04,930 --> 00:02:07,000
and this for loop will end.

35
00:02:07,000 --> 00:02:09,460
Now, you don't have to ever
call close on a channel.

36
00:02:10,570 --> 00:02:11,320
It's not like a file,

37
00:02:11,320 --> 00:02:15,660
you don't have to call close on a channel,
unless you're doing what I'm showing here.

38
00:02:15,660 --> 00:02:18,250
Unless you're using a range construct.

39
00:02:18,250 --> 00:02:22,180
If you use this range keyword
to forever read from a channel

40
00:02:22,180 --> 00:02:24,960
you need to close the channel,
the sender needs to close the channel.

41
00:02:24,960 --> 00:02:27,970
So that the receiver eventually
knows I can quit this loop

42
00:02:27,970 --> 00:02:29,570
because now this channel is done.

43
00:02:29,570 --> 00:02:34,690
So the only time you would call close on
a channel is if, as a sender, you knew

44
00:02:34,690 --> 00:02:38,420
I am never going to send more data on this
channel again, then you can call close.

45
00:02:38,420 --> 00:02:42,895
And that basically sends a message to
the receiver to say now this channel is

46
00:02:42,895 --> 00:02:46,670
closed so you can jump out of the loop
whose range you're iterating through.

47
00:02:47,770 --> 00:02:51,050
So this is sort of a very common
thing to read from channels.

48
00:02:52,460 --> 00:02:58,730
Now, another thing that you might want to
do is read from multiple Goroutines, okay?

49
00:02:58,730 --> 00:03:02,790
From multiple channels really, which can
be associated with multiple Goroutines.

50
00:03:02,790 --> 00:03:05,940
There might be attributes associated
with the same Goroutine but

51
00:03:05,940 --> 00:03:08,440
reading from multiple channels,
put it like that.

52
00:03:08,440 --> 00:03:13,658
So, let's say in this example,
I got these three Goroutines, T1, T2, T3.

53
00:03:13,658 --> 00:03:16,980
T3 is receiving data from T1 and T2.

54
00:03:16,980 --> 00:03:23,190
And, from T1, it's receiving on Channel 1,
C1, and T2 is receiving on Channel, on C2.

55
00:03:23,190 --> 00:03:27,864
So T3 has these two channels
that it's receiving data from.

56
00:03:27,864 --> 00:03:33,200
Now, there are different scenarios
about reading from multiple channels.

57
00:03:33,200 --> 00:03:39,840
Maybe, like in the case I'm showing here,
maybe you need data on both channels.

58
00:03:39,840 --> 00:03:45,360
So for instance, totally it depends on the
application, but let's say T3 is trying

59
00:03:45,360 --> 00:03:50,670
to compute the product of the two numbers
we're starting from T1 and T2, okay?

60
00:03:50,670 --> 00:03:52,934
So if that's the case then
you do what I'm doing here,

61
00:03:52,934 --> 00:03:55,090
just read the two channels sequentially.

62
00:03:55,090 --> 00:03:58,838
A = arrow c1, b = arrow c2.

63
00:03:58,838 --> 00:04:00,586
So you read from both channels, and

64
00:04:00,586 --> 00:04:03,400
then once you get them both
then you print the product.

65
00:04:03,400 --> 00:04:04,780
Fine, it does the product.

66
00:04:04,780 --> 00:04:09,600
So in this case, T3 actually
needed data from both c1 and c2,

67
00:04:09,600 --> 00:04:15,600
it needed both channels to complete
it's task, the product, right?

68
00:04:15,600 --> 00:04:18,042
And these are blocking, right?

69
00:04:18,042 --> 00:04:23,758
These are blocking, so the first read will
wait until something is written under c1,

70
00:04:23,758 --> 00:04:28,740
but eventually, T2 will read from
both of them and it'll do its task.

71
00:04:28,740 --> 00:04:32,960
But this is an example where you
need data from multiple channels.

72
00:04:32,960 --> 00:04:35,110
But sometimes you have a choice.

73
00:04:35,110 --> 00:04:41,150
So sometimes you got a Goroutine which
can read from different channels,

74
00:04:41,150 --> 00:04:44,350
but it doesn't have to read from all
of them, it just needs one of them.

75
00:04:44,350 --> 00:04:46,870
One or the other, so
sort of there's an or relationship.

76
00:04:46,870 --> 00:04:51,990
You can get from this one, or this one, or
that one, you don't need all the channels.

77
00:04:51,990 --> 00:04:56,562
So if you have a situation like that where
you have a choice of which data to use,

78
00:04:56,562 --> 00:05:00,810
and whichever data comes in first
that's the one you want to use, right?

79
00:05:00,810 --> 00:05:04,237
So, say you got two channels, c1 and
c2, data could come in on c1,

80
00:05:04,237 --> 00:05:05,555
data could come in on c2.

81
00:05:05,555 --> 00:05:08,560
In this scenario,
whichever one comes in first first come,

82
00:05:08,560 --> 00:05:12,020
first serve that's the one I'm going
to use and do something with, okay?

83
00:05:12,020 --> 00:05:16,020
In that situation, you don't want to read
from both channel 1 and channel 2, right?

84
00:05:16,020 --> 00:05:18,890
If you read from both of them then
you're blocked on one of them.

85
00:05:18,890 --> 00:05:22,940
So say data gets sent on c1,
that read will work.

86
00:05:22,940 --> 00:05:26,490
But then the read on c2 will never
happen because maybe data never gets

87
00:05:26,490 --> 00:05:28,260
sent on c2, right?

88
00:05:28,260 --> 00:05:31,560
So you don't want to wait on c2 when
no data is going to come, right?

89
00:05:31,560 --> 00:05:32,490
And vice versa.

90
00:05:32,490 --> 00:05:35,800
Maybe data comes in on c2 but
not on c1, right?

91
00:05:35,800 --> 00:05:38,440
So you don't want to have
to wait on both of them.

92
00:05:38,440 --> 00:05:42,220
In the last slide, we waited on both
channels, c1 and c2, because we

93
00:05:42,220 --> 00:05:45,930
needed data from both channels and we knew
the data would come in on both channels.

94
00:05:45,930 --> 00:05:50,220
In this scenario, we just need
data from one of the channel and

95
00:05:50,220 --> 00:05:52,670
we don't know that data is going
to come in on all channels.

96
00:05:52,670 --> 00:05:55,700
Data might just come in on one of
the channels, and so we don't want to

97
00:05:55,700 --> 00:05:59,830
wait on all of them, we want to wait on
one of them, but we don't know which one.

98
00:05:59,830 --> 00:06:03,690
So that's the case we use a select
statement like I'm showing here.

99
00:06:03,690 --> 00:06:08,790
So select statement allows you to wait for
the first data from a set of channels.

100
00:06:08,790 --> 00:06:12,860
So in this case [COUGH] we
got two cases actually.

101
00:06:12,860 --> 00:06:16,310
So in the select you got the first case,
the second case.

102
00:06:16,310 --> 00:06:20,600
First case is waiting on c1 to write
it to a, second case is waiting on c2.

103
00:06:20,600 --> 00:06:23,650
And whichever one of
those two happens first,

104
00:06:23,650 --> 00:06:26,900
that's the one that's
going to get executed.

105
00:06:26,900 --> 00:06:29,997
So if the data comes on c1 first
it will do the first case and

106
00:06:29,997 --> 00:06:32,479
it'll skip the second case,
and visa versa.

107
00:06:34,759 --> 00:06:36,767
Thank you.

108
00:06:36,767 --> 00:06:39,033
Module 4, Synchronized Communication.

109
00:06:39,033 --> 00:06:40,500
Topic 1.2, Select.

110
00:06:42,620 --> 00:06:45,250
So we've been talking about select, and

111
00:06:45,250 --> 00:06:49,995
I showed how select allows you to choose
data from one of several channels.

112
00:06:49,995 --> 00:06:52,303
You don't have to block
on all the channels,

113
00:06:52,303 --> 00:06:54,810
you can just block on
the first one that comes in.

114
00:06:54,810 --> 00:06:58,630
The first one that satisfies when
data comes in, then you just wait for

115
00:06:58,630 --> 00:07:02,580
that and you can continue
your execution more quickly.

116
00:07:02,580 --> 00:07:05,860
Now, the way I described it before,

117
00:07:05,860 --> 00:07:09,190
I was assuming that we were
blocking on receiving data.

118
00:07:09,190 --> 00:07:11,494
But we can also block on sending data too.

119
00:07:11,494 --> 00:07:15,818
So, with select, your case can either
be receiving data from a channel or

120
00:07:15,818 --> 00:07:18,060
sending data on a channel.

121
00:07:18,060 --> 00:07:19,680
So I have that here.

122
00:07:19,680 --> 00:07:24,941
Let's say my first case I say a is
assigned to be arrow inchan, right?

123
00:07:24,941 --> 00:07:27,950
So I have some input
channel called inchan.

124
00:07:27,950 --> 00:07:31,790
And if something comes in on that,
they're eager to sign to that, and

125
00:07:31,790 --> 00:07:33,630
you print received a.

126
00:07:33,630 --> 00:07:37,150
Now the other case, instead of
a receiving it's a sending thing.

127
00:07:37,150 --> 00:07:41,020
So in the other case I'm taking some
number, b, I don't know what that is.

128
00:07:41,020 --> 00:07:43,430
I'm taking the number, b, and
I'm writing it to outchan.

129
00:07:44,480 --> 00:07:48,150
Now, note that either one of
these two cases can block, right?

130
00:07:48,150 --> 00:07:54,600
So reading from inchan, that will block if
nobody's actually sent anything on inchan.

131
00:07:54,600 --> 00:07:58,450
And outchan, write into outchan will
block if nobody is receiving on outchan.

132
00:07:58,450 --> 00:08:01,070
So either one of these
two cases can block.

133
00:08:01,070 --> 00:08:04,563
And what happens with select is,
whether it's a read or is a write,

134
00:08:04,563 --> 00:08:09,540
whichever one of the cases is unblocked
first, that's the case that's executed.

135
00:08:09,540 --> 00:08:14,210
So, in this case, if some data
came in on inchan first before

136
00:08:14,210 --> 00:08:18,320
outchan became available,
then you would execute the first case.

137
00:08:18,320 --> 00:08:23,159
Otherwise if some other Goroutine
did a read on outchan then

138
00:08:23,159 --> 00:08:27,210
the second case would be executed first.

139
00:08:27,210 --> 00:08:32,550
So I'll select either send or receive.

140
00:08:32,550 --> 00:08:35,682
You can block on either sends or
receives and select one of them,

141
00:08:35,682 --> 00:08:38,210
whichever one completes first,
that's the one you execute.

142
00:08:40,700 --> 00:08:45,720
Now, one common use of a select is

143
00:08:45,720 --> 00:08:50,190
to have a separate Abort channel, okay?

144
00:08:50,190 --> 00:08:54,150
So say there's some task that you're doing
over and over, you're reading data and

145
00:08:54,150 --> 00:08:55,270
processing it, right?

146
00:08:55,270 --> 00:08:57,381
So this is producer-consumer
scenario again, right?

147
00:08:57,381 --> 00:09:01,373
Something is producing some data and
sending it on a channel to you,

148
00:09:01,373 --> 00:09:02,900
the consumer.

149
00:09:02,900 --> 00:09:05,790
And your consumer, his job is
basically to receive the data and

150
00:09:05,790 --> 00:09:07,330
then do something with it.

151
00:09:07,330 --> 00:09:10,500
So let's assume that the code I have
here is for a consumer like that.

152
00:09:10,500 --> 00:09:13,970
Now, notice that first thing it's a for
loop, an infinite for loop, right?

153
00:09:13,970 --> 00:09:17,720
It's an infinite for loop,
because that's typical for our consumer,

154
00:09:17,720 --> 00:09:20,260
it's just going to keep receiving,
receiving, receiving.

155
00:09:20,260 --> 00:09:23,290
Now, then in there I select,
the first case

156
00:09:23,290 --> 00:09:28,270
is to receive data on the c channel and
assign it to a, and then I process it.

157
00:09:28,270 --> 00:09:30,300
In this case, I just print a.

158
00:09:30,300 --> 00:09:35,015
And so I'll keep doing that, receiving
data, processing, receiving data, process,

159
00:09:35,015 --> 00:09:37,382
until eventually there's an abort signal.

160
00:09:37,382 --> 00:09:43,118
So somehow an abort happens, and
that can happen any number of ways.

161
00:09:43,118 --> 00:09:46,660
Maybe another Goroutine
receives user input,

162
00:09:46,660 --> 00:09:49,060
the input user types in
something that says quit.

163
00:09:49,060 --> 00:09:49,995
Who knows, right?

164
00:09:49,995 --> 00:09:54,730
So, normally what it wants
to do is that first case,

165
00:09:54,730 --> 00:09:56,090
receive data, process the data.

166
00:09:56,090 --> 00:09:59,356
But at some point there is an abort
that comes in on another channel.

167
00:09:59,356 --> 00:10:01,730
So you have this separate abort channel,
and

168
00:10:01,730 --> 00:10:05,715
if anything comes in on the abort channel,
then you just return.

169
00:10:05,715 --> 00:10:07,390
Right, you just quit the whole process.

170
00:10:07,390 --> 00:10:10,380
Quit the whole loop.

171
00:10:10,380 --> 00:10:16,240
So basically this is normally an infinite
for loop until that abort happens.

172
00:10:16,240 --> 00:10:19,170
So if some data comes in, and
notice that we are not paying attention

173
00:10:19,170 --> 00:10:21,360
to the date of that comes
in on the abort channel.

174
00:10:21,360 --> 00:10:24,320
Notice that it just says case arrow abort.

175
00:10:24,320 --> 00:10:28,200
I didn't say case x equals arrow abort,
I just said case arrow abort.

176
00:10:28,200 --> 00:10:31,010
So I don't care what data is coming into
the abort channel, if something comes

177
00:10:31,010 --> 00:10:35,460
in on the abort channel, that means
the user wants to abort, or somebody is

178
00:10:35,460 --> 00:10:38,820
ordering you to quit this loop, and
then you just return at that point.

179
00:10:38,820 --> 00:10:41,350
So this is a common use of select.

180
00:10:41,350 --> 00:10:45,880
So you can have this separate channel
that happens probably infrequently.

181
00:10:45,880 --> 00:10:48,744
So most of the time, you're going
through the first case, reading data and

182
00:10:48,744 --> 00:10:51,205
processing it off the normal channel,
but every once in a while,

183
00:10:51,205 --> 00:10:53,712
at some point somebody is going to
want to abort your procedure, and so

184
00:10:53,712 --> 00:10:55,849
you have a separate abort
channel that you select from.

185
00:10:57,977 --> 00:11:02,610
Another thing that's done with
select is to have a default case.

186
00:11:02,610 --> 00:11:08,335
So this is a lot like a case switch in c,
it looks like it.

187
00:11:08,335 --> 00:11:10,620
It's not the same, but
it has similar structure.

188
00:11:10,620 --> 00:11:12,520
You can have a default case.

189
00:11:12,520 --> 00:11:17,240
So in this case, we got the regular
cases are waiting on channel 1,

190
00:11:17,240 --> 00:11:19,250
then the second one is
waiting on channel 2.

191
00:11:19,250 --> 00:11:22,250
The default says, look,
I don't want to wait on anything.

192
00:11:22,250 --> 00:11:27,200
If none of those other
cases are satisfied, then

193
00:11:27,200 --> 00:11:31,270
I will execute the default, so I won't
wait, I won't block at all in this case.

194
00:11:31,270 --> 00:11:34,546
When I have a default,
you don't block, you just go and

195
00:11:34,546 --> 00:11:38,121
execute the default if none of
the previous cases are ready.

196
00:11:40,056 --> 00:11:41,510
Thank you.