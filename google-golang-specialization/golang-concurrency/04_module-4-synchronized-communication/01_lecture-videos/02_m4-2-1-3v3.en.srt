1
00:00:00,660 --> 00:00:03,345
Module 4: Threads in Go.

2
00:00:03,345 --> 00:00:06,500
Topic 2.1: Mutual Exclusion.

3
00:00:06,600 --> 00:00:10,555
So, we've been talking about channels.

4
00:00:10,555 --> 00:00:14,280
Goroutines are sending data back and forth through channels.

5
00:00:14,280 --> 00:00:22,070
Now, sharing variables between goroutines can cause problems.

6
00:00:22,070 --> 00:00:25,535
I'll show you an example of this,

7
00:00:25,535 --> 00:00:29,580
but two goroutines writing to a shared variable,

8
00:00:29,580 --> 00:00:31,070
to the same shared variable,

9
00:00:31,070 --> 00:00:33,000
can interfere with each other.

10
00:00:33,000 --> 00:00:37,050
So, one will try to write one number,

11
00:00:37,050 --> 00:00:40,060
the other will try to write the other number and they will get into

12
00:00:40,060 --> 00:00:43,530
an inconsistent state and I'll give you a more concrete example of that in a few slides.

13
00:00:43,530 --> 00:00:52,070
A thread program is said to be concurrency safe if it can be executed,

14
00:00:52,070 --> 00:00:55,120
be invoked concurrently with other goroutines

15
00:00:55,120 --> 00:00:58,005
without interfering improperly with the other goroutines.

16
00:00:58,005 --> 00:01:00,430
So, then you say, oh this is concurrency is safe because I

17
00:01:00,430 --> 00:01:03,160
know that when this runs it won't mess with

18
00:01:03,160 --> 00:01:06,080
the variables of the other goroutines and alter them in

19
00:01:06,080 --> 00:01:09,130
some way that will ruin the other goroutines.

20
00:01:09,130 --> 00:01:11,500
So, by this I mean, not that one goroutine

21
00:01:11,500 --> 00:01:14,515
can mess up the execution of another goroutine, right?

22
00:01:14,515 --> 00:01:16,915
To, say this one goroutine is using a variable x,

23
00:01:16,915 --> 00:01:21,510
the other goroutine writes to that variable x while the first goroutine is using it,

24
00:01:21,510 --> 00:01:24,400
maybe the second goroutine didn't intend for that

25
00:01:24,400 --> 00:01:27,200
variable to be written by this first goroutine.

26
00:01:27,200 --> 00:01:30,810
So, the first one goroutine can interfere with other goroutines.

27
00:01:30,810 --> 00:01:35,870
A function is said to be concurrency safe if you know that that won't happen,

28
00:01:35,870 --> 00:01:38,495
that they won't interfere in these unsafe ways.

29
00:01:38,495 --> 00:01:44,030
So, let me just give you some example of what I mean by bad sharing,

30
00:01:44,030 --> 00:01:45,980
how can that happen and how can they interfere with each other.

31
00:01:45,980 --> 00:01:47,970
So let's be a little more concrete.

32
00:01:47,970 --> 00:01:53,345
Okay. Here's an example of variable sharing going on.

33
00:01:53,345 --> 00:01:56,670
Now, all of this is going to do is,

34
00:01:56,670 --> 00:01:59,810
all it really does is it increments the variable i.

35
00:01:59,810 --> 00:02:02,025
So, there's this variable i,

36
00:02:02,025 --> 00:02:03,510
we're going to start it off at zero,

37
00:02:03,510 --> 00:02:05,130
and I'm going to make two threads.

38
00:02:05,130 --> 00:02:08,600
In my main I'm going to make two threads which just increment

39
00:02:08,600 --> 00:02:13,105
i and each one is going to increment it once.

40
00:02:13,105 --> 00:02:15,175
So, by the time they're done,

41
00:02:15,175 --> 00:02:16,395
i should equal two.

42
00:02:16,395 --> 00:02:18,130
So I should start off as zero,

43
00:02:18,130 --> 00:02:23,090
you run these two threads to increment i and then at the end i should equal two.

44
00:02:23,090 --> 00:02:25,060
So, just to look at the structure of the code,

45
00:02:25,060 --> 00:02:26,385
there are two functions,

46
00:02:26,385 --> 00:02:29,385
the main and the inc function for increment.

47
00:02:29,385 --> 00:02:32,665
At the very top I'm just declaring this global variable i,

48
00:02:32,665 --> 00:02:34,190
also I'm declaring my weight group,

49
00:02:34,190 --> 00:02:37,460
remember I make a weight group so that the main doesn't complete before

50
00:02:37,460 --> 00:02:41,840
the goroutines or before the sub-goroutines have a chance to execute.

51
00:02:41,840 --> 00:02:44,480
So I make the weight group. Now, my increment

52
00:02:44,480 --> 00:02:47,150
function all it does is i equals i plus one and

53
00:02:47,150 --> 00:02:49,265
then it calls our wg done

54
00:02:49,265 --> 00:02:52,895
to know that you don't have to wait for it anymore, it is now done.

55
00:02:52,895 --> 00:02:59,915
Now then, my main function I execute wg.add,

56
00:02:59,915 --> 00:03:03,050
I call the add method and I add two because I'm going to wait on

57
00:03:03,050 --> 00:03:05,420
two goroutines because I'm going to

58
00:03:05,420 --> 00:03:08,225
have two goroutine I'm going to create the do incrementing.

59
00:03:08,225 --> 00:03:11,960
So I add two, then I invoke the two goroutines.

60
00:03:11,960 --> 00:03:13,590
So, go inc, go inc,

61
00:03:13,590 --> 00:03:15,882
both of them, should just increment this i.

62
00:03:15,882 --> 00:03:20,615
And then, I do weight, wg.Wait, waiting for both of these guys to finish,

63
00:03:20,615 --> 00:03:23,005
and then at the end I just print i.

64
00:03:23,005 --> 00:03:25,985
So, what I expect is that I should print two.

65
00:03:25,985 --> 00:03:28,140
Because i starts off at zero,

66
00:03:28,140 --> 00:03:29,630
I initialized the zero at the top,

67
00:03:29,630 --> 00:03:31,245
it should be two when it's done.

68
00:03:31,245 --> 00:03:33,700
But this doesn't always happen.

69
00:03:33,700 --> 00:03:38,000
So, let's explain why this doesn't happen.

70
00:03:38,800 --> 00:03:42,170
Sometimes it doesn't happen because of all the possible interleavings.

71
00:03:42,170 --> 00:03:44,049
Now at first glance,

72
00:03:44,049 --> 00:03:47,245
it would seem like there's no real problem here because

73
00:03:47,245 --> 00:03:51,060
there are different interleaving but the interleavings all look reasonable,

74
00:03:51,060 --> 00:03:53,970
they look like they don't cause a problem at a glance.

75
00:03:53,970 --> 00:03:56,870
So, what I'm showing here is this table,

76
00:03:56,870 --> 00:03:59,755
there are two tables, two different interleavings.

77
00:03:59,755 --> 00:04:03,205
Each one of these tables has task one on the left, task two on the right,

78
00:04:03,205 --> 00:04:05,680
task two in the middle and then on the right is the value of i,

79
00:04:05,680 --> 00:04:08,470
I just want to keep track of the value of i as we go through the code.

80
00:04:08,470 --> 00:04:10,710
Notice, I'm not showing all task one and task two.

81
00:04:10,710 --> 00:04:14,250
I'm not showing the done calls.

82
00:04:14,250 --> 00:04:17,180
The ordering of the done calls doesn't really matter for this.

83
00:04:17,180 --> 00:04:20,940
But I'm showing that there are two different orderings for the i equals i plus one.

84
00:04:20,940 --> 00:04:22,905
So in the first in the top one,

85
00:04:22,905 --> 00:04:28,445
the top chart, task one executes i equals i plus one first,

86
00:04:28,445 --> 00:04:30,310
then task two executes it's second.

87
00:04:30,310 --> 00:04:32,590
In the bottom, task one execute second,

88
00:04:32,590 --> 00:04:34,100
task two executes first.

89
00:04:34,100 --> 00:04:36,325
But either one of those two orders,

90
00:04:36,325 --> 00:04:38,820
the value of i ends up correct.

91
00:04:38,820 --> 00:04:41,290
So, if you look at the top ordering look at i,

92
00:04:41,290 --> 00:04:44,955
it's zero at first, after the first increment it becomes one,

93
00:04:44,955 --> 00:04:46,910
after the second increment it becomes two.

94
00:04:46,910 --> 00:04:53,125
Same thing on the bottom even though the task two does this increment first,

95
00:04:53,125 --> 00:04:57,120
it doesn't really matter because i is incremented twice still,

96
00:04:57,120 --> 00:04:59,290
so it goes from zero to one, one to two.

97
00:04:59,290 --> 00:05:01,970
So, it looks like either one of these interleaving is

98
00:05:01,970 --> 00:05:05,370
just fine and it shouldn't change the value of i,

99
00:05:05,370 --> 00:05:07,100
but that is deceiving.

100
00:05:07,100 --> 00:05:11,725
So, really there are a lot more interleaving than we're seeing here.

101
00:05:11,725 --> 00:05:15,350
The reason is because of the level at which this concurrency,

102
00:05:15,350 --> 00:05:17,404
this interleaving actually happens.

103
00:05:17,404 --> 00:05:20,825
So, concurrency is at the machine code level,

104
00:05:20,825 --> 00:05:22,735
not the source code level.

105
00:05:22,735 --> 00:05:28,080
So, what I mean by this is that the interleaving is not interleaving of go instructions,

106
00:05:28,080 --> 00:05:29,210
go source code instructions,

107
00:05:29,210 --> 00:05:33,485
where it's actually getting interleaved at the underlying machine code instructions.

108
00:05:33,485 --> 00:05:35,990
So remember, the go source code is

109
00:05:35,990 --> 00:05:39,410
compiled to machine code on whatever platform you're on.

110
00:05:39,410 --> 00:05:43,145
So, these machine instructions which are sort of smaller instructions,

111
00:05:43,145 --> 00:05:45,295
those are what are actually getting interleaved.

112
00:05:45,295 --> 00:05:49,130
So, what that means is for each one of these go source code instructions,

113
00:05:49,130 --> 00:05:52,565
there can be a sequence

114
00:05:52,565 --> 00:05:56,030
of machine code instructions that correspond to the go source code instruction.

115
00:05:56,030 --> 00:06:02,000
So, the interleaving can basically partition, can chop up,

116
00:06:02,000 --> 00:06:05,635
interrupt right in the middle of a go source code instruction,

117
00:06:05,635 --> 00:06:08,110
it can start interleaving right in the middle of it.

118
00:06:08,110 --> 00:06:10,205
So, let's be more concrete.

119
00:06:10,205 --> 00:06:11,860
Let's take i equals i plus one,

120
00:06:11,860 --> 00:06:13,810
the instruction that we're basically looking at right now.

121
00:06:13,810 --> 00:06:20,140
Now, that might be typically that could map to three machine code instructions.

122
00:06:20,140 --> 00:06:24,635
First, a read i where you read the value of i from memory.

123
00:06:24,635 --> 00:06:28,955
Because remember that most of these machines they're register-based.

124
00:06:28,955 --> 00:06:31,585
So, when you do the increment operation,

125
00:06:31,585 --> 00:06:33,360
you can't just increment directly in memory.

126
00:06:33,360 --> 00:06:35,715
I mean, there are processes that do that but most of the time

127
00:06:35,715 --> 00:06:39,740
you first read the data from memory into a register,,

128
00:06:39,740 --> 00:06:44,845
then you do the arithmetic manipulation and then you write the result back to memory.

129
00:06:44,845 --> 00:06:47,055
So, those are the three steps I'm showing here.

130
00:06:47,055 --> 00:06:50,370
Read i, it goes to memory to wherever the value of i is,

131
00:06:50,370 --> 00:06:51,590
brings it into some register,

132
00:06:51,590 --> 00:06:55,280
then increment just takes the contents that register as one,

133
00:06:55,280 --> 00:06:57,440
then write takes the contents of that register

134
00:06:57,440 --> 00:07:00,490
and writes it back to memory wherever i is supposed to go.

135
00:07:00,490 --> 00:07:02,580
So, that i equals i plus one,

136
00:07:02,580 --> 00:07:03,755
it looks like one instruction,

137
00:07:03,755 --> 00:07:05,660
is one go instruction but it's really

138
00:07:05,660 --> 00:07:08,355
a sequence of these three machine code instructions.

139
00:07:08,355 --> 00:07:11,360
Now, this is important to keep in

140
00:07:11,360 --> 00:07:14,385
mind because the interleaving actually happens at that level.

141
00:07:14,385 --> 00:07:18,020
So, and that's what gets confusing because see normally,

142
00:07:18,020 --> 00:07:21,290
programmers aren't thinking about the machine code when they're writing

143
00:07:21,290 --> 00:07:23,120
their code or if they were then they'd be writing

144
00:07:23,120 --> 00:07:25,230
machine code directly where assembly go to code straight.

145
00:07:25,230 --> 00:07:27,425
Now generally, if you're writing go code you're thinking

146
00:07:27,425 --> 00:07:29,740
source code level, go instructions.

147
00:07:29,740 --> 00:07:31,560
You're not thinking about the way that

148
00:07:31,560 --> 00:07:34,300
the go instructions are subdivided into machine code instructions,

149
00:07:34,300 --> 00:07:37,705
not unless you're a hardcore coder,

150
00:07:37,705 --> 00:07:39,445
you usually don't think about that.

151
00:07:39,445 --> 00:07:41,340
So this is where people can get tripped up.

152
00:07:41,340 --> 00:07:43,340
So, let's show the interleaving,

153
00:07:43,340 --> 00:07:44,965
the different possible interleavings again.

154
00:07:44,965 --> 00:07:48,475
Except this time, instead of just looking at the two interleavings,

155
00:07:48,475 --> 00:07:52,355
task one does the increment first or it does the second right those are the two.

156
00:07:52,355 --> 00:07:55,740
Now we're going to take these three instructions,

157
00:07:55,740 --> 00:08:00,100
these three machine instructions and interleave those and show how it can go wrong.

158
00:08:00,150 --> 00:08:03,755
So, here's an example where it goes wrong.

159
00:08:03,755 --> 00:08:05,985
So this time you got task one left,

160
00:08:05,985 --> 00:08:07,910
I'd say I've the very left column I've

161
00:08:07,910 --> 00:08:10,440
just numbered the underlined so I can refer to them.

162
00:08:10,440 --> 00:08:15,530
But you got task one and task two and then on the right you got the value of i.

163
00:08:15,530 --> 00:08:19,385
Now, task one if you look at just a task one's column,

164
00:08:19,385 --> 00:08:22,005
first it's going to do a read in step one,

165
00:08:22,005 --> 00:08:23,885
then in step three is going to do the increment,

166
00:08:23,885 --> 00:08:25,500
then step four it does the write.

167
00:08:25,500 --> 00:08:27,735
Task two it has the same order.

168
00:08:27,735 --> 00:08:30,460
In step two is going to do a read,

169
00:08:30,460 --> 00:08:32,745
then step six it does an increment,

170
00:08:32,745 --> 00:08:35,090
step seven it does a write.

171
00:08:35,090 --> 00:08:41,080
So, fine, in each one of these tasks,

172
00:08:41,080 --> 00:08:44,790
the ordering stays the same but the relative interleaving can be different.

173
00:08:44,790 --> 00:08:46,790
So, notice the interleaving that we've picked and I've

174
00:08:46,790 --> 00:08:49,500
highlighted the read instructions, read i, read i.

175
00:08:49,500 --> 00:08:51,275
Task one does a read,

176
00:08:51,275 --> 00:08:56,505
read i in step one and task two does a read i in step two.

177
00:08:56,505 --> 00:09:01,305
So, what happens is both of them have read the same value of i.

178
00:09:01,305 --> 00:09:04,425
So, note that the value of i at the beginning is zero.

179
00:09:04,425 --> 00:09:08,690
So, task one and task two have both read values as zero for i.

180
00:09:08,690 --> 00:09:12,965
Then task one goes ahead in step three and in step four it

181
00:09:12,965 --> 00:09:15,050
increments that zero to a one and then it

182
00:09:15,050 --> 00:09:17,490
writes it back to the location memory where i goes.

183
00:09:17,490 --> 00:09:19,820
So, it writes a one into the location memory where

184
00:09:19,820 --> 00:09:22,495
i goes and you can see that i is equal to one.

185
00:09:22,495 --> 00:09:24,720
But remember that task two,

186
00:09:24,720 --> 00:09:27,790
the read that it did in step two is still read as zero.

187
00:09:27,790 --> 00:09:31,790
So, by the time task two does it increment in step six,

188
00:09:31,790 --> 00:09:35,810
it's incrementing what it read was a zero, which was a zero.

189
00:09:35,810 --> 00:09:40,400
It's not incrementing the actual value of i in memory which is now a one.

190
00:09:40,400 --> 00:09:44,000
Remember task one wrote a one back to memory in step four,

191
00:09:44,000 --> 00:09:45,900
but that's not what was read by task two.

192
00:09:45,900 --> 00:09:47,315
Because of this interleaving,

193
00:09:47,315 --> 00:09:50,025
task two read the old value of i zero.

194
00:09:50,025 --> 00:09:56,590
So, task two in step six it increments zero to one and then it writes a one in for i.

195
00:09:56,590 --> 00:09:58,720
Now, there was already a one in there for i,

196
00:09:58,720 --> 00:10:00,330
writes another one in there for i.

197
00:10:00,330 --> 00:10:02,055
But at the end of the sequence,

198
00:10:02,055 --> 00:10:04,570
i has the value one instead of two.

199
00:10:04,570 --> 00:10:09,520
So, think about this for a little while but the idea,

200
00:10:09,520 --> 00:10:18,235
the general problem is that when these two goroutines are sharing this i variable,

201
00:10:18,235 --> 00:10:20,125
they're both writing to it.

202
00:10:20,125 --> 00:10:23,450
The interleaving is happening at a finer granularity,

203
00:10:23,450 --> 00:10:25,580
at the machine code level and that adds

204
00:10:25,580 --> 00:10:30,015
complications that people don't think about sometimes.

205
00:10:30,015 --> 00:10:32,735
So, it's important to be aware of these.

206
00:10:32,735 --> 00:10:38,925
Thank you. Module 4: Threads and Go.

207
00:10:38,925 --> 00:10:41,770
Topic 2.2: Mutex.

208
00:10:41,940 --> 00:10:47,205
So, how we do sharing of data correctly between goroutines?

209
00:10:47,205 --> 00:10:49,325
Don't let two goroutines

210
00:10:49,325 --> 00:10:52,575
write to a shared variable at the same time, just as a rule of thumb.

211
00:10:52,575 --> 00:10:54,295
Don't let that happen because you can get

212
00:10:54,295 --> 00:10:58,610
these interleavings that are going to cause the problem that we just saw.

213
00:10:58,610 --> 00:11:03,630
So, you need to restrict the possible interleavings of these goroutines.

214
00:11:03,630 --> 00:11:05,070
Say there are two goroutines,

215
00:11:05,070 --> 00:11:06,565
goroutine one and two,

216
00:11:06,565 --> 00:11:08,585
which are both writing to this variable i,

217
00:11:08,585 --> 00:11:10,880
to the shared data.

218
00:11:10,880 --> 00:11:14,020
Then you have to restrict their interleavings in

219
00:11:14,020 --> 00:11:18,505
such a way that you make sure that they can't both write to it at the same time.

220
00:11:18,505 --> 00:11:22,315
So, access to the shared variables cannot be interleaved.

221
00:11:22,315 --> 00:11:25,500
You have to somehow as a programmer ensure that they can't

222
00:11:25,500 --> 00:11:28,850
both do that at the same time. So, how do you do that?

223
00:11:28,850 --> 00:11:30,620
That is called mutual exclusion.

224
00:11:30,620 --> 00:11:32,270
You need to have code segments,

225
00:11:32,270 --> 00:11:35,030
you as a programmer have to declare code segments in

226
00:11:35,030 --> 00:11:38,320
these different goroutines which cannot execute concurrently,

227
00:11:38,320 --> 00:11:41,120
so that they cannot be interleaved.

228
00:11:41,120 --> 00:11:44,510
So, this action of say writing to shared variables.

229
00:11:44,510 --> 00:11:48,980
So, say these two goroutines both write to i. i equals i plus one, i equals i plus one.

230
00:11:48,980 --> 00:11:53,295
You've got to make sure that this goroutines segment where it writes to i,

231
00:11:53,295 --> 00:11:59,645
cannot as mutually exclusive with the writing to i for this other goroutine.

232
00:11:59,645 --> 00:12:03,235
So, you have to declare these segments

233
00:12:03,235 --> 00:12:07,710
of code that are mutually exclusive with one another,

234
00:12:07,710 --> 00:12:09,370
and you have to do that as a programmer.

235
00:12:09,370 --> 00:12:10,810
So, there are constructs, of course,

236
00:12:10,810 --> 00:12:13,920
built into Golang to do that.

237
00:12:13,920 --> 00:12:19,165
So, what we're going to use is in the sync package again,

238
00:12:19,165 --> 00:12:21,610
there's this mutex object.

239
00:12:21,610 --> 00:12:24,780
Mutex ensures mutual exclusion.

240
00:12:24,780 --> 00:12:27,360
There are several methods associated with mutex,

241
00:12:27,360 --> 00:12:30,035
but let me just describe it conceptually first.

242
00:12:30,035 --> 00:12:33,025
It uses what's generally called a binary semaphore.

243
00:12:33,025 --> 00:12:36,160
So, semaphore is like the flag on your mailbox.

244
00:12:36,160 --> 00:12:38,325
If you have one of those outdoor mailboxes.

245
00:12:38,325 --> 00:12:43,115
So, if the flag is up that means the shared variable is in use.

246
00:12:43,115 --> 00:12:47,850
That means that somebody is using the shared variable.

247
00:12:47,850 --> 00:12:50,340
So, like specifically, the shared variable,

248
00:12:50,340 --> 00:12:52,440
if we're trying to protect this variable i.

249
00:12:52,440 --> 00:12:55,235
There are two goroutines that are writing to i.

250
00:12:55,235 --> 00:12:57,395
Only one can do it at a time.

251
00:12:57,395 --> 00:13:01,930
So, the flag should be up when one goroutine is writing to i.

252
00:13:01,930 --> 00:13:04,970
Then the flag being down means the shared variable is available.

253
00:13:04,970 --> 00:13:08,335
So, when this one goroutine is done writing to i,

254
00:13:08,335 --> 00:13:10,625
then the flag goes back down.

255
00:13:10,625 --> 00:13:13,000
Then the other goroutine knows, "Oh!

256
00:13:13,000 --> 00:13:14,355
Now I see the flag is down,

257
00:13:14,355 --> 00:13:16,795
I can write to i if I want to."

258
00:13:16,795 --> 00:13:20,555
So each one of these goroutines has to adhere to this protocol.

259
00:13:20,555 --> 00:13:23,635
Meaning, there's a semaphore in this flag and is binary.,

260
00:13:23,635 --> 00:13:24,710
these are up or down,

261
00:13:24,710 --> 00:13:26,380
zero or one 1.

262
00:13:26,380 --> 00:13:31,435
If the flag is up then you are not allowed to use the shared variable.

263
00:13:31,435 --> 00:13:33,070
Because that means somebody else,

264
00:13:33,070 --> 00:13:34,590
some other goroutine is using it.

265
00:13:34,590 --> 00:13:38,320
If the flag is down then you are allowed to use the shared variable,

266
00:13:38,320 --> 00:13:39,820
but you have to put the flag up first.

267
00:13:39,820 --> 00:13:42,615
So, you have to put the flag up and then use a shared variable,

268
00:13:42,615 --> 00:13:44,380
and when you're done using the shared variable,

269
00:13:44,380 --> 00:13:47,020
you have to put the flag back down so everybody else,

270
00:13:47,020 --> 00:13:49,635
all the other goroutines, know they can use a shared variable.

271
00:13:49,635 --> 00:13:52,890
So, it is this protocol that the programmer has

272
00:13:52,890 --> 00:13:56,395
to write into their code and adhere to in order for this scheme to work.

273
00:13:56,395 --> 00:13:59,690
But this is the idea. Thank you.

274
00:14:01,260 --> 00:14:03,940
Module four, Threads in Go,

275
00:14:03,940 --> 00:14:06,980
Topic 2.3 Mutex Methods.

276
00:14:07,410 --> 00:14:12,440
So, we talked about this semaphores inside the mutex.

277
00:14:12,440 --> 00:14:14,010
You put the flag up,

278
00:14:14,010 --> 00:14:21,465
put it up to declare a goroutine is using the shared data,

279
00:14:21,465 --> 00:14:25,720
it's writing to it, and then put the flag down when you're done writing to it.

280
00:14:25,720 --> 00:14:29,765
So, these are implemented in a set of methods, lock and unlock.

281
00:14:29,765 --> 00:14:33,175
So, lock when you call lock that basically puts the flag up,

282
00:14:33,175 --> 00:14:36,110
and when you call unlock, it puts the flag down.

283
00:14:36,260 --> 00:14:42,150
Goroutine should call lock before it's about to use the shared data.

284
00:14:42,150 --> 00:14:45,850
What'll happen is, if no one has the lock,

285
00:14:45,850 --> 00:14:48,175
meaning no goroutines are using the shared data,

286
00:14:48,175 --> 00:14:51,780
then that first lock that call to lock will proceed.

287
00:14:51,780 --> 00:14:53,285
It'll put the flag up,

288
00:14:53,285 --> 00:14:58,445
meaning it sets some binary value from zero to one internally and then it will continue.

289
00:14:58,445 --> 00:14:59,720
So, it will not bloc.

290
00:14:59,720 --> 00:15:01,830
The code will execute in

291
00:15:01,830 --> 00:15:05,115
that mutually exclusive region and it will access the shared variable.

292
00:15:05,115 --> 00:15:07,435
Now, while that's going on,

293
00:15:07,435 --> 00:15:11,315
say another goroutine comes along and calls lock.

294
00:15:11,315 --> 00:15:14,830
Now, remember at this point when the second goroutine comes along and calls lock,

295
00:15:14,830 --> 00:15:16,705
the flag is already up.

296
00:15:16,705 --> 00:15:18,905
So, when that happens,

297
00:15:18,905 --> 00:15:20,775
this lock will block.

298
00:15:20,775 --> 00:15:25,575
It won't allow the second goroutine to continue and access the shared data.

299
00:15:25,575 --> 00:15:27,240
So it stops the second one.

300
00:15:27,240 --> 00:15:31,220
So, whichever goroutine gets into that region calls lock first,

301
00:15:31,220 --> 00:15:33,405
it gets the lock and the other guy,

302
00:15:33,405 --> 00:15:35,335
whoever the other one is, it has to wait.

303
00:15:35,335 --> 00:15:38,160
Notice that we're talking about two goroutines.

304
00:15:38,160 --> 00:15:39,570
This could be any number of goroutines.

305
00:15:39,570 --> 00:15:46,355
You can have 10 goroutines all try to share the same i variables something like that.

306
00:15:46,355 --> 00:15:49,435
One of them gets in there first calls lock first,

307
00:15:49,435 --> 00:15:51,970
then there could be nine other ones that try to call lock

308
00:15:51,970 --> 00:15:55,210
while the first ones in there and all nine will block.

309
00:15:55,210 --> 00:15:58,645
So, that's basically what lock does.

310
00:15:58,645 --> 00:16:00,865
Now, unlock is the matching thing.

311
00:16:00,865 --> 00:16:04,905
So, unlock is the function that gets called when

312
00:16:04,905 --> 00:16:07,060
the goroutine is actually done using

313
00:16:07,060 --> 00:16:10,160
the shared data and it's effectively putting that flag down.

314
00:16:10,160 --> 00:16:14,380
So, when this one goroutine is done using a shared data,

315
00:16:14,380 --> 00:16:18,145
it's got to call unlock if it doesn't that's an error because it'll cause a deadlock.

316
00:16:18,145 --> 00:16:21,730
It calls unlock, and then what will happen is,

317
00:16:21,820 --> 00:16:25,020
one of the goroutines that are waiting,

318
00:16:25,020 --> 00:16:26,805
they're blocked on their lock,

319
00:16:26,805 --> 00:16:28,650
will be able to continue.

320
00:16:28,650 --> 00:16:32,855
So, if there were like nine goroutines that call lock and are now blocked,

321
00:16:32,855 --> 00:16:34,595
as soon as unlock is called,

322
00:16:34,595 --> 00:16:37,610
the first one that called lock that is in waiting list,

323
00:16:37,610 --> 00:16:40,360
it will be allowed to continue,

324
00:16:40,360 --> 00:16:42,480
it'll stop blocking, it'll be allowed to continue,

325
00:16:42,480 --> 00:16:44,830
it will access the shared variable.

326
00:16:44,830 --> 00:16:49,550
In this way, as long as every goroutine

327
00:16:49,550 --> 00:16:51,200
calls lock at the beginning of it's

328
00:16:51,200 --> 00:16:54,645
mutually exclusive region and calls unlock at the end,

329
00:16:54,645 --> 00:17:02,645
then, it ensures that only one of these goroutines can be inside this region,

330
00:17:02,645 --> 00:17:04,325
this mutually exclusive region.

331
00:17:04,325 --> 00:17:08,205
Which in our case is basically where the shared variables are being written to.

332
00:17:08,205 --> 00:17:12,310
So, this mechanism is sort of generalizable to lots of

333
00:17:12,310 --> 00:17:16,760
different goroutines even though we're only talking about two right now.

334
00:17:16,760 --> 00:17:19,025
Here's a little example of it,

335
00:17:19,025 --> 00:17:21,030
how we would modify this incrementing problem.

336
00:17:21,030 --> 00:17:22,969
So this Incrementing problem that we had,

337
00:17:22,969 --> 00:17:24,405
I'm fixing it now.

338
00:17:24,405 --> 00:17:29,445
I'll go to this increment function and now basically I've done a couple of things,

339
00:17:29,445 --> 00:17:31,220
if you look at the second line,

340
00:17:31,220 --> 00:17:34,580
I've created a mutex, so call it 'mut'.

341
00:17:34,580 --> 00:17:38,265
Then, the increment function is still this i equals i plus one,

342
00:17:38,265 --> 00:17:44,115
but before that it calls 'mut.loc' and after that it calls 'mut.unlock'.

343
00:17:44,115 --> 00:17:47,305
So, now that region in between the lock and the unlock that is

344
00:17:47,305 --> 00:17:51,235
mutually exclusive with any other lock/unlock region.

345
00:17:51,235 --> 00:17:53,905
So, remember with this example,

346
00:17:53,905 --> 00:17:55,620
these goroutines, I had two goroutines we're

347
00:17:55,620 --> 00:17:58,370
calling that would basically execute increment.

348
00:17:58,370 --> 00:18:02,770
So both of them have a lock and unlock since they're both executing the same function,

349
00:18:02,770 --> 00:18:07,000
increment function, they both have a lock and unlock before and after their regions.

350
00:18:07,000 --> 00:18:08,525
So, those regions are exclusive.

351
00:18:08,525 --> 00:18:14,665
So, only one of those two goroutines can be executing i equals i plus one at a time.

352
00:18:14,665 --> 00:18:16,900
Because once one of them gets in there and calls lock,

353
00:18:16,900 --> 00:18:19,445
the other one is blocked on that lock.

354
00:18:19,445 --> 00:18:21,070
Until the first one finishes,

355
00:18:21,070 --> 00:18:23,540
calls unlock then the second one go through.

356
00:18:23,540 --> 00:18:29,520
So, that's a simple example of how you would do mutual exclusion. Thank you.