1
00:00:00,100 --> 00:00:02,740
Module 4, Threads in Go.

2
00:00:02,740 --> 00:00:05,985
Topic 3.1, Once Synchronization.

3
00:00:05,985 --> 00:00:09,765
So, we've been talking about Goroutines

4
00:00:09,765 --> 00:00:13,505
and we're going to talk about some of the features of the sync package.

5
00:00:13,505 --> 00:00:18,210
So sync packages gives you a set of methods that we can use to do synchronization between

6
00:00:18,210 --> 00:00:20,040
different Goroutines and here's

7
00:00:20,040 --> 00:00:24,390
another useful idiom that people form a lot, is initialization.

8
00:00:24,390 --> 00:00:27,750
So, say you've got some multithreaded i.e.

9
00:00:27,750 --> 00:00:33,150
multigo routine program running and you need to perform some initialization task.

10
00:00:33,150 --> 00:00:36,670
Now, by definition initialization is something that should happen once,

11
00:00:36,670 --> 00:00:40,640
happen only one time and it has to happen before everything else happens.

12
00:00:40,640 --> 00:00:42,755
It should be the first thing, it's initial.

13
00:00:42,755 --> 00:00:47,890
So sometimes that's a little bit hard to guarantee when you have multithreaded,

14
00:00:47,890 --> 00:00:50,700
when you have lots of Goroutines that are running in parallel because

15
00:00:50,700 --> 00:00:53,740
you don't know in exactly which order they're going to execute.

16
00:00:53,740 --> 00:00:57,750
So which Goroutine should you put

17
00:00:57,750 --> 00:00:59,810
the initialization in because you can't

18
00:00:59,810 --> 00:01:02,855
guarantee the order of execution of these multiple Goroutines?

19
00:01:02,855 --> 00:01:06,050
So, how do you do initialization guaranteeing that

20
00:01:06,050 --> 00:01:09,020
there's some initialization function that happens one time,

21
00:01:09,020 --> 00:01:11,015
happens before everything else happens,

22
00:01:11,015 --> 00:01:14,470
how do you guarantee that when you have multiple Goroutines?

23
00:01:14,470 --> 00:01:18,930
Well, one way is to actually perform initialization before starting the Goroutine.

24
00:01:18,930 --> 00:01:22,630
So maybe you can do your initialization inside the main,

25
00:01:22,630 --> 00:01:24,530
which will be the first Goroutine.

26
00:01:24,530 --> 00:01:27,300
You can do at the beginning and only then create the Goroutines.

27
00:01:27,300 --> 00:01:30,205
But sometimes you may or may not have that option.

28
00:01:30,205 --> 00:01:38,940
So, another facility that allows you to do this as part of the sync package is sinc.once.

29
00:01:38,940 --> 00:01:40,345
So this once method,

30
00:01:40,345 --> 00:01:42,660
once object, it has this method do.

31
00:01:42,660 --> 00:01:46,360
One method do, and you pass it some function as an argument.

32
00:01:46,360 --> 00:01:48,275
So, you can see there once.Do(f),

33
00:01:48,275 --> 00:01:50,210
whatever that function f is,

34
00:01:50,210 --> 00:01:52,010
and you can put this,

35
00:01:52,010 --> 00:01:56,255
called once.do in lots of different Goroutines,

36
00:01:56,255 --> 00:02:00,610
and this function f though will only be executed one time.

37
00:02:00,610 --> 00:02:04,250
So, the Goroutine guarantees that even if this

38
00:02:04,250 --> 00:02:08,465
once that Do is called in 20 different Goroutines,

39
00:02:08,465 --> 00:02:11,110
only one of them will actually execute,

40
00:02:11,110 --> 00:02:16,880
and it also guarantees that all calls to once.do inside any Goroutine,

41
00:02:16,880 --> 00:02:18,765
they block until the first one,

42
00:02:18,765 --> 00:02:20,765
the one that executes actually returns.

43
00:02:20,765 --> 00:02:22,640
So that makes sure that

44
00:02:22,640 --> 00:02:26,055
the initialization execute first before anything else can proceed.

45
00:02:26,055 --> 00:02:30,120
So you can put this once.do at the beginning of all your Goroutines, let's say.

46
00:02:30,120 --> 00:02:32,180
One of them will actually execute and

47
00:02:32,180 --> 00:02:34,625
the other ones will block until it finishes executing.

48
00:02:34,625 --> 00:02:38,615
So sync.once using once.do,

49
00:02:38,615 --> 00:02:41,140
it allows you to guarantee that first,

50
00:02:41,140 --> 00:02:43,120
initialization happens only one time because

51
00:02:43,120 --> 00:02:45,575
only one of these once.do's is actually going to execute.

52
00:02:45,575 --> 00:02:50,020
Also, it ensures that initialization happens before everything else because all the

53
00:02:50,020 --> 00:02:54,374
other once.do calls will block until the first one actually returns.

54
00:02:54,374 --> 00:02:57,485
So, this sync.once is useful

55
00:02:57,485 --> 00:03:01,045
when you need to do initialization and you have multiple Goroutines executed.

56
00:03:01,045 --> 00:03:04,640
So let's show an example of where we might use that.

57
00:03:04,640 --> 00:03:06,870
So let's say we've got

58
00:03:06,870 --> 00:03:11,760
two Goroutines and we're going to start two Goroutines in addition to the main Goroutine.

59
00:03:11,760 --> 00:03:16,515
We're going to start two Goroutines and we want them to do some initialization process,

60
00:03:16,515 --> 00:03:18,985
initialization function and do it only once.

61
00:03:18,985 --> 00:03:21,500
So, each Goroutine is going to be

62
00:03:21,500 --> 00:03:24,820
associated with this code dostuff so if you look at the main right there.

63
00:03:24,820 --> 00:03:27,625
I have go dostuff twice.

64
00:03:27,625 --> 00:03:32,350
So I'm starting two different Goroutines and both are running dostuff,

65
00:03:32,350 --> 00:03:34,565
whatever that is and I'll show that in the next slide.

66
00:03:34,565 --> 00:03:37,100
Also just notice, we've done this before,

67
00:03:37,100 --> 00:03:39,980
but notice that I put the wait group.

68
00:03:39,980 --> 00:03:42,755
So, I create a weight group at the top and then I

69
00:03:42,755 --> 00:03:46,950
call wg.Add(2) to say I'm going to wait for two functions,

70
00:03:46,950 --> 00:03:48,550
wait to two Goroutines rather,

71
00:03:48,550 --> 00:03:50,290
and then I call wg.Wait at the end.

72
00:03:50,290 --> 00:03:51,860
This is to make sure that

73
00:03:51,860 --> 00:03:57,240
the main Goroutine waits until these two sub-Goroutines actually complete.

74
00:03:57,240 --> 00:03:59,320
Otherwise, the main Goroutine will just exit

75
00:03:59,320 --> 00:04:01,745
before the dostuff actually gets to do anything.

76
00:04:01,745 --> 00:04:03,860
So, that's not the point of this,

77
00:04:03,860 --> 00:04:06,340
but I just want to mention that so you understand the code. All right.

78
00:04:06,340 --> 00:04:08,680
So, we've got these two Goroutines that are going to dostuff,

79
00:04:08,680 --> 00:04:12,675
and one of them is going to have to do initialization.

80
00:04:12,675 --> 00:04:16,565
We need initialization done at the beginning of the stuff that's going to be done.

81
00:04:16,565 --> 00:04:18,405
So let's go to the next slide.

82
00:04:18,405 --> 00:04:21,915
So now, first you can see on this slide a few things.

83
00:04:21,915 --> 00:04:24,790
First the top, we're defining our sync.once object,

84
00:04:24,790 --> 00:04:29,375
var on sync.once, ON I called it called it, call it whatever you want.

85
00:04:29,375 --> 00:04:31,415
Then I define this function called setup.

86
00:04:31,415 --> 00:04:34,625
So this function called setup is what I want to execute once,

87
00:04:34,625 --> 00:04:36,365
think of this as my initialization.

88
00:04:36,365 --> 00:04:38,490
Now this could be whatever I want it to be.

89
00:04:38,490 --> 00:04:41,810
In this case, I just had it print init just to do something.

90
00:04:41,810 --> 00:04:45,800
But you can have any sort of initialization operations in there that you want.

91
00:04:45,800 --> 00:04:48,425
So setup is a function that we want to have happen once.

92
00:04:48,425 --> 00:04:53,185
Now func dostuff down below is what's being executed by each one of the Goroutines.

93
00:04:53,185 --> 00:04:57,085
So, you can look at each Goroutine, look at dostuff.

94
00:04:57,085 --> 00:05:00,775
First thing it does is it calls on.do setup.

95
00:05:00,775 --> 00:05:02,735
Then it says print hello.

96
00:05:02,735 --> 00:05:04,820
So, we should see "Hello" printed

97
00:05:04,820 --> 00:05:07,455
twice on the screen at some point because there are two Goroutines.

98
00:05:07,455 --> 00:05:10,830
And then it calls wg.done just to let

99
00:05:10,830 --> 00:05:14,885
the wait group know that this Goroutine is finished doing what it's doing.

100
00:05:14,885 --> 00:05:20,050
So, now notice that both of these Goroutines are executing the same code, dostuff.

101
00:05:20,050 --> 00:05:27,195
So both these Goroutines have this on.do calling setup at the beginning of them.

102
00:05:27,195 --> 00:05:30,620
But what's going to happen is that only one of those is actually going to execute,

103
00:05:30,620 --> 00:05:32,420
not both those Goroutines are going to execute,

104
00:05:32,420 --> 00:05:33,740
only one is going to execute.

105
00:05:33,740 --> 00:05:37,495
So, when we execute the code,

106
00:05:37,495 --> 00:05:39,395
we get this appearing on the screen.

107
00:05:39,395 --> 00:05:43,795
You get Init first because that's the result of setup, setup prints Init.

108
00:05:43,795 --> 00:05:45,880
So that's the initialization process and I

109
00:05:45,880 --> 00:05:48,355
noticed that that happens first which is what we expected.

110
00:05:48,355 --> 00:05:53,815
Then "Hello, hello" you get twice because both of the Goroutines do execute both.

111
00:05:53,815 --> 00:05:55,820
Excuse me for the capitalization on one of the hellos,

112
00:05:55,820 --> 00:05:58,555
but both of them execute and they both print "Hello."

113
00:05:58,555 --> 00:06:01,615
So, this works.

114
00:06:01,615 --> 00:06:02,975
So Init appears once.

115
00:06:02,975 --> 00:06:06,515
Init appears before "Hello" so the initialization is done

116
00:06:06,515 --> 00:06:10,310
before any of the other stuff in the Goroutines are actually executed,

117
00:06:10,310 --> 00:06:12,515
which is what we want of an initialization.

118
00:06:12,515 --> 00:06:17,720
Thank you. Module 4: Threads in Go.

119
00:06:17,720 --> 00:06:20,380
Topic 3.2: Deadlock.

120
00:06:20,380 --> 00:06:25,195
So right now what we're going to talk about are problems that come with synchronization.

121
00:06:25,195 --> 00:06:26,830
So, we've been talking about synchronization,

122
00:06:26,830 --> 00:06:30,280
synchronization facilities provided in the sync package,

123
00:06:30,280 --> 00:06:32,660
also even outside the sync package with channels too.

124
00:06:32,660 --> 00:06:35,015
They also provide synchronization.

125
00:06:35,015 --> 00:06:37,880
But this synchronization, you get into problems with

126
00:06:37,880 --> 00:06:40,550
synchronization if you're not careful, specifically deadlock.

127
00:06:40,550 --> 00:06:43,420
So, this is something that you have to avoid when you're coding.

128
00:06:43,420 --> 00:06:46,865
You don't want to basically build deadlock in your system.

129
00:06:46,865 --> 00:06:50,975
So deadlock comes from synchronization dependencies.

130
00:06:50,975 --> 00:06:53,330
So, what I mean by that is,

131
00:06:53,330 --> 00:06:56,840
you can have multiple Goroutines and synchronization can

132
00:06:56,840 --> 00:07:00,825
cause one Goroutine's execution to depend on the other.

133
00:07:00,825 --> 00:07:02,640
So as example here,

134
00:07:02,640 --> 00:07:03,760
we've got G1, G2,

135
00:07:03,760 --> 00:07:07,730
these two Goroutines, and let's start look at the top row.

136
00:07:07,730 --> 00:07:09,540
So I got in G1,

137
00:07:09,540 --> 00:07:15,915
there's a channel CH and G1 is writing the number one onto the channel.

138
00:07:15,915 --> 00:07:18,625
Now, on the other side on G2,

139
00:07:18,625 --> 00:07:21,150
G2 is reading from that channel.

140
00:07:21,150 --> 00:07:24,075
Is taking CH, reading something from it, assigning it to x.

141
00:07:24,075 --> 00:07:26,760
So, there is a dependency here because G1 is

142
00:07:26,760 --> 00:07:30,095
writing onto the channel and G2 is reading from the channel.

143
00:07:30,095 --> 00:07:36,410
So that's the dependency and it's a blocking dependency in the sense that G1-

144
00:07:36,410 --> 00:07:41,115
It writes to the channel, but G2 can't continue pass that line,

145
00:07:41,115 --> 00:07:47,190
that read line until G1 does the write because since it has to read from the channel,

146
00:07:47,190 --> 00:07:50,270
it's going to wait right there until G1 actually does the write.

147
00:07:50,270 --> 00:07:53,075
So, there's dependency G2 depends on G1,

148
00:07:53,075 --> 00:07:54,820
it's execution depends on G1.

149
00:07:54,820 --> 00:07:56,730
Also, this data dependency here too,

150
00:07:56,730 --> 00:07:59,110
data is been passed from G1 and G2 also,

151
00:07:59,110 --> 00:08:02,010
but we're less interested in that in terms of deadlock.

152
00:08:02,010 --> 00:08:04,100
But we're more worried about the execution dependency.

153
00:08:04,100 --> 00:08:08,595
G1's execution cannot continue until G1 executes a statement.

154
00:08:08,595 --> 00:08:11,180
You can see the same thing on the bottom,

155
00:08:11,180 --> 00:08:14,900
and this time, instead of using channels, were using mutexes.

156
00:08:14,900 --> 00:08:17,345
So say I've got a mutex object.

157
00:08:17,345 --> 00:08:20,585
In G1 It unlocks that mutex,

158
00:08:20,585 --> 00:08:22,005
and G2 locks it.

159
00:08:22,005 --> 00:08:24,090
So, in this case, again,

160
00:08:24,090 --> 00:08:28,715
you can get a dependency because G2 can't accept the lock until G1 unlocks.

161
00:08:28,715 --> 00:08:31,685
G2 can't care to get the lock until G1 unlocks.

162
00:08:31,685 --> 00:08:34,860
So G2 again, its execution is dependent on G1.

163
00:08:34,860 --> 00:08:38,790
G2 can't continue past that lock until G1 gives up the lock.

164
00:08:38,790 --> 00:08:40,460
So, in both cases,

165
00:08:40,460 --> 00:08:44,340
you get G2's execution depending on G1's execution.

166
00:08:44,340 --> 00:08:47,730
So, G2 can't continue until G1 does something.

167
00:08:47,730 --> 00:08:50,340
So, four in one case, it's writing into a channel,

168
00:08:50,340 --> 00:08:53,440
the other case is it's unlocking a mutex, but either way.

169
00:08:53,440 --> 00:08:57,665
So, the synchronization causes the dependencies, the blocking dependencies.

170
00:08:57,665 --> 00:09:00,510
Now, when you can get into a problem,

171
00:09:00,510 --> 00:09:04,055
when you get into deadlock is when the dependencies are circular.

172
00:09:04,055 --> 00:09:09,070
So, what I mean by circular is if G1 is waiting for G2,

173
00:09:09,070 --> 00:09:11,010
and G2 is waiting for G1.

174
00:09:11,010 --> 00:09:16,695
So, G1 is waiting for G2 to do something like unlock a mutex or something like that,

175
00:09:16,695 --> 00:09:20,340
and maybe G2 is waiting for G1 to write onto a channel,

176
00:09:20,340 --> 00:09:23,070
and they're both waiting for each other to do something,

177
00:09:23,070 --> 00:09:24,590
but they're both blocked.

178
00:09:24,590 --> 00:09:26,745
So, neither one of them can progress,

179
00:09:26,745 --> 00:09:27,925
and that's called deadlock,

180
00:09:27,925 --> 00:09:29,560
nothing can happen at that point.

181
00:09:29,560 --> 00:09:31,890
So, it can be caused by waiting on channels,

182
00:09:31,890 --> 00:09:33,290
it can also be caused by mutex,

183
00:09:33,290 --> 00:09:34,600
waiting on mutexes too,

184
00:09:34,600 --> 00:09:36,330
waiting for unlocking of mutex,

185
00:09:36,330 --> 00:09:39,260
but it can also be caused by on waiting on channels too.

186
00:09:39,260 --> 00:09:44,520
So, this type of circular dependency where G1 waits for G2 and G2 waits for G1,

187
00:09:44,520 --> 00:09:46,520
that's what you need to avoid in your code.

188
00:09:46,520 --> 00:09:49,890
So, this is up to the programmer to avoid making such dependencies.

189
00:09:49,890 --> 00:09:53,060
So, let's show an example of a dependency like that.

190
00:09:53,060 --> 00:09:57,960
So, we're going to make a couple of goroutines in the main.

191
00:09:57,960 --> 00:09:59,160
I'm not showing you main right now.

192
00:09:59,160 --> 00:10:00,730
Right now I'm showing you dostuff,

193
00:10:00,730 --> 00:10:04,210
this is the code that each goroutine is going to execute.

194
00:10:04,210 --> 00:10:06,085
They're both going to execute same code.

195
00:10:06,085 --> 00:10:07,880
This dostuff, it takes two channels,

196
00:10:07,880 --> 00:10:09,655
channel one C1 and C2.

197
00:10:09,655 --> 00:10:12,325
Two channels as input and dostuff.

198
00:10:12,325 --> 00:10:17,670
First thing it does is it waits to receive something on the first channel,

199
00:10:17,670 --> 00:10:19,695
on C1, and then,

200
00:10:19,695 --> 00:10:22,130
it writes a one on the second channel.

201
00:10:22,130 --> 00:10:25,460
So, that's all it does. It waits to receive something on the first channel,

202
00:10:25,460 --> 00:10:27,290
and it writes to the second channel.

203
00:10:27,290 --> 00:10:29,920
Both of these goroutines are going to do the same thing.

204
00:10:29,920 --> 00:10:32,200
Now, they're going to have different arguments as I'll show you in a second,

205
00:10:32,200 --> 00:10:33,625
but that's basically what they're going to do,

206
00:10:33,625 --> 00:10:34,960
wait on the first channel,

207
00:10:34,960 --> 00:10:37,220
write to the second channel.

208
00:10:38,960 --> 00:10:42,409
So now, in the main,

209
00:10:42,409 --> 00:10:46,150
this is the main, I'll make two channels CH1, CH2.

210
00:10:46,150 --> 00:10:49,100
They have integers, then I have the weight groups,

211
00:10:49,100 --> 00:10:50,790
so we don't have to worry about that,

212
00:10:50,790 --> 00:10:53,255
but the main point is the go dostuff.

213
00:10:53,255 --> 00:10:54,515
I've got two calls of that.

214
00:10:54,515 --> 00:10:57,625
So, I'm creating these two goroutines.

215
00:10:57,625 --> 00:11:01,095
Now, notice they both take two arguments, CH1, CH2.

216
00:11:01,095 --> 00:11:04,665
But the first call, the first goroutine,

217
00:11:04,665 --> 00:11:06,030
the first go dostuff,

218
00:11:06,030 --> 00:11:10,075
it takes the order of the arguments is CH1 first, CH2 second.

219
00:11:10,075 --> 00:11:12,160
Then the second go dostuff,

220
00:11:12,160 --> 00:11:15,865
the order's changed, CH2 first, CH1 second.

221
00:11:15,865 --> 00:11:17,950
So, what this means is that,

222
00:11:17,950 --> 00:11:20,180
so remember dostuff that we just saw.

223
00:11:20,180 --> 00:11:25,695
What it does is, it waits to receive something on the first channel argument,

224
00:11:25,695 --> 00:11:27,510
and then it writes something to second.

225
00:11:27,510 --> 00:11:29,210
So, what that means is that the first goroutine

226
00:11:29,210 --> 00:11:30,770
is going to wait to receive something on channel

227
00:11:30,770 --> 00:11:35,285
one and write something on channel two in that order.

228
00:11:35,285 --> 00:11:39,330
Now then the second goroutine is going to wait to receive something on channel two,

229
00:11:39,330 --> 00:11:41,285
then write on channel one.

230
00:11:41,285 --> 00:11:43,290
Notice how they're depending on each other.

231
00:11:43,290 --> 00:11:47,545
So, the second goroutine is going to write on the channel one,

232
00:11:47,545 --> 00:11:50,295
while the first one is waiting to receive something on channel one.

233
00:11:50,295 --> 00:11:51,970
So, the first one's going to be blocked.

234
00:11:51,970 --> 00:11:55,340
Then the second one is waiting to

235
00:11:55,340 --> 00:11:59,465
receive something on channel two where the first one is writing on the channel two.

236
00:11:59,465 --> 00:12:01,055
So, the second one is going to be blocked,

237
00:12:01,055 --> 00:12:04,470
both goroutines are blocked and nothing can progress.

238
00:12:04,470 --> 00:12:06,915
So, this is an example of a deadlock.

239
00:12:06,915 --> 00:12:09,700
So, you have to avoid this as a programmer.

240
00:12:09,700 --> 00:12:14,380
Now, if you were to run that code that I just showed you filled in with the details,

241
00:12:14,380 --> 00:12:15,760
if you run that code,

242
00:12:15,760 --> 00:12:19,385
golang runtime actually detects this deadlock.

243
00:12:19,385 --> 00:12:23,105
So, if there's a situation where all goroutines are locked,

244
00:12:23,105 --> 00:12:24,850
which is what we just saw,

245
00:12:24,850 --> 00:12:26,605
all goroutines are stopped,

246
00:12:26,605 --> 00:12:29,790
then the golang runtime automatically detects it,

247
00:12:29,790 --> 00:12:31,635
and you get an error like what I'm showing here.

248
00:12:31,635 --> 00:12:33,090
These are just the first few lines the error,

249
00:12:33,090 --> 00:12:34,790
but basically it gets an error that says this is

250
00:12:34,790 --> 00:12:37,210
a deadlock and let you know, which is a good thing.

251
00:12:37,210 --> 00:12:39,550
However, the golang runtime cannot

252
00:12:39,550 --> 00:12:42,860
detect when only a subset of goroutines are deadlocked.

253
00:12:42,860 --> 00:12:44,805
So when that happens,

254
00:12:44,805 --> 00:12:47,280
then it'll lock those,

255
00:12:47,280 --> 00:12:51,360
they'll be deadlocked, and you won't know it in any obvious way.

256
00:12:51,360 --> 00:12:54,040
It's just your program won't operate correctly,

257
00:12:54,040 --> 00:12:56,770
and you'll notice it's somewhere down the line, it's harder to debug.

258
00:12:56,770 --> 00:12:58,080
So, this type of deadlock,

259
00:12:58,080 --> 00:13:04,930
these type of circular dependencies have to be avoided by the programmer. Thank you.

260
00:13:05,820 --> 00:13:08,365
Module four, Threads and Go,

261
00:13:08,365 --> 00:13:11,140
Topic 3.3, Dining Philosophers.

262
00:13:11,140 --> 00:13:14,450
So now we're going to talk about the dining philosophers problem.

263
00:13:14,450 --> 00:13:18,890
This is one of these classic concurrency problems that people use to talk about

264
00:13:18,890 --> 00:13:23,585
synchronization and show basically possibility of deadlock problems in synchronization.

265
00:13:23,585 --> 00:13:24,910
So this is one of the classics.

266
00:13:24,910 --> 00:13:27,360
I mean you always teach this when you talk about concurrency.

267
00:13:27,360 --> 00:13:28,670
So, we're going to talk about it,

268
00:13:28,670 --> 00:13:32,945
and show how deadlock can sneak up on you.

269
00:13:32,945 --> 00:13:35,070
You have to be careful to avoid it.

270
00:13:35,070 --> 00:13:36,580
So, in this problem,

271
00:13:36,580 --> 00:13:39,405
you got five philosophers sitting at a round table.

272
00:13:39,405 --> 00:13:41,140
Each one has a plate in front of them,

273
00:13:41,140 --> 00:13:46,085
a plate of rice, and they're chopsticks they're going to use to eat this rice.

274
00:13:46,085 --> 00:13:50,740
So, one chopstick is placed between each adjacent pair of philosophers.

275
00:13:50,740 --> 00:13:54,610
So, there are five philosophers in a circle,

276
00:13:54,610 --> 00:13:57,005
there also five chopsticks between them.

277
00:13:57,005 --> 00:13:59,840
Now, everybody wants to eat their rice from the plate,

278
00:13:59,840 --> 00:14:01,865
but you need two chopsticks to eat the rice.

279
00:14:01,865 --> 00:14:03,610
So, every philosopher in order to eat is going to

280
00:14:03,610 --> 00:14:05,435
have to pick up the chopstick I'm going left,

281
00:14:05,435 --> 00:14:08,190
pick up the chopstick on the right and then eat.

282
00:14:08,190 --> 00:14:11,960
But only one philosophy can hold a chopstick at a time.

283
00:14:11,960 --> 00:14:14,755
So, when one philosopher is eating,

284
00:14:14,755 --> 00:14:17,290
his neighbors can't eat because he's got

285
00:14:17,290 --> 00:14:20,220
both of the chopsticks so the neighbors don't have their neighboring chopsticks,

286
00:14:20,220 --> 00:14:23,155
so at least one of them, so they can't eat.

287
00:14:23,155 --> 00:14:26,855
So, there are not enough chopsticks for everyone to eat at once, and this is key.

288
00:14:26,855 --> 00:14:30,900
So not necessarily one can eat a time,

289
00:14:30,900 --> 00:14:32,810
you can have multiple people eating at a time,

290
00:14:32,810 --> 00:14:35,715
but they can't all eat at a time.

291
00:14:35,715 --> 00:14:39,310
So they have to be properly ordered in order to all eat.

292
00:14:39,310 --> 00:14:41,690
So, the problem with this is if you implement this in

293
00:14:41,690 --> 00:14:45,270
a naive way or I wouldn't even call naive,

294
00:14:45,270 --> 00:14:47,850
but in a way without thinking through,

295
00:14:47,850 --> 00:14:52,285
you can easily cause possibility of deadlock in the system.

296
00:14:52,285 --> 00:14:55,595
So, here's a picture of our table.

297
00:14:55,595 --> 00:14:59,045
That is a round table, there's five plates for the five philosophers,

298
00:14:59,045 --> 00:15:00,460
and then you see this little sticks between,

299
00:15:00,460 --> 00:15:03,255
those chopsticks so there is five chopsticks.

300
00:15:03,255 --> 00:15:06,375
So, in our model when we code this,

301
00:15:06,375 --> 00:15:08,535
we're going to make each chopstick a mutex.

302
00:15:08,535 --> 00:15:12,155
That makes sense because a chopstick can only be held,

303
00:15:12,155 --> 00:15:15,810
taken or locked by one philosopher.

304
00:15:15,810 --> 00:15:19,260
So, a philosopher, so this a chopstick and one at the top,

305
00:15:19,260 --> 00:15:21,560
there's a philosopher to the left of it,

306
00:15:21,560 --> 00:15:25,220
philosopher to the right, only one of them can read that chopstick at a time.

307
00:15:25,220 --> 00:15:27,910
So, they can only have mutually exclusive access,

308
00:15:27,910 --> 00:15:30,925
so it makes sense to represent a chopstick as a mutex.

309
00:15:30,925 --> 00:15:32,780
So chopsticks are mutex,

310
00:15:32,780 --> 00:15:35,110
and then each philosopher is going to be associated

311
00:15:35,110 --> 00:15:38,050
with a goroutine because it's going to be eating.

312
00:15:38,050 --> 00:15:41,305
It's goroutine is going to be the action of eating,

313
00:15:41,305 --> 00:15:43,705
but it's also associated with two chopsticks,

314
00:15:43,705 --> 00:15:45,440
one on the left, one on the right.

315
00:15:45,440 --> 00:15:49,635
So every philosopher is going to have a left chopstick and a right chopstick.

316
00:15:49,635 --> 00:15:53,535
So, let's look at how we might code this in an obvious way.

317
00:15:53,535 --> 00:15:56,480
First, we will define our chopS as chopstick, our type,

318
00:15:56,480 --> 00:15:58,295
and that's just a sync mutex,

319
00:15:58,295 --> 00:16:00,820
sync.Mutex, so that's a mutex like we were saying.

320
00:16:00,820 --> 00:16:05,320
Then we make our philosopher type and that's a struct with two things,

321
00:16:05,320 --> 00:16:08,010
leftCS, left chopstick and a rightCS,

322
00:16:08,010 --> 00:16:10,400
right chopstick, and those are both pointers to chopsticks.

323
00:16:10,400 --> 00:16:13,030
So, we've got a philosopher, we got a chopstick.

324
00:16:13,030 --> 00:16:17,895
Now, the philosopher is going to have to have associated with a method for eating.

325
00:16:17,895 --> 00:16:21,030
So, this is what we're going to say the eating method looks like.

326
00:16:21,030 --> 00:16:23,520
So, it's an infinite loop, see that for the top,

327
00:16:23,520 --> 00:16:26,355
and what it does is it basically,

328
00:16:26,355 --> 00:16:31,975
the philosopher, first thing it does is it locks the left chopstick,

329
00:16:31,975 --> 00:16:33,675
then it locks the right chopstick.

330
00:16:33,675 --> 00:16:35,100
So then it's got both chopsticks.

331
00:16:35,100 --> 00:16:37,930
Locking is basically picking up the chopsticks off the table.

332
00:16:37,930 --> 00:16:39,660
Then it's it eats.

333
00:16:39,660 --> 00:16:43,305
So format, I just print eating to represent the act of eating.

334
00:16:43,305 --> 00:16:46,030
So, it eats. Then when it's done, it puts down the chopstick,

335
00:16:46,030 --> 00:16:47,850
puts down the right, puts down the right chopstick,

336
00:16:47,850 --> 00:16:49,085
puts down the left chopstick.

337
00:16:49,085 --> 00:16:52,705
By the way, the order of putting down chopsticks doesn't really matter for us.

338
00:16:52,705 --> 00:16:55,400
So, that's what eating is, and it's an infinite loop.

339
00:16:55,400 --> 00:16:57,640
It's just going eat over and over and over.

340
00:16:57,640 --> 00:17:01,980
Each one of these five philosophers is basically executing the same code.

341
00:17:02,010 --> 00:17:04,365
So, now in the main,

342
00:17:04,365 --> 00:17:06,820
I'm omitting some of these details, weights,

343
00:17:06,820 --> 00:17:08,470
and such, but the main,

344
00:17:08,470 --> 00:17:09,590
I'm just getting into the heart of it.

345
00:17:09,590 --> 00:17:11,790
First thing, if we look at this code,

346
00:17:11,790 --> 00:17:14,740
we're initializing, we're doing some initialization in the main.

347
00:17:14,740 --> 00:17:19,150
For its initialization, the first few lines are creating the chopsticks,

348
00:17:19,150 --> 00:17:21,785
and the next few lines are creating the philosophers.

349
00:17:21,785 --> 00:17:24,330
So, we got to make five chopsticks and five philosophers.

350
00:17:24,330 --> 00:17:26,705
So, if you look at the top, we make

351
00:17:26,705 --> 00:17:30,865
this slice for five chopsticks pointers and then in that loop,

352
00:17:30,865 --> 00:17:33,450
from I equals zero to less than five,

353
00:17:33,450 --> 00:17:36,085
we create these chopsticks and filling this array.

354
00:17:36,085 --> 00:17:37,550
So, we create these new chopsticks,

355
00:17:37,550 --> 00:17:40,940
five of them, all numbered CSticks zero through four.

356
00:17:40,940 --> 00:17:43,420
Then we do the same thing with the philosopher.

357
00:17:43,420 --> 00:17:47,050
So, we make this philosopher slice right

358
00:17:47,050 --> 00:17:49,130
there enough for five then we have another for

359
00:17:49,130 --> 00:17:52,040
loop and we curate the philosophers. We fill in the philosopher.

360
00:17:52,040 --> 00:17:56,910
Now, notice philos i equals ampersand,

361
00:17:56,910 --> 00:18:02,000
because these are pointers, and then the constructor base when I construct it,

362
00:18:02,000 --> 00:18:05,040
when I call philo I'm passing it two things.

363
00:18:05,040 --> 00:18:10,075
Now, remember the order of the structure feels, so philosophers structure.

364
00:18:10,075 --> 00:18:11,965
It's got left chopstick,

365
00:18:11,965 --> 00:18:13,595
right chopstick. That's the order.

366
00:18:13,595 --> 00:18:17,274
So, in the curly brackets there after philo,

367
00:18:17,274 --> 00:18:18,630
you can see two things.

368
00:18:18,630 --> 00:18:20,350
The first thing is going to be the left chopstick.

369
00:18:20,350 --> 00:18:22,030
The second is going to be the right chopstick.

370
00:18:22,030 --> 00:18:25,490
So, the first thing, the left chopstick is CSticks i.

371
00:18:25,490 --> 00:18:27,100
So, if this is philosopher zero,

372
00:18:27,100 --> 00:18:29,935
left chopstick is going to be chopstick zero.

373
00:18:29,935 --> 00:18:36,210
Then notice that the right chopstick is i plus one, modular five.

374
00:18:36,210 --> 00:18:38,995
So, you have to do the modular five

375
00:18:38,995 --> 00:18:41,685
to account for the last philosopher, philosopher four.

376
00:18:41,685 --> 00:18:43,410
So, what this means is that philosopher

377
00:18:43,410 --> 00:18:46,170
zero is going to have chopstick zero as its left chopstick,

378
00:18:46,170 --> 00:18:47,715
chopstick one is its right.

379
00:18:47,715 --> 00:18:51,735
Philosopher two is going to have chopstick two as its left chopstick,

380
00:18:51,735 --> 00:18:53,235
chopstick three as its right.

381
00:18:53,235 --> 00:18:56,690
But philosopher four, he has chopstick four as

382
00:18:56,690 --> 00:19:01,360
his left chopstick and chopstick zero as its right chopstick. It's in a circle.

383
00:19:01,360 --> 00:19:04,240
That's why you have to do the modular five because there's no chopstick five.

384
00:19:04,240 --> 00:19:05,875
He gets chopstick zero.

385
00:19:05,875 --> 00:19:09,300
So, we had to do i plus one modular five in there,

386
00:19:09,300 --> 00:19:11,230
but basically you get the idea.

387
00:19:11,230 --> 00:19:13,830
So, we've created in here,

388
00:19:13,830 --> 00:19:15,710
we've initialized the set of chopsticks,

389
00:19:15,710 --> 00:19:18,190
five of them, then we made five philosophers and associated

390
00:19:18,190 --> 00:19:21,185
their left and right chopsticks with each one of the philosophers.

391
00:19:21,185 --> 00:19:24,000
Now, this program, so this,

392
00:19:24,000 --> 00:19:25,810
basically, this is almost it.

393
00:19:25,810 --> 00:19:27,550
One more thing we have to do in the main after doing

394
00:19:27,550 --> 00:19:30,480
this initialization is we have to actually create the Goroutines.

395
00:19:30,480 --> 00:19:33,685
The Goroutine for every philosopher and get him eating.

396
00:19:33,685 --> 00:19:36,280
So, we have right after that,

397
00:19:36,280 --> 00:19:37,825
they start the eating.

398
00:19:37,825 --> 00:19:40,740
We say four loop i equal zero to

399
00:19:40,740 --> 00:19:43,845
five because we want to make five Goroutines one for each philosopher.

400
00:19:43,845 --> 00:19:50,270
We just say philosopher i dot eat and he calls this eat which is an infinite execution.

401
00:19:50,270 --> 00:19:55,470
So, this will start each philosopher eating and so starting these five Goroutines.

402
00:19:55,470 --> 00:19:57,580
We would also, I'm not putting this in here,

403
00:19:57,580 --> 00:20:01,050
but we'd also have to add some weighting in the main.

404
00:20:01,050 --> 00:20:03,340
Some form of weight in the main so that the main

405
00:20:03,340 --> 00:20:05,710
doesn't complete before these philosophers complete.

406
00:20:05,710 --> 00:20:07,575
Because the philosopher is the way I've written it.

407
00:20:07,575 --> 00:20:10,895
These Philosopher Goroutines will never complete, they're in an infinite loop.

408
00:20:10,895 --> 00:20:13,520
So, we've got to make sure that the main doesn't complete either.

409
00:20:13,520 --> 00:20:15,750
So, we'd have to put it in a little synchronization in there,

410
00:20:15,750 --> 00:20:17,260
a weight or something like that

411
00:20:17,260 --> 00:20:20,725
but I just want to focus on the philosophers for the moment.

412
00:20:20,725 --> 00:20:26,345
So, this is how you would write the code in a naive way.

413
00:20:26,345 --> 00:20:32,775
So, the place where deadlock can happen is if all philosophers,

414
00:20:32,775 --> 00:20:36,605
if they all grab their left chopsticks at the same time.

415
00:20:36,605 --> 00:20:38,000
Now, if you remember that code.

416
00:20:38,000 --> 00:20:42,135
So, this is a little summary of the code that each one of the eat code for a philosopher.

417
00:20:42,135 --> 00:20:43,965
First, he grabs his left chopstick,

418
00:20:43,965 --> 00:20:45,850
it locks his left then it locks the right,

419
00:20:45,850 --> 00:20:48,445
then it eats, then it unlocks the two chopsticks.

420
00:20:48,445 --> 00:20:51,200
So, now we don't know what interleaving is going to

421
00:20:51,200 --> 00:20:55,345
happen between these different philosophers,

422
00:20:55,345 --> 00:20:59,340
but there is an interleaving where each one of

423
00:20:59,340 --> 00:21:03,285
these five philosophers it executes its first lock,

424
00:21:03,285 --> 00:21:06,185
locking the left chopstick

425
00:21:06,185 --> 00:21:10,720
without going on and then the next philosopher does that, grabs its left.

426
00:21:10,720 --> 00:21:12,965
The next one grabs its left. Each one of these five

427
00:21:12,965 --> 00:21:15,995
could grab its left chopstick before they continue.

428
00:21:15,995 --> 00:21:19,274
In that state, if they all grab their left chopstick,

429
00:21:19,274 --> 00:21:21,950
meaning they lock the left chopstick,

430
00:21:21,950 --> 00:21:24,735
then all five chopsticks are locked.

431
00:21:24,735 --> 00:21:27,650
So, then when they try to execute the next instruction,

432
00:21:27,650 --> 00:21:29,070
locking the right chopstick,

433
00:21:29,070 --> 00:21:32,280
they won't be able to because all the chopsticks are locked.

434
00:21:32,280 --> 00:21:34,610
Because your right chopstick is somebody else's left

435
00:21:34,610 --> 00:21:37,410
chopstick so everybody's locked all the left chopsticks,

436
00:21:37,410 --> 00:21:40,240
they're all locked and we would be in a deadlock situation.

437
00:21:40,240 --> 00:21:43,190
So, there's an interleaving here, at least one interleaving,

438
00:21:43,190 --> 00:21:47,925
where you can get into this deadlock situation and it's easy not to see that.

439
00:21:47,925 --> 00:21:52,815
It would be easy to code this the way I just coded it and run into that type of deadlock.

440
00:21:52,815 --> 00:21:55,720
Now, this is a fundamental problem.

441
00:21:55,720 --> 00:21:58,080
There are lots of solutions that have been proposed,

442
00:21:58,080 --> 00:21:59,700
ways to fix this.

443
00:21:59,700 --> 00:22:02,620
One way to fix this, so Dykstra's way.

444
00:22:02,620 --> 00:22:06,095
In this particular case, Dykstra is a genius.

445
00:22:06,095 --> 00:22:09,115
Anyway Dykstra, he decided to fix it by

446
00:22:09,115 --> 00:22:12,760
basically modifying the code and I want show you the modification,

447
00:22:12,760 --> 00:22:15,605
really, but he wants to modify the code so that

448
00:22:15,605 --> 00:22:19,030
each philosopher picks the lowest numbered chopstick first.

449
00:22:19,030 --> 00:22:24,285
Now, what I'm showing there in the blue is the code that we have.

450
00:22:24,285 --> 00:22:26,280
Our code does not do that.

451
00:22:26,280 --> 00:22:29,270
Our code, the first one that you pick up is the one to your left,

452
00:22:29,270 --> 00:22:33,970
which is for most of the philosophers that's the lowest number.

453
00:22:33,970 --> 00:22:37,170
So, if you're talking about philosopher zero,

454
00:22:37,170 --> 00:22:38,980
to his left is chopstick zero,

455
00:22:38,980 --> 00:22:40,180
to his right is chopstick one.

456
00:22:40,180 --> 00:22:43,370
So, the lowest numbered chopstick is chopstick zero.

457
00:22:43,370 --> 00:22:46,485
So, that's the one that he picks up first, the left one.

458
00:22:46,485 --> 00:22:49,940
So, that's true for all of them except for philosopher four.

459
00:22:49,940 --> 00:22:53,850
Philosopher four, on his left he has chopstick four,

460
00:22:53,850 --> 00:22:59,455
on his right he has chopstick zero and four picks up chopstick zero first.

461
00:22:59,455 --> 00:23:02,965
Sorry, according to our code,

462
00:23:02,965 --> 00:23:06,685
four would pick up chopstick four first and then pick up chopstick zero.

463
00:23:06,685 --> 00:23:11,200
So, the code that we have violates this rule that I haven't read,

464
00:23:11,200 --> 00:23:13,320
picking up the lowest numbered chopstick first.

465
00:23:13,320 --> 00:23:19,090
If you change the ordering so it always picks up the lowest chopstick first,

466
00:23:19,090 --> 00:23:23,680
then philosopher four would pick up chopstick zero before chopstick four and

467
00:23:23,680 --> 00:23:28,645
it would try to pick it up and if they were about to be in a deadlock situation,

468
00:23:28,645 --> 00:23:30,825
if everybody else had picked up their left chopstick,

469
00:23:30,825 --> 00:23:34,280
then plus a four would be blocked because it would try to pick up chopstick zero but

470
00:23:34,280 --> 00:23:38,590
it would already had been picked up by philosopher zero.

471
00:23:39,210 --> 00:23:41,940
So, then you wouldn't get into the blocking,

472
00:23:41,940 --> 00:23:44,535
you wouldn't get to the absolute deadlock state that we would have.

473
00:23:44,535 --> 00:23:50,245
Then it wouldn't pick up this chopstick since it tried to pick up chopstick zero first,

474
00:23:50,245 --> 00:23:52,570
it would never get to pick then chopstick four,

475
00:23:52,570 --> 00:23:56,170
which means philosopher four would block and philosopher three would be

476
00:23:56,170 --> 00:23:59,660
allowed to eat because philosopher three could then grab its right chopstick,

477
00:23:59,660 --> 00:24:02,945
chopstick four, and they could eat and then we could continue.

478
00:24:02,945 --> 00:24:08,140
So, there is no deadlock in this situation but philosopher four may starve.

479
00:24:08,140 --> 00:24:13,935
So, what that means is that philosopher four in this setup gets lowest priority.

480
00:24:13,935 --> 00:24:18,470
He's the one who ends up having to wait on others most of the time.

481
00:24:18,470 --> 00:24:20,805
So, that's called starvation.

482
00:24:20,805 --> 00:24:24,960
He would, it's literal starvation in this example but that can happen in other scenarios,

483
00:24:24,960 --> 00:24:28,010
too, where you have multiple threads, multiple Goroutines,

484
00:24:28,010 --> 00:24:33,300
they are all executing but some number of them don't get to execute as often as

485
00:24:33,300 --> 00:24:39,470
the other ones because of the way you've set up your synchronization.

486
00:24:39,470 --> 00:24:42,720
So, starvation is another issue but deadlock is the worst and you can

487
00:24:42,720 --> 00:24:45,980
avoid it in several ways but just be careful of these circular dependencies.

488
00:24:45,980 --> 00:24:48,220
So, this is a case where you have a circular dependency but

489
00:24:48,220 --> 00:24:50,740
the circle is five philosophers long.

490
00:24:50,740 --> 00:24:53,680
The dependency it has to go through all five philosophers,

491
00:24:53,680 --> 00:24:56,570
the four, the circular dependency completes itself.

492
00:24:56,570 --> 00:25:01,420
So, it's a little more subtle to see. Thank you.