So, now we're moving on to composite data types. Composite data types are beyond the basic data types. They are data types that put together, that aggregate other data types. So, unlike a string. Even a string you can think of. Actually, a string is a special case because you can think of it as aggregating these different bytes. So, a string is somewhat of if I ask you. Now, I think about a string is a composite data type, but we're going to talk more generally about arrays right now. So, an array in general, is just where you take a bunch of a fixed-length series of elements of a chosen type. So, you can make an array of bytes, you can make an array of integers, an array of floats, and so on. But it's fixed length. That's the key thing about arrays, they are fixed length. It is known to compile time how big they're going to be. So, the compiler can tell, how much space in memory it needs to allocate for these. Just in general, let me say that these composite data types are important. That is, in any kind of complicated program, you're going to need to use composite data types. It's not enough to use the fundamental data types. Yeah. You need to bring together different data types and group them, and aggregate them into some kind of composite data type. So, you have different array elements. Each one is some chosen type, maybe it's an integer array, you've got a set of each array element would be an integer. Elements of the array, each element is indexed by using subscript notation. So, square brackets. You put the index right in the middle of the square brackets. So, we're going to have example here, but this is a similar notation what you see in a lot of different languages. Indices start at zero, because we're computer science, we start counting at zero not one. Elements are initialized to a zero value and actually, this is not always the case in other languages. Say in C, your making an array, that array is not initialized at all. Unless you actually write code to initialize it. When you create it, it's not initialized. In goaling, the array is initialized to zero value. When I say zero value, I mean the zero value of the type that the array is composed of. So, if it's the integer, the zero value is just zero. If it's strings, the zero value is empty string. So, in this example, we're showing how you can declare an array. So, you say C at the top, var x, and then in brackets five int. The fact that it has the brackets five, tells you this is supposed to be an array of five integers. So, that's how you declare an array. That would be initialized to zeros by default. Then next line I refer to a particular element x bracket zero. So, I'm looking at the zeroth element. I'm setting that equal to two. So, now I've changed that to equal to two. In the next line I'm doing a Printf. So, do Printf x of bracket one. Since bracket one, I didn't actually explicitly initialize that, it would have been initialized to zero. So, that'll print zero. So, that's an array. You've seen that in other languages most likely. An array literal, is a pre-defined set of values that make up an array. So, you use this to initialize arrays if you want to. So, for instance here, we say var x bracket five int. So, it's an array of five integers. We say equals and we say square bracket five and within the curly brackets, there are actually five integers. So, that's actually a way of initializing the array to a set of values, to an array of five integers. So, that array of five integers that's inside the curly brackets. That's actually called an array literal, and we're defining x to be equal to that array literal. The length of the literal has to be the same as the length of the array. So, if you declare x to be five, you better have five literals inside the array literal. Then this is operation that dot dot dot. That's actually a key word. So, dot dot dot is used to express the size. You can use dot dot dot to express the size of an array literal. You can do that because if you have an array literal and inside the curly brackets you have four elements in there, then it's clear that you want this array literal to be size four. You don't have to say explicitly four. So, you can just put a dot dot dot in there, and it will infer the size of the array from the number of elements inside the array literal. So, in this example, x :=, brackets we have.dot dot dot. We don't specify explicitly what the size is. This is int 1, 2, 3, 4. Since there's four elements in there, clearly you want x to be size four. The most common programming operation that you do to arrays, is to iterate through the array. You look through each element of the array and you do something with the element of the array. Maybe you add it to a sum or you check if it's greater than five or something like that, but it is extremely common in programming to iterate through an array and check out each element in the array. So, the way you do that in goaling, is with a four loop. So, you can see the code here, we've got some sample array one, two, three. It's just three elements in it, one, two, three. Now, we want to iterate through this array. Maybe we want to print out each element of the array. So, we make a four loop. Now, notice that I have highlighted near that range keyword. To the right of the range keyword is the name of the array that we want to iterate through. So, range x. To the left, we say for i, v. We got two variables here, i and v. I is the index of the array element that we're looking through in this particular pass, and v is going to be bound to the value of the array in element that we're looking at in this pass. So, the idea here is that in this loop, if you look inside the curly brackets, there's a print statement. That print statement is going to get iterated once each passes the loop. So, every pass of the loop, i and v have bound to different values. I is the index of the element that we're looking at, and v is the value. So, in this case, with this array, the first pass of the loop. I is going to be zero, next pass is going to be one, next pass is going to be two. They'll increment each time. V is going to be the ith value in the array. So, the first pass through when i is equal to 0, v is going to be equal to one because the first element in that array is the number one. So, the zeroth element is the number one. Then the next pass, i is going to be one and v is going to be two, because the first element from zero, one. The first element in that count is the value two and so on. All this loop does is very simple, it just prints out the i and v together, but that's the idea. This allows me to iterate through the array. So, i and v get bound to an index and a value inside this array on each pass. So, inside the loop, inside the curly brackets of the loop, we can do whatever we want to that value v and to that index i.