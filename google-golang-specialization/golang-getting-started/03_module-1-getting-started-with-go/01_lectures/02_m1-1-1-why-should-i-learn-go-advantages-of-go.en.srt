1
00:00:10,110 --> 00:00:12,485
So, why should you learn Go?

2
00:00:12,485 --> 00:00:15,095
What's unique and good about the Go language?

3
00:00:15,095 --> 00:00:17,230
I'll go over some of the highlights of that.

4
00:00:17,230 --> 00:00:18,900
Different people have different opinions,

5
00:00:18,900 --> 00:00:21,689
but there are certain features that are pretty

6
00:00:21,689 --> 00:00:25,320
uniformly understood as being advantages of the Go language.

7
00:00:25,320 --> 00:00:27,955
So, some of the advantages of Go.

8
00:00:27,955 --> 00:00:30,275
First, runs fast.

9
00:00:30,275 --> 00:00:31,920
Okay, that's always a good thing,

10
00:00:31,920 --> 00:00:36,120
and I'll talk a little bit more detail in the slides about why it runs fast,

11
00:00:36,120 --> 00:00:37,370
and faster than what, right?

12
00:00:37,370 --> 00:00:38,560
Doesn't run fast than everything,

13
00:00:38,560 --> 00:00:40,130
but it runs fast than a lot of things,

14
00:00:40,130 --> 00:00:41,825
and we'll talk about why.

15
00:00:41,825 --> 00:00:44,110
Garbage collection, that's another feature.

16
00:00:44,110 --> 00:00:45,800
That in similar languages,

17
00:00:45,800 --> 00:00:48,240
meaning languages that run fast like Go does,

18
00:00:48,240 --> 00:00:49,535
they don't have garbage collection.

19
00:00:49,535 --> 00:00:51,390
So, garbage collections are really useful feature,

20
00:00:51,390 --> 00:00:52,990
I'll describe what that is.

21
00:00:52,990 --> 00:00:56,780
Simpler objects, now this could be an advantage or disadvantage,

22
00:00:56,780 --> 00:01:01,250
but the idea is that Go is essentially object oriented although, some might disagree,

23
00:01:01,250 --> 00:01:03,405
but it has this concept of objects,

24
00:01:03,405 --> 00:01:05,685
and these objects are generally,

25
00:01:05,685 --> 00:01:09,825
the object orientation is a little simplified as compared to other languages.

26
00:01:09,825 --> 00:01:11,950
So, this is good, it makes it easier to code.

27
00:01:11,950 --> 00:01:13,610
You don't have to use these complicated features,

28
00:01:13,610 --> 00:01:15,105
of course you never had to use them any way,

29
00:01:15,105 --> 00:01:18,190
but it makes it faster, and simpler to use.

30
00:01:18,190 --> 00:01:20,255
So, I know somebody might argue that

31
00:01:20,255 --> 00:01:22,880
look these features are useful features, I wanted them.

32
00:01:22,880 --> 00:01:24,830
Okay. But Go is actually

33
00:01:24,830 --> 00:01:30,755
a simpler object-oriented implementation than you would see in other languages like C++.

34
00:01:30,755 --> 00:01:34,490
Another feature of Go is that it has concurrency,

35
00:01:34,490 --> 00:01:36,980
efficient concurrency implementation built into language.

36
00:01:36,980 --> 00:01:41,260
So, there are a lot of these concurrency primitives that are built into the language,

37
00:01:41,260 --> 00:01:42,805
and that are efficiently implemented,

38
00:01:42,805 --> 00:01:44,680
and we'll talk about those.

39
00:01:44,680 --> 00:01:46,880
So, to start off with, let's go into

40
00:01:46,880 --> 00:01:49,730
that code running fast thing and tell you why that is the case.

41
00:01:49,730 --> 00:01:51,315
To talk about that,

42
00:01:51,315 --> 00:01:53,465
we've got to talk about a little bit about

43
00:01:53,465 --> 00:01:56,390
languages in general, differences between languages.

44
00:01:56,390 --> 00:01:58,160
So, I've got these three,

45
00:01:58,160 --> 00:02:01,830
very broad categories of languages for machines.

46
00:02:01,830 --> 00:02:03,480
So, one is machine language,

47
00:02:03,480 --> 00:02:04,830
next is Assembly language,

48
00:02:04,830 --> 00:02:06,730
next is high-level language, right?

49
00:02:06,730 --> 00:02:07,970
Now, that's a really big category,

50
00:02:07,970 --> 00:02:09,255
but let me explain.

51
00:02:09,255 --> 00:02:10,965
Machine language to start off with,

52
00:02:10,965 --> 00:02:14,410
that is the lowest level language,

53
00:02:14,410 --> 00:02:18,275
and it's directly executed on the CPU, on the processor.

54
00:02:18,275 --> 00:02:21,170
So, the machine language instructions are very,

55
00:02:21,170 --> 00:02:25,150
very straightforward and simple, add, multiply,

56
00:02:25,150 --> 00:02:27,530
add might add to register contents,

57
00:02:27,530 --> 00:02:28,820
put the result in another register,

58
00:02:28,820 --> 00:02:31,210
something like that, very small steps,

59
00:02:31,210 --> 00:02:33,000
each machine language instruction.

60
00:02:33,000 --> 00:02:38,530
Now, this runs directly on the processor, so there's that.

61
00:02:38,530 --> 00:02:42,590
There's assembly language and assembly language is basically machine language,

62
00:02:42,590 --> 00:02:45,440
almost a one-to-one mapping to machine language.

63
00:02:45,440 --> 00:02:47,280
So, in machine language,

64
00:02:47,280 --> 00:02:50,945
say you had to add instruction that might be represented as a sequence of zeros and ones,

65
00:02:50,945 --> 00:02:55,240
11110000 that might be an add, Opcode for an add.

66
00:02:55,240 --> 00:02:56,955
So, in assembly language,

67
00:02:56,955 --> 00:02:59,265
you would use the word ADD.

68
00:02:59,265 --> 00:03:03,775
So, it maps one-to-one to the machine language equivalent,

69
00:03:03,775 --> 00:03:05,960
but you can read it because it's English.

70
00:03:05,960 --> 00:03:08,255
Now, it's concise English,

71
00:03:08,255 --> 00:03:10,315
I would argue it's hard to read,

72
00:03:10,315 --> 00:03:12,375
but it's English mnemonic,

73
00:03:12,375 --> 00:03:15,540
so a human could read that and could right that if you wanted to,

74
00:03:15,540 --> 00:03:16,770
and people do sometimes.

75
00:03:16,770 --> 00:03:18,020
If you want something to run really,

76
00:03:18,020 --> 00:03:20,490
really fast and really efficiently,

77
00:03:20,490 --> 00:03:23,180
then you'll write it directly in assembly language.

78
00:03:23,180 --> 00:03:25,665
That's outside of the scope of this class,

79
00:03:25,665 --> 00:03:27,530
that's hardcore, I'll call it.

80
00:03:27,530 --> 00:03:30,439
That is not something we're going to really cover in this class,

81
00:03:30,439 --> 00:03:33,325
but sometimes you do write directly in assembly language.

82
00:03:33,325 --> 00:03:35,720
So, there's assembly machine in assembly,

83
00:03:35,720 --> 00:03:37,610
and assembly language is basically

84
00:03:37,610 --> 00:03:41,670
a one-to-one mapping to machine language not completely, but very close.

85
00:03:41,670 --> 00:03:44,340
So, fundamentally they're the same complexity.

86
00:03:44,340 --> 00:03:47,405
They're the same language, but assembly language is easier to read.

87
00:03:47,405 --> 00:03:50,980
Now, as high-level languages that's everything else,

88
00:03:50,980 --> 00:03:52,240
that's a broad category.

89
00:03:52,240 --> 00:03:58,185
A high-level language is a language that essentially humans commonly use to program in.

90
00:03:58,185 --> 00:04:02,720
They are much easier to use than assembly language or machine language.

91
00:04:02,720 --> 00:04:06,750
They provide you with lots of abstractions that any program would be used to,

92
00:04:06,750 --> 00:04:08,630
for instance variables, right?

93
00:04:08,630 --> 00:04:11,310
Assembly language and machine language do not have variables,

94
00:04:11,310 --> 00:04:13,440
they have memory, and you can put stuff in it,

95
00:04:13,440 --> 00:04:14,895
take stuff out, right?

96
00:04:14,895 --> 00:04:19,370
There's no idea of a type or anything like that in assembly language or machine language,

97
00:04:19,370 --> 00:04:22,890
but high-level languages provide that to you, right? If statements.

98
00:04:22,890 --> 00:04:24,665
Now, assembly language, machine language,

99
00:04:24,665 --> 00:04:26,690
they have conditional branches and so on,

100
00:04:26,690 --> 00:04:29,510
but these are generally much harder to use than your standard

101
00:04:29,510 --> 00:04:32,440
if statement that you would see in any normal high-level language or loops or,

102
00:04:32,440 --> 00:04:33,765
for loops things like this.

103
00:04:33,765 --> 00:04:36,620
You can create these things in assembly and machine language,

104
00:04:36,620 --> 00:04:39,610
but they are harder to write than they would be in a high-level language.

105
00:04:39,610 --> 00:04:43,870
So, high-level languages are basically everything that most people program in.

106
00:04:43,870 --> 00:04:48,200
So, you can imagine these different categories.

107
00:04:48,200 --> 00:04:50,075
Now, the language that we're talking about Go.

108
00:04:50,075 --> 00:04:54,870
Go is of course a high-level language in this set of three categories,

109
00:04:54,870 --> 00:04:56,675
it will be considered high level.

110
00:04:56,675 --> 00:04:59,850
Remember that term high-level is subjective, okay?

111
00:04:59,850 --> 00:05:01,560
But I'll call it high level.

112
00:05:01,560 --> 00:05:04,835
So, all software that I have highlighted in the slide,

113
00:05:04,835 --> 00:05:07,010
all software needs to be translated into

114
00:05:07,010 --> 00:05:09,460
the machine language of the processor to be executed.

115
00:05:09,460 --> 00:05:11,300
So, what that means is,

116
00:05:11,300 --> 00:05:13,460
that if you've got a processor or some kind,

117
00:05:13,460 --> 00:05:15,915
some i7 or whatever processor you're working with,

118
00:05:15,915 --> 00:05:22,395
that processor does not know C or Java or Python or Go or C++ or any of those, right?

119
00:05:22,395 --> 00:05:24,660
All it knows is its own machine language,

120
00:05:24,660 --> 00:05:26,280
say x86 machine language,

121
00:05:26,280 --> 00:05:30,060
if it's an Intel based processor or an AMD or something like that,

122
00:05:30,060 --> 00:05:31,690
so it knows that machine language.

123
00:05:31,690 --> 00:05:34,620
So, in order for the code to execute on the processor,

124
00:05:34,620 --> 00:05:38,790
it has to be first translated into the machine language of the processor.

125
00:05:38,790 --> 00:05:41,330
So, even if it's C, Python,

126
00:05:41,330 --> 00:05:43,580
Java whatever it is, has to be translated.

127
00:05:43,580 --> 00:05:47,645
So, there is this software translation step that has to go on.

128
00:05:47,645 --> 00:05:50,280
Okay, now, this translation step,

129
00:05:50,280 --> 00:05:53,285
it can go on in one of roughly two ways.

130
00:05:53,285 --> 00:05:55,259
It can be compiled,

131
00:05:55,259 --> 00:05:57,860
it can be a compilation or interpretation, okay?

132
00:05:57,860 --> 00:06:02,390
Now, a compiled language is a language where the translation from

133
00:06:02,390 --> 00:06:08,435
high-level language to machine code happens one time before you execute the code,

134
00:06:08,435 --> 00:06:11,080
before you deploy the code, happens one time, okay?

135
00:06:11,080 --> 00:06:14,775
So, like in C, C++, Go,

136
00:06:14,775 --> 00:06:17,450
Java partially, there's a compiler,

137
00:06:17,450 --> 00:06:19,220
and you compile the code.

138
00:06:19,220 --> 00:06:21,400
So, somebody writes the source code, they compile it,

139
00:06:21,400 --> 00:06:22,620
and then they execute it,

140
00:06:22,620 --> 00:06:25,440
and they execute the compiled executable, right?

141
00:06:25,440 --> 00:06:29,300
The compiled executable is basically machine language code plus other stuff,

142
00:06:29,300 --> 00:06:31,110
but it's basically machine language code.

143
00:06:31,110 --> 00:06:34,975
So, the idea behind a compiled languages,

144
00:06:34,975 --> 00:06:40,420
the key thing we want to bring out anyway is the fact that this translation occurs once,

145
00:06:40,420 --> 00:06:43,220
it doesn't occur while you're running the code, right?

146
00:06:43,220 --> 00:06:45,025
It happens before you run the code,

147
00:06:45,025 --> 00:06:46,190
and then when you run the code,

148
00:06:46,190 --> 00:06:48,755
you are just running the machine language instructions directly

149
00:06:48,755 --> 00:06:52,045
because they're already compiled into machine language by the compiler.

150
00:06:52,045 --> 00:06:55,975
So, the other way to do this is interpreted, interpretation.

151
00:06:55,975 --> 00:06:58,505
In interpreted language what happens is,

152
00:06:58,505 --> 00:07:01,750
instructions are translated while the code is executed.

153
00:07:01,750 --> 00:07:05,300
So, what happens is,

154
00:07:05,300 --> 00:07:09,660
it happens it adds time to the execution because every time you see an instruction,

155
00:07:09,660 --> 00:07:11,870
and say Python, that code,

156
00:07:11,870 --> 00:07:14,845
that instruction has to be translated into machine code on a fly,

157
00:07:14,845 --> 00:07:17,860
and that takes a certain amount of time just to do that translation.

158
00:07:17,860 --> 00:07:20,359
So, in addition to actually executing the instruction,

159
00:07:20,359 --> 00:07:23,725
you've got to do this translation from the instruction into the equivalent machine code,

160
00:07:23,725 --> 00:07:25,385
so that slows you down.

161
00:07:25,385 --> 00:07:28,600
So, the translation occurs every time you run the Python code,

162
00:07:28,600 --> 00:07:30,755
say or Java, the Java byte code.

163
00:07:30,755 --> 00:07:36,360
I put Java as partially in both categories because Java it's compiled,

164
00:07:36,360 --> 00:07:37,870
but it generates what's called byte code,

165
00:07:37,870 --> 00:07:41,410
not actual machine code and then the byte code has to be interpreted at runtime.

166
00:07:41,410 --> 00:07:44,085
So, there's an Interpreter also in the Java virtual machine,

167
00:07:44,085 --> 00:07:47,840
but these interpretive languages require an interpreter to be

168
00:07:47,840 --> 00:07:50,000
executing while you're running your code because it has to

169
00:07:50,000 --> 00:07:52,770
be doing this translation as you execute the code,

170
00:07:52,770 --> 00:07:55,320
and so that slows you down.

171
00:07:55,320 --> 00:08:00,415
Now, this is a trade off between compiled code and interpreted code.

172
00:08:00,415 --> 00:08:02,295
The first level is trade off.

173
00:08:02,295 --> 00:08:04,380
One big difference you can see is,

174
00:08:04,380 --> 00:08:07,185
its compiled code is generally faster to execute,

175
00:08:07,185 --> 00:08:10,820
that's because you don't have to do the translation every time you run the code,

176
00:08:10,820 --> 00:08:12,000
so it is going to be faster.

177
00:08:12,000 --> 00:08:13,580
Now, there are people who would argue the opposite,

178
00:08:13,580 --> 00:08:16,125
but generally compiled code is a lot faster.

179
00:08:16,125 --> 00:08:18,140
Now, on the other hand though,

180
00:08:18,140 --> 00:08:20,445
interpreters make coding easier.

181
00:08:20,445 --> 00:08:24,130
So, the thing about interpreters is that, the interpreter itself,

182
00:08:24,130 --> 00:08:26,720
that program that is doing the translation of your code,

183
00:08:26,720 --> 00:08:28,160
it can help you,

184
00:08:28,160 --> 00:08:29,990
it can handle things that you,

185
00:08:29,990 --> 00:08:31,665
as a programmer, don't want to handle.

186
00:08:31,665 --> 00:08:34,065
For instance, in Python,

187
00:08:34,065 --> 00:08:36,540
I don't have to declare my variable types.

188
00:08:36,540 --> 00:08:39,820
I can just start using a variable and the interpreter will say,

189
00:08:39,820 --> 00:08:42,845
"It looks like he's using it as an integer, make it an integer."

190
00:08:42,845 --> 00:08:45,865
So, that's something that the programmer doesn't have to think about.

191
00:08:45,865 --> 00:08:51,280
Another thing that interpreters commonly often have is memory management.

192
00:08:51,280 --> 00:08:52,670
In fact, almost always they have this.

193
00:08:52,670 --> 00:08:53,850
They can manage their memory,

194
00:08:53,850 --> 00:08:55,460
and by that I mean,

195
00:08:55,460 --> 00:09:00,100
getting rid of variables and other pieces of data when you're not using them.

196
00:09:00,100 --> 00:09:01,975
So, when you use a variable,

197
00:09:01,975 --> 00:09:05,480
that variable has to go into memory somewhere, and that memory,

198
00:09:05,480 --> 00:09:08,100
if you keep making variables and using a memory space,

199
00:09:08,100 --> 00:09:09,390
you will eventually run out of memory,

200
00:09:09,390 --> 00:09:11,180
things will slow down and you'll run out of memory.

201
00:09:11,180 --> 00:09:13,030
So, you have to manage your memory,

202
00:09:13,030 --> 00:09:16,040
that is when you're done using an object, you want to get rid of that,

203
00:09:16,040 --> 00:09:17,600
de-allocate it from memory,

204
00:09:17,600 --> 00:09:21,585
and that happens automatically in an interpreted language,

205
00:09:21,585 --> 00:09:23,210
so the interpreter handles that.

206
00:09:23,210 --> 00:09:25,015
So, that's a good thing about interpreters.

207
00:09:25,015 --> 00:09:29,590
So, Go is a good compromise between this compiled and interpreted type of language.

208
00:09:29,590 --> 00:09:30,985
It's a compiled language,

209
00:09:30,985 --> 00:09:34,730
but it has some of the good features of interpreted language,

210
00:09:34,730 --> 00:09:37,010
specifically it has garbage collection.

211
00:09:37,010 --> 00:09:41,570
So, garbage collection is the automatic memory management that I'm talking about.

212
00:09:41,570 --> 00:09:43,130
So, this memory management,

213
00:09:43,130 --> 00:09:45,000
where should memory be allocated,

214
00:09:45,000 --> 00:09:47,170
so I'd say, "I need a variable x.

215
00:09:47,170 --> 00:09:48,410
Where should I put it in memory?

216
00:09:48,410 --> 00:09:50,445
What type of memory I should put it in?"

217
00:09:50,445 --> 00:09:52,590
We'll, talk about that a little bit later,

218
00:09:52,590 --> 00:09:55,370
but also when am I done with that memory, right?

219
00:09:55,370 --> 00:09:56,540
Because when you're done with the memory,

220
00:09:56,540 --> 00:09:57,670
you can get rid of a memory.

221
00:09:57,670 --> 00:10:00,005
You don't have to use it anymore, you can use it for something else.

222
00:10:00,005 --> 00:10:02,490
So, that's what I talk about memory management,

223
00:10:02,490 --> 00:10:04,900
that's what I mean and this happens automatically.

224
00:10:04,900 --> 00:10:07,040
The garbage collector can figure that out, it says, "Oh,

225
00:10:07,040 --> 00:10:09,415
it looks like this program is done with variable x,

226
00:10:09,415 --> 00:10:13,060
I will free that memory now," and that happens automatically.

227
00:10:13,060 --> 00:10:16,045
Manual memory management is hard.

228
00:10:16,045 --> 00:10:20,240
This is, if you've ever done C or something like this,

229
00:10:20,240 --> 00:10:23,970
you know this, deallocate memory too early,

230
00:10:23,970 --> 00:10:25,375
if you stop using it too early,

231
00:10:25,375 --> 00:10:27,840
then you will have false memory accesses, you still need it,

232
00:10:27,840 --> 00:10:32,330
so you'll use the memory that's already deallocated and errors crop up because of that.

233
00:10:32,330 --> 00:10:34,030
Also if you deallocate it too late,

234
00:10:34,030 --> 00:10:36,300
then you're wasting memory, you can have what's called a memory leak,

235
00:10:36,300 --> 00:10:39,980
where you have more and more memory that's not actually being used,

236
00:10:39,980 --> 00:10:43,905
but it's being blocked up because your machine thinks it's being used, right?

237
00:10:43,905 --> 00:10:47,545
So, at memory management manually is very difficult,

238
00:10:47,545 --> 00:10:50,560
and there are lots of errors, security errors too.

239
00:10:50,560 --> 00:10:55,970
So, Go has a garbage collection code included,

240
00:10:55,970 --> 00:10:57,435
so when it compiles your code,

241
00:10:57,435 --> 00:11:00,640
it also compiles garbage collection into your code automatically,

242
00:11:00,640 --> 00:11:02,960
and this is typically only done by interpreter.

243
00:11:02,960 --> 00:11:07,180
So, this is a compiled language that actually has garbage collection,

244
00:11:07,180 --> 00:11:08,460
which is a really good feature.

245
00:11:08,460 --> 00:11:11,930
Now, downside is that it slows down execution a bit,

246
00:11:11,930 --> 00:11:13,635
but it's an efficient garbage collector,

247
00:11:13,635 --> 00:11:15,980
so it doesn't slow down much and you get a lot of

248
00:11:15,980 --> 00:11:19,260
advantage of having this automatic garbage collection.