So, we've been talking about variables and how they're referenced. Variables, they're all referring to some data that somewhere in memory. So, the variables eventually have to be deallocated in memory. So allocated and deallocated. So what I mean is once you declare a variable and your code is running your space needs to be allocated somewhere in memory for that variable. If it's an integer, there has to be some allocated space dedicated to holding that integer and at some point that space has to be deallocated. When you're done using it all right. So, when you're done using your variable X, you want to be able to say "Oh that space is now free and it can be used for other purposes." So, that's deallocation, when you make memory space available for other purposes. You have to do this in a timely fashion. So, otherwise you eventually will run out of memory and your machine. So for an example, you look at this piece of code it declares a variable X, var X equals 1, so the process when it runs it has to allocate a memory location just for X to hold it. Now say you call in your program you call this function f 100 times right, then it's going to allocate 100 different spaces for this variable X right, because the X goes away after the function completes the X goes away it's going to allocate it again it should go away, you want it to go away. But every time if you don't deallocate it, you'll execute, every time you execute this function f you will get a new variable X allocated and so you'll have all these spaces allocated in memory and really you don't need them anymore right? I mean once a particular function call ends you no longer need the space for the X that it was using. So, at some point you have to deallocate this memory. You have to say "Look this memory is now free, " because otherwise you would eventually use up all your space and you might think well, how am I going to use it my space I've got X number of gig in my memory system. You can eat that up very quickly and believe me this is called a memory leak this is a thing that happens in C a lot. You can eat up all your space very quickly. So, you have to deallocate this space in a timely fashion. Now in order to talk about how space is de-allocated, we got to talk a little bit about where the space is stored in memory. So, memory is a big thing but there are two big hunks of memory that are relevant to us right now, the stack and the heap. Now the stack is an area of memory that is dedicated to function calls, primarily dedicated to function calls. So, one of the things is stored in the stack are the local variables for a function. So every time you call a function there can be variables that you define in that function and generally they go into the stack. They are allocated in the stack area of the memory and they're deallocated. If they're allocated in the stack, they are deallocated automatically when the function completes. Now this is this is different a little bit different for go. This is traditional. What I'm talking about now is how it works in regular languages. Go change this a little bit, okay. But normally the stack is the area of these local variables where when the function is done, the variables are deallocated automatically. Now the heap on the other hand, is a persistent region of memory where when you allocate something on the heap it doesn't go away just because the function that allocated it is complete, that heap memory it you have to explicitly deallocate it somehow in another language. So if you were in say C, you would have to explicitly deallocate this. Now Go does a tweak on this. But it is still important to understand that memory variables can be in the stack which will for the most part automatically go away when the variable, will be deallocated automatically when the function is done or in the heap where it's persistent. Now if you're in another language like C, then you have to manually deallocate things on the heap. The stuff that's on the stack you don't have to manually deallocate it, it will go away when the function completes. But stuffs on the heap you have to manually explicitly deallocate it. So, say you were working in C, if you want to allocate memory on the heap, you would call a function called malloc, and I say I say X equals malloc 32. It'll allocate 32 bytes of memory and X will be appointed to that and then later when I'm, that's how you allocate it. Later when I want to free it I'd say free X and it will free that space deallocating it. So, error prone but fast. So, what I mean by that is, it's error prone because it's easy to make a mistake in your allocation and deallocation. Deallocating at the wrong time or forgetting to deallocate it stuff like this, it can cause headaches. So, it's error prone in that sense but its fast. The implementations are very fast. What happens with deallocation in an interpreted language is that the interpreter does it okay and that can take time. So but in a compiled language like C, you would have to do that manually.