To continue with the control flow, we were looking at switch. Let's talk about a Tagless switch. This is a variant on the regular switch. So, normal switches, they have a tag, switch X let's say, and that's the tag, that X, and that's a variable that's going to be compared to constants that are right after the cases. So case one, case two, case three, X as compared to those constants one, two and three. So, sometimes, that's not what you want. Sometimes, you can have a switch without a tag. And when you do that, then what happens is the case that X it gets executed is the first case whose expression is true. So what I mean by this is, when you don't have a tag in the switch, then each case is going to have to have it. Instead of having a constant after, it will have some expression that resolves to a Boolean, true or false. And if that Boolean is true, then that's the case it's executed and it'll execute the first case whose condition is actually true. So, here's an example of that, in this case we have a switch, there's no tag. We just have these cases, two cases plus a default. So, case X greater than one, case X less than negative one and then default. So, in this situation, since there's no tag, it just looks to the right of the case keyword, looks the condition, X greater than one, evaluates that. If it's true, then that's the case it gets executed and we're done to switch. If it's false, it goes and checks the next case to see if this condition is true, and so on until you're done with all your cases. And then if none of them happen, then the default is executed if you've included a default. So that's the tagless switch, and you can use that as well. Instead of if else, if else if, you'd use a switch like this, tagless switch. Break and continue were also control flow instructions. Sometimes the're considered bad form, but they definitely exist and they're used. So, break and continual for loops. So, a break exits the containing loop. So say you're inside a loop and that loop, in this case we got a four loop and i equals 0, i less than ten, and there's an i plus plus inside the loop. So, this is supposed to happen, whatever this is, it's supposed to iterate through ten times conceivably. But notice inside the loop, it says if X equal, equal five then break. So, if it hits that break, and it will in this case, when it hits that break, it will exit the loop. So, this thing only execute for i equals zero, one, two, three, four, and five. It'll go into the loop and it'll hit the break on the fifth pass through the loop, so it won't finish the loop. So, break just jumps out of whatever the containing loop is and quits the loop. Now continue on the other hand, it also uses loops. It doesn't quit you out of the loop, it just skips the current iteration of the loop. So, if we look at the continue example, same code, except instead of a break, it calls the continue. If i equal equal five, then it calls continue. So, in this case, if without that if statement and that continue, it would execute this loop 10 times, because i starts at zero, it goes up to the condition i less than less than 10. So, it would execute 10 times. But for this loop, it says if i equal equal five continue, so that one iteration where i is equal to five, it will continue and just jump right past that iteration of the loop. So the loop will execute, but it won't execute as many times. It'll skip one iteration of the loop. So, scan is a function to read the user's input. This isn't a control-flow function, but we need to hit this because read user input is something that you're going to use in the code examples that you write. Sort of a common thing to do, you want to read input that the user types into the keyboard. So, this isn't the format package. What scan does is it takes a pointer as an argument. So, what you do is you make a pointed to some value that you expect the user to type in. So, if a user is going to type in an integer, you'd make an integer and you would pass a pointer to that integer to the scan function. You call Scan, and when you execute the scan function, it blocks. The program waits until the user types in something and hits Enter. When they hit Enter, the scan function will take whatever they typed in and will place it wherever the pointer is pointing. So, it will take what they typed in and put it into say an integer. If you pass the pointer to an integer, it will take it, turned to an integer point in, put it into that integer. And what it returns is the number of scanned items. It returns actually two things; the number of scanned items, the number of tokens that a person typed in. So, space separate tokens that's returned, also an error. The second thing is returned as an error. If there's an error, it'll return something other than nil. If there's no error, it'll just return nil for that error. But if there's an error, it'll return an error code and we could investigate that. So, we can look at this example code. Let's say, we make a variable appleNum and it's an integer. Then we print out number of apples, question expecting the user to type in how many apples. So, we expect them to type in some integer, five, let's say. So, the next line, it executes the scan function. The code will actually stop running there and wait until the user types in something and hits Enter. So, let's say the user types in a five hits enter. Then notice that the argument to scan the argument pass is ampersand appleNum, which means the address of the AppleNum variable. So, when the user types in five and hits enter, that scan function takes that number five, puts it into the appleNum variable. So on the next line, when I say, printf appleNum, it'll print five or whatever integer they typed in.