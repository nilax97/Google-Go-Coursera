1
00:00:08,720 --> 00:00:15,350
So, we're going to talk about what the scope of a variable is.

2
00:00:15,350 --> 00:00:18,420
Roughly, the scope of a variable is that

3
00:00:18,420 --> 00:00:21,775
the places in the code where a variable can be accessed.

4
00:00:21,775 --> 00:00:27,240
So, variable scope defines how a variable reference is resolved in the code.

5
00:00:27,240 --> 00:00:29,760
So, if you reference a variable x,

6
00:00:29,760 --> 00:00:34,425
how does the program figure out which variable actually talking about.

7
00:00:34,425 --> 00:00:36,605
That's basically what variable scope is.

8
00:00:36,605 --> 00:00:40,880
So, these little examples just to show you an example of scope.

9
00:00:40,880 --> 00:00:43,030
If we look at the first block of code,

10
00:00:43,030 --> 00:00:45,830
we got this variable x, I'm highlighting in red.

11
00:00:45,830 --> 00:00:50,000
This variable x is defined outside of these two functions.

12
00:00:50,000 --> 00:00:51,400
So, I've got these two functions defined.

13
00:00:51,400 --> 00:00:55,430
Function f and function g. But outside of both of them,

14
00:00:55,430 --> 00:00:56,520
I define this variable x.

15
00:00:56,520 --> 00:00:58,865
So, var x equals to, wherever it is, one.

16
00:00:58,865 --> 00:01:02,585
Then, I defined my function f and function g. Now,

17
00:01:02,585 --> 00:01:05,245
if you look inside function f and g, the're very simple.

18
00:01:05,245 --> 00:01:08,690
All they doing is they're printing x,

19
00:01:08,690 --> 00:01:11,185
they're both printing x, is all they doing.

20
00:01:11,185 --> 00:01:15,080
So, inside function f and inside function g,

21
00:01:15,080 --> 00:01:16,675
when you call these functions,

22
00:01:16,675 --> 00:01:21,240
they've got to figure out where to find the value for x.

23
00:01:21,240 --> 00:01:22,945
Now, in this case,

24
00:01:22,945 --> 00:01:25,830
they're going to find the value that I've defined outside.

25
00:01:25,830 --> 00:01:27,820
So, where I say var x equals one,

26
00:01:27,820 --> 00:01:31,395
when they print out x, they going to print out one for x.

27
00:01:31,395 --> 00:01:34,790
Because of the scoping rules allow that.

28
00:01:34,790 --> 00:01:38,160
So basically, because it define outside of either one of these functions,

29
00:01:38,160 --> 00:01:39,830
then both of them will have access to it.

30
00:01:39,830 --> 00:01:42,080
We'll define the formal rules for that in a few slides.

31
00:01:42,080 --> 00:01:45,710
Now, the next block of code, you get a problem.

32
00:01:45,710 --> 00:01:47,420
Because the next block of code again,

33
00:01:47,420 --> 00:01:49,370
you've got function f and function g,

34
00:01:49,370 --> 00:01:53,010
but this time variable x is defined inside function f,

35
00:01:53,010 --> 00:01:57,510
but not inside function g. It's only inside f. So,

36
00:01:57,510 --> 00:02:00,200
function f will print properly because

37
00:02:00,200 --> 00:02:03,145
it'll look at x and resolve it since it's defined locally,

38
00:02:03,145 --> 00:02:04,310
right there inside, it's functional.

39
00:02:04,310 --> 00:02:06,315
So, x is equal to one, and it'll be happy.

40
00:02:06,315 --> 00:02:09,230
But function g will have no reference to x.

41
00:02:09,230 --> 00:02:12,125
It won't be able to see that and it'll throw an error when you try to run that,

42
00:02:12,125 --> 00:02:13,910
because they won't know what x is.

43
00:02:13,910 --> 00:02:17,960
So, this is the type of problem that needs to be resolved,

44
00:02:17,960 --> 00:02:19,400
you don't want to run into this type of problem.

45
00:02:19,400 --> 00:02:23,350
You want to be able to know where your variables get resolved to.

46
00:02:23,350 --> 00:02:25,345
So that you don't have problems like this.

47
00:02:25,345 --> 00:02:27,470
So, we're going to talk about variable scoping right now.

48
00:02:27,470 --> 00:02:32,780
So, how does the compiler figure out where a variable reference should be resolved to?

49
00:02:32,780 --> 00:02:34,110
Which x are you talking about?

50
00:02:34,110 --> 00:02:36,960
It's this x versus that x.

51
00:02:36,960 --> 00:02:43,460
So, in Go, variable scoping is done using blocks.

52
00:02:43,460 --> 00:02:49,380
Now, block is a sequence of declarations and statements within matching curly brackets.

53
00:02:49,380 --> 00:02:50,990
So, those curly brackets right there,

54
00:02:50,990 --> 00:02:52,450
you have an open curly bracket,

55
00:02:52,450 --> 00:02:55,340
closed curly bracket, everything in between is called a block.

56
00:02:55,340 --> 00:02:57,820
So, that's how you explicitly define blocks.

57
00:02:57,820 --> 00:03:00,275
You notice how these blocks can be hierarchical.

58
00:03:00,275 --> 00:03:02,570
You can have curly brackets and then within that you

59
00:03:02,570 --> 00:03:05,480
can have some other curly brackets and within that you can have some more.

60
00:03:05,480 --> 00:03:08,450
So, you can have this hierarchy of blocks.

61
00:03:08,450 --> 00:03:10,300
These are explicit blocks.

62
00:03:10,300 --> 00:03:12,050
When you put the curly brackets in your own code,

63
00:03:12,050 --> 00:03:13,470
those are explicit blocks that you,

64
00:03:13,470 --> 00:03:14,910
as a programmer included.

65
00:03:14,910 --> 00:03:16,855
Our function definitions notice,

66
00:03:16,855 --> 00:03:19,350
are defined by curly brackets.

67
00:03:19,350 --> 00:03:21,830
We haven't gotten to functions, we'll talk about it more later.

68
00:03:21,830 --> 00:03:24,110
But every function definition, you define the function,

69
00:03:24,110 --> 00:03:25,550
gives the name of the function,

70
00:03:25,550 --> 00:03:27,640
and then you have open curly brackets, closed curly brackets.

71
00:03:27,640 --> 00:03:30,095
Every function, you got curly brackets.

72
00:03:30,095 --> 00:03:34,830
So, there's a hierarchy of these curly brackets and hierarchy of these blocks.

73
00:03:34,830 --> 00:03:38,190
Now, also there implicit blocks inside this hierarchy.

74
00:03:38,190 --> 00:03:42,500
So, there are blocks that are implicitly defined without the curly brackets.

75
00:03:42,500 --> 00:03:44,210
So, just to list those blocks,

76
00:03:44,210 --> 00:03:45,975
first is the universe block.

77
00:03:45,975 --> 00:03:47,755
That's all Go source code,

78
00:03:47,755 --> 00:03:50,225
that is the biggest block, the universe block.

79
00:03:50,225 --> 00:03:51,660
There's a package block.

80
00:03:51,660 --> 00:03:54,440
So, every package, you don't put curly brackets around

81
00:03:54,440 --> 00:03:57,825
every package at all the source code in a particular package,

82
00:03:57,825 --> 00:03:59,335
that's all within one block,

83
00:03:59,335 --> 00:04:01,365
which is inside the universe block.

84
00:04:01,365 --> 00:04:03,360
Then, there's file block.

85
00:04:03,360 --> 00:04:07,860
File block, all the source code in a single file is within the file block,

86
00:04:07,860 --> 00:04:10,490
and remember that package can be composed of many files.

87
00:04:10,490 --> 00:04:12,380
So, there can be one package block that has

88
00:04:12,380 --> 00:04:15,865
many file block if you got a lot of files inside the package.

89
00:04:15,865 --> 00:04:19,600
Now, then other implicit blocks include the if statement,

90
00:04:19,600 --> 00:04:21,650
for statement, and switch statements.

91
00:04:21,650 --> 00:04:26,060
All these have curly brackets that define their own blocks.

92
00:04:26,060 --> 00:04:29,070
Also, the clauses inside a switch or select.

93
00:04:29,070 --> 00:04:31,240
We'll get to these in more detail later.

94
00:04:31,240 --> 00:04:33,260
But these are all, all the ones I'm listing here are

95
00:04:33,260 --> 00:04:38,110
these implicit blocks that you don't have to put explicit curly brackets for.

96
00:04:38,110 --> 00:04:40,080
Well, so you can.

97
00:04:40,080 --> 00:04:41,110
So, for instance, an if statement,

98
00:04:41,110 --> 00:04:42,940
you can use it curly brackets too.

99
00:04:42,940 --> 00:04:44,320
But like the universe block,

100
00:04:44,320 --> 00:04:45,485
the package block, file block,

101
00:04:45,485 --> 00:04:48,840
these are all implicit blocks and there's a hierarchy of these.

102
00:04:48,840 --> 00:04:52,205
So, this is my point, that there's this hierarchy of these blocks and

103
00:04:52,205 --> 00:04:57,320
each block can have its own environment variables associated with it.

104
00:04:57,590 --> 00:05:00,635
So, lexical scoping.

105
00:05:00,635 --> 00:05:04,695
This defines how variable references are resolved.

106
00:05:04,695 --> 00:05:08,955
So, Go is a lexically scoped language using blocks.

107
00:05:08,955 --> 00:05:11,090
So, when we talk about lexical scoping,

108
00:05:11,090 --> 00:05:12,725
we've got to talk about this relationship

109
00:05:12,725 --> 00:05:16,980
of one block being defined inside another block.

110
00:05:16,980 --> 00:05:19,350
So, I'm using this terminology here,

111
00:05:19,350 --> 00:05:22,425
I'm saying bi is greater than/equal to bj.

112
00:05:22,425 --> 00:05:25,200
If bj, b is a block.

113
00:05:25,200 --> 00:05:27,885
If bj is defined inside bi,

114
00:05:27,885 --> 00:05:32,100
then bi is greater than or equal to bj.

115
00:05:32,100 --> 00:05:34,620
So, I would say that bj,

116
00:05:34,620 --> 00:05:36,920
if it's defined inside bi, bj would be,

117
00:05:36,920 --> 00:05:38,510
I refer to it as an inner scope,

118
00:05:38,510 --> 00:05:42,705
where the outer scope that includes bj is bi.

119
00:05:42,705 --> 00:05:45,690
So, just as an example of this,

120
00:05:45,690 --> 00:05:49,370
it's a transitive relationship, but just as an example of this, look at the code.

121
00:05:49,370 --> 00:05:51,835
We got, we've seen this code before.

122
00:05:51,835 --> 00:05:55,445
Got variable x, we'd initialize it to one.

123
00:05:55,445 --> 00:05:58,805
Then, you got a function f and function g. Now,

124
00:05:58,805 --> 00:06:01,955
if we look at the blocks inside here,

125
00:06:01,955 --> 00:06:04,240
first you got, this is all in one file.

126
00:06:04,240 --> 00:06:09,220
So, all of this is inside the file block and I'm calling that b1.

127
00:06:09,220 --> 00:06:12,440
So, b1 is my file block and everything is inside the file block.

128
00:06:12,440 --> 00:06:13,980
But in addition to the file block,

129
00:06:13,980 --> 00:06:15,155
I'm defining two function,

130
00:06:15,155 --> 00:06:18,380
f and g. Each one of these function blocks,

131
00:06:18,380 --> 00:06:20,235
the functions gets its own function block,

132
00:06:20,235 --> 00:06:26,110
so b2 is the function block for f and b3 is the function block for g. So,

133
00:06:26,110 --> 00:06:29,165
if I were to look at how these blocks are related,

134
00:06:29,165 --> 00:06:33,390
a b2 and b3 are both defined inside b1.

135
00:06:33,390 --> 00:06:35,760
So, I say b1 is greater than b2,

136
00:06:35,760 --> 00:06:38,395
and b1 is greater than b3 by my definition,

137
00:06:38,395 --> 00:06:41,180
because b2 and b3 are defined inside b1.

138
00:06:41,180 --> 00:06:44,205
But notice that there's no relationship between b2 and b3.

139
00:06:44,205 --> 00:06:46,745
Because they're not defined within each other.

140
00:06:46,745 --> 00:06:49,040
So, we need to know this,

141
00:06:49,040 --> 00:06:52,110
because the scoping rules,

142
00:06:52,110 --> 00:06:53,540
when you're resolving a variable,

143
00:06:53,540 --> 00:06:56,180
you go to the greater including scope.

144
00:06:56,180 --> 00:07:00,145
So, for instance, if inside b1 the function f and inside of that block,

145
00:07:00,145 --> 00:07:02,175
you're referring to variable x.

146
00:07:02,175 --> 00:07:06,150
Then, it's going to look for that variable x inside b2 itself,

147
00:07:06,150 --> 00:07:07,315
inside its local block.

148
00:07:07,315 --> 00:07:10,580
But then, it looks for the next bigger block that is defined inside.

149
00:07:10,580 --> 00:07:11,910
So, it starts in b2,

150
00:07:11,910 --> 00:07:13,830
looks for the block, it looks for variable x.

151
00:07:13,830 --> 00:07:16,585
If it doesn't see it there, which is not defined there, in this case,

152
00:07:16,585 --> 00:07:20,310
then it says, "Okay what is the next bigger block that I've defined inside?"

153
00:07:20,310 --> 00:07:22,800
It would get b1, and when it look inside b1 and say,

154
00:07:22,800 --> 00:07:24,820
"Ah, there is a definition of x here."

155
00:07:24,820 --> 00:07:26,960
That's the definition of x that it would use.

156
00:07:26,960 --> 00:07:28,755
Same goes for b3.

157
00:07:28,755 --> 00:07:31,035
If you look at the function g,

158
00:07:31,035 --> 00:07:33,150
it uses variable x,

159
00:07:33,150 --> 00:07:34,660
it access variable x.

160
00:07:34,660 --> 00:07:38,170
First it looks inside its local block b3, it doesn't see it.

161
00:07:38,170 --> 00:07:41,255
So, it looks inside the next bigger block that's defined inside,

162
00:07:41,255 --> 00:07:43,260
b1 and it sees it there.

163
00:07:43,260 --> 00:07:45,525
So, that's why this works,

164
00:07:45,525 --> 00:07:47,415
this why this code will work.

165
00:07:47,415 --> 00:07:48,970
The x will be resolved properly,

166
00:07:48,970 --> 00:07:50,135
so that x equals one,

167
00:07:50,135 --> 00:07:52,600
that variable that we defined inside b1.

168
00:07:52,600 --> 00:07:56,925
So, when you're talking about scope variables,

169
00:07:56,925 --> 00:08:00,590
a variable is accessible from a block bj,

170
00:08:00,590 --> 00:08:04,720
if the variables declared in some block bi,

171
00:08:04,720 --> 00:08:08,185
and block bi is greater than/equal to bj.

172
00:08:08,185 --> 00:08:10,850
So, it's either the variables you declared right there in

173
00:08:10,850 --> 00:08:15,540
bj or it's declared in some outer block that's greater than bj.

174
00:08:15,540 --> 00:08:17,970
So, that's why in the first block of code,

175
00:08:17,970 --> 00:08:21,430
first block of the first step code sequence,

176
00:08:21,430 --> 00:08:24,905
you can see where x is defined inside the file block.

177
00:08:24,905 --> 00:08:27,985
Both of those functions, which are also inside the same file block,

178
00:08:27,985 --> 00:08:31,130
they can both properly access the x variable because

179
00:08:31,130 --> 00:08:34,490
their function blocks are within the file block.

180
00:08:34,490 --> 00:08:36,140
But in the next block of code,

181
00:08:36,140 --> 00:08:38,250
next sequence of code,

182
00:08:38,250 --> 00:08:42,230
the x is defined inside the function block of

183
00:08:42,230 --> 00:08:45,800
f. But it's not inside the function block of g. So,

184
00:08:45,800 --> 00:08:47,720
when g tries to reference x,

185
00:08:47,720 --> 00:08:50,300
the variable x, it doesn't see it in its local block.

186
00:08:50,300 --> 00:08:52,790
It also doesn't see it in its file block,

187
00:08:52,790 --> 00:08:58,145
because now the definition is inside the function block for function f. So,

188
00:08:58,145 --> 00:09:00,660
that's why this fails,

189
00:09:00,660 --> 00:09:05,170
x doesn't get resolved back to anything and there's an error.