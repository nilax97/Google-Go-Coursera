1
00:00:10,880 --> 00:00:15,270
So, we've been talking about deallocation, deallocating memory,

2
00:00:15,270 --> 00:00:20,695
and it can be hard to determine when it is appropriate to deallocate a variable.

3
00:00:20,695 --> 00:00:24,000
Reason is because you can only deallocate a variable

4
00:00:24,000 --> 00:00:26,810
when you know the variable is no longer in use.

5
00:00:26,810 --> 00:00:28,525
You don't want to deallocate

6
00:00:28,525 --> 00:00:32,310
a variable and then later need that variable that you deallocated,

7
00:00:32,310 --> 00:00:34,075
because then it's basically gone.

8
00:00:34,075 --> 00:00:37,400
So, it's hard sometimes to figure that out,

9
00:00:37,400 --> 00:00:42,455
figure out when it's not in use or when it is in use and so on.

10
00:00:42,455 --> 00:00:46,685
So, here's an example, a Go example.

11
00:00:46,685 --> 00:00:49,190
This is legal in Go but because this is a pain,

12
00:00:49,190 --> 00:00:52,120
his is not legal in certain other languages but in Go this is legal thing.

13
00:00:52,120 --> 00:00:54,275
If you look at the first function foo.

14
00:00:54,275 --> 00:00:56,680
Inside there we declare this variable x.

15
00:00:56,680 --> 00:00:59,150
So, It's a local variable to this function foo

16
00:00:59,150 --> 00:01:02,770
and what's returned though is the address of x,

17
00:01:02,770 --> 00:01:05,130
f say x, write a pointer to x.

18
00:01:05,130 --> 00:01:08,010
Now, then in the main function down below,

19
00:01:08,010 --> 00:01:10,690
the main function calls foo.

20
00:01:10,690 --> 00:01:13,325
Then, the main function,

21
00:01:13,325 --> 00:01:17,320
what happens is since it calls foo and it

22
00:01:17,320 --> 00:01:22,990
gets the return value of foo actually gets assigned to a variable in the main function.

23
00:01:22,990 --> 00:01:25,990
So, the trick here, the confusion here,

24
00:01:25,990 --> 00:01:28,940
is that this program foo normally,

25
00:01:28,940 --> 00:01:31,460
if you declare a local variable x when

26
00:01:31,460 --> 00:01:34,575
the function ends that variable x should be deallocated.

27
00:01:34,575 --> 00:01:36,670
Right. You're done with it because the function is done with it.

28
00:01:36,670 --> 00:01:40,840
But in this case it's not the case because is returning a pointer to x.

29
00:01:40,840 --> 00:01:41,990
So, now the main,

30
00:01:41,990 --> 00:01:45,710
since the main now has that pointed to x since that's getting returned to the main,

31
00:01:45,710 --> 00:01:48,330
the main might still use that pointer to x.

32
00:01:48,330 --> 00:01:52,380
So, you can't just say "foo is now done,

33
00:01:52,380 --> 00:01:55,190
I can get rid of its local variable x because maybe

34
00:01:55,190 --> 00:01:58,625
main is going to use that local variable because now main has a pointer to it".

35
00:01:58,625 --> 00:02:02,740
Okay. So, this is actually a legal thing to do in Go.

36
00:02:02,740 --> 00:02:07,490
So, this is just one example of how pointers especially make it

37
00:02:07,490 --> 00:02:12,835
difficult to tell when deallocation is legal and when it's not.

38
00:02:12,835 --> 00:02:15,720
So, deallocation is a complicated thing.

39
00:02:15,720 --> 00:02:17,660
So, what people do?

40
00:02:17,660 --> 00:02:20,300
One way of dealing with that is to have garbage collection.

41
00:02:20,300 --> 00:02:22,865
So, garbage collection is basically

42
00:02:22,865 --> 00:02:27,755
automatic or an automatic tool that deals with deallocation.

43
00:02:27,755 --> 00:02:32,035
So, this is part of interpreted languages and this is done by the interpreter, so if is,

44
00:02:32,035 --> 00:02:34,260
say Java, the Java Virtual Machine

45
00:02:34,260 --> 00:02:37,150
or a Python is a Python interpreter something like that.

46
00:02:37,150 --> 00:02:40,190
It keeps track of these pointers and it

47
00:02:40,190 --> 00:02:43,670
determines when a variable is not in use anymore and when it is.

48
00:02:43,670 --> 00:02:46,370
Once it determines that a variable is definitely not used,

49
00:02:46,370 --> 00:02:47,655
there no more pointers,

50
00:02:47,655 --> 00:02:52,190
no more references to that variable then the garbage collector deallocates it.

51
00:02:52,190 --> 00:02:55,615
Only when it all references are gone.

52
00:02:55,615 --> 00:02:58,220
So, this is nice,

53
00:02:58,220 --> 00:02:59,535
garbage collection is a nice thing.

54
00:02:59,535 --> 00:03:01,070
It's easy for the programmer.

55
00:03:01,070 --> 00:03:04,120
Right. Programmer doesn't have to worry about exactly when deallocation,

56
00:03:04,120 --> 00:03:05,670
when to do it, when not to do it.

57
00:03:05,670 --> 00:03:09,920
Believe me deallocating memory is a big headache,

58
00:03:09,920 --> 00:03:12,620
in other lang say C or something like that.

59
00:03:12,620 --> 00:03:17,300
But, it requires an interpreter so generally compiled languages like C,

60
00:03:17,300 --> 00:03:19,860
C++, they can't do it,

61
00:03:19,860 --> 00:03:22,490
but Go is different.

62
00:03:22,490 --> 00:03:24,590
Okay. Go is different and better in the sense.

63
00:03:24,590 --> 00:03:30,010
So, Go is a compiled language which has garbage collection built into it.

64
00:03:30,010 --> 00:03:33,830
So, that is a unique feature Go which is really nice.

65
00:03:33,830 --> 00:03:37,670
So as a result, the Go compiler can figure

66
00:03:37,670 --> 00:03:41,420
out when to follow these points is

67
00:03:41,420 --> 00:03:45,450
to some extent and figure out when this point you're still in use.

68
00:03:45,450 --> 00:03:47,640
It basically, keeps track we're not going to go into

69
00:03:47,640 --> 00:03:50,365
Go garbage collection because that is the complicated thing.

70
00:03:50,365 --> 00:03:52,490
There are many ways of doing it but generally you have to keep

71
00:03:52,490 --> 00:03:54,980
track of the pointers to a particular object.

72
00:03:54,980 --> 00:03:56,645
Once all the pointers are gone,

73
00:03:56,645 --> 00:03:59,535
then you know that the object can be deallocated.

74
00:03:59,535 --> 00:04:04,015
So, garbage collection in Go allows two things.

75
00:04:04,015 --> 00:04:09,600
One thing is, it will actually allocate stuff on the heap and the stack itself.

76
00:04:09,600 --> 00:04:11,655
So, you as a programmer don't have to determine,

77
00:04:11,655 --> 00:04:13,980
I want to put this on the heap I want to put this on the stack.

78
00:04:13,980 --> 00:04:17,175
The Go compiler, it'll put code in there at compile-time,

79
00:04:17,175 --> 00:04:18,770
it'll figure out this needs to go heap,

80
00:04:18,770 --> 00:04:22,730
this needs to go to the stack and it'll garbage collect appropriately.

81
00:04:22,730 --> 00:04:24,890
So, if it's on the heap it will garbage collected appropriately will

82
00:04:24,890 --> 00:04:27,140
see when all the pointers are gone and it'll

83
00:04:27,140 --> 00:04:31,820
determine when it can be deallocated.

84
00:04:31,820 --> 00:04:33,900
This is a really helpful thing.

85
00:04:33,900 --> 00:04:40,275
Now, there is a downside because the act of garbage collection does take some time.

86
00:04:40,275 --> 00:04:42,980
Right. So, there's a performance hit but it's

87
00:04:42,980 --> 00:04:46,130
a pretty efficient implementation and garbage collection is so

88
00:04:46,130 --> 00:04:49,550
darn useful is probably worth it to put it in Go.

89
00:04:49,550 --> 00:04:51,760
So, that's a trade-off that Go makes.

90
00:04:51,760 --> 00:04:54,440
It slows things down a little bit but it

91
00:04:54,440 --> 00:04:57,690
is a great advantage because it makes programming a lot easier.

92
00:04:57,690 --> 00:04:59,690
You don't have to go as far as using a

93
00:04:59,690 --> 00:05:04,320
full-on interpreter like you would in an interpreted language.