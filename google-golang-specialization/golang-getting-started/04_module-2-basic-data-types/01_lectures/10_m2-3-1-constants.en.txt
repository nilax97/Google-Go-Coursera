So, let's talk a little bit about a constant. So, constant it's pretty obvious what the constant is. It is an expression whose value is known at compile time. Right. So, you know it and it never changes. So, you can just basically declare a variable to be a certain value and it holds that value for all the time, as long as the program is running. The type is inferred from the righthand side of the assignment. So, for instance, here we say const x equals 1.3. So, that's going to set x to the value 1.3 and the compiler looks at 1.3, sees that that's a floating point and so x becomes a floating point. So, it infers from the right hand side of the assignment what the type of the variable needs to be and it is held constant, can't be changed. You can assign many at once. So, constant we have y equals four, z equals hi. Alright. You can give a long list if you want to. So, that's what a constant is. Now, iota is a function used to generate constants. It's interesting. So, it generates a set of related but distinct constants. So, when do you use this? You use this when you have to represent some property or some property that has several different distinct possible value. So, this is also known as one-hot. So, basically if you have a variable and you know it's going to be one-hot coded. Right. This variable can have one to five values let's say. So, you want each one of these five values to be a distinct constant. Right. Now, in a situation like this, just examples of such things, days of the week. Right. You got seven days of the week and you want each day of the week. If you want to define a constant for each day of the week, Monday, Tuesday, Wednesday, you want them all to be constants which are different but which are different and you don't particularly care what the value of the constant is, as long as Monday is different from Tuesday which is different from Wednesday. Months of the year same thing. Right. So, key thing about these constants is, when you use iota to generate these constants, the constants need to be different but the actual value of the constants is not important. So, if I have Monday, Tuesday Wednesday as my constants, I don't care if Monday is 500 or 5,000 or two or something. As long as Monday is not the same as Tuesday, which is not the same as Wednesday. Right. So, that's the case where you can use iota. If that's the case, you need to represent some set of constants with all different values, you don't care exactly what the value is but as long as they are distinct constants then you can use iota. This is essentially just like an enumerated type in other languages like C or something like that. It's the same idea. So, they give you a nice little shorthand for defining these set of constants. So, here's a little example of how you might define something using iota. Say I wanted to find some grades. So, I make a type called grades. I make it an int. I want to represent my grades as integers. I want to have these five grades A, B, C, D and F. I know that I want A, B, C, D and F to be all different grades. Right. So, they should be represented by different integers. But, I don't particularly care what integers they are represented by. I just want A to be something different than B and C and D and F. So, I declare the constants A, B, C, D and F. The first one, I say A give the type grades. Right. Which is actually an int, alias for int. A grades equal iota. I say that in the first constant definition. Then for B, C, D and F, I don't have to repeat that. Right. You can see I just say B, C, D and F. I don't give the type, I don't say iota, none of that. They just do it on the top and what will happen is automatically iota will assign a value to the first constant and then it will assign a different one to the next one, a different one to the next and so on. Actually, what it does what the implementation does is that, it assign it starts at one. So, A would be one, B would be two, C will be three, but you should not depend on that. Right. That's not. So, you don't know the idea behind using iota is it, you don't care what the actual values of the constants are. You just want the constant values to be different from one another. So, it happens that the current implementation starts off at one in increments, but you can't guarantee that in the future maybe that's going to be changed. Right. Just all you know that iota is that they're going to be different.