1
00:00:10,760 --> 00:00:14,010
เรามาต่อกันที่การควบคุมทิศทางของการไหลของโปรแกรมกันนะครับ

2
00:00:14,010 --> 00:00:15,470
ยกตัวอย่างเช่นสวิทช์ปิดเปิด

3
00:00:15,470 --> 00:00:17,000
แต่เรากำลังพูดถึงสวิทช์ปิดเปิดที่ไม่มีป้ายบอก

4
00:00:17,000 --> 00:00:19,025
ซึ่งต่างออกไปจากสวิทช์ปิดเปิดธรรมดา

5
00:00:19,025 --> 00:00:22,650
โดยปกติ สวิทช์จะมีป้ายหรือเครื่องหมายบอก

6
00:00:22,650 --> 00:00:25,120
เช่น สวิทช์ X และเราเรียก X ว่าป้าย

7
00:00:25,120 --> 00:00:27,520
และค่า X คือค่าตัวแปรที่เรากำลังจะนำไป

8
00:00:27,520 --> 00:00:31,495
เปรียบเทียบกับค่าคงที่ ที่จะเปลี่ยนไปทันทีเมื่อเข้าเงื่อนไข

9
00:00:31,495 --> 00:00:33,360
เช่นยกตัวอย่าง ค่าคงที่ 1, 2 หรือ 3

10
00:00:33,360 --> 00:00:36,070
X จะถูกนำมาเปรียบเทียบกับค่าคงที่เหล่านั้น ว่าจะได้ค่าเป็น 1, 2 หรือ 3

11
00:00:36,070 --> 00:00:38,665
แต่บางครั้ง มันอาจไม่เป็นอย่างที่คุณต้องการ

12
00:00:38,665 --> 00:00:41,405
บางครั้ง เราอาจจะเจอสวิทช์ที่ไม่มีป้ายบอกว่าเป็นสวิทช์ของค่าอะไร

13
00:00:41,405 --> 00:00:42,840
และเมื่อเราทำแบบนั้น

14
00:00:42,840 --> 00:00:45,835
สิ่งจะเกิดขึ้นเมื่อสวิทช์ X ถูกกด

15
00:00:45,835 --> 00:00:49,235
คือ ชุดคำสั่งใดที่เป็นจริง จะทำงาน

16
00:00:49,235 --> 00:00:50,455
และที่ผมกำลังจะบอกคือ

17
00:00:50,455 --> 00:00:52,475
เมื่อเราไม่มีป้ายบอกติดสวิทช์

18
00:00:52,475 --> 00:00:54,240
ทางเลือกที่จะเป็นไปได้ทั้งหมดก็จะเปิดกว้าง

19
00:00:54,240 --> 00:00:55,690
โดยแทนที่เราจะกำหนดค่าตัวแปรให้กับแต่ละทางเลือก

20
00:00:55,690 --> 00:01:00,610
มันจะมีชุดคำสั่งที่ทำหน้าที่ตรวจสอบค่าตรรกะ ว่าเป็นจริงหรือเท็จ

21
00:01:00,610 --> 00:01:02,690
และถ้าค่าตรรกะที่ได้ เป็นจริง

22
00:01:02,690 --> 00:01:05,200
และในกรณีที่ทางเลือกไหนถูกสั่งให้ทำงาน

23
00:01:05,200 --> 00:01:08,950
จะเป็นทางเลือกแรกแรกที่พบว่ามีค่าตรรกะเป็นจริง ถูกสั่งให้ทำงาน

24
00:01:08,950 --> 00:01:11,140
ดังนั้น เรามาดูตัวอย่างกัน

25
00:01:11,140 --> 00:01:14,415
ตัวอย่างเรามีสวิทช์หนึ่งอัน ที่ไม่มีป้ายบอกว่าเป็นสวิทช์ของค่าอะไร

26
00:01:14,415 --> 00:01:16,055
เรามีแค่ทางเลือกหลาย ๆ ทางเลือก

27
00:01:16,055 --> 00:01:17,680
มีสองทางเลือก และหนึ่งค่าเริ่มต้น

28
00:01:17,680 --> 00:01:20,640
ทางเลือกแรก ถ้า X มากกว่า 1

29
00:01:20,640 --> 00:01:23,395
ทางเลือกที่สอง คือ X น้อยกว่า -1 หากไม่ใช่ ก็ให้ใช้ค่าเริ่มต้น

30
00:01:23,395 --> 00:01:27,075
ในสถานะการณ์แบบนี้ เมื่อไม่มีป้ายบอกว่าเป็นสวิทช์ของค่าอะไร

31
00:01:27,075 --> 00:01:29,765
มันจะดู และประเมินแต่ละทางเลือก

32
00:01:29,765 --> 00:01:32,290
อ่านและตีความเงื่อนไขของทางเลือก

33
00:01:32,290 --> 00:01:36,025
ถ้าเป็นจริง ทางเลือกนั้นก็จะทำงาน และถือว่าจบการทำงานของสวิทช์

34
00:01:36,025 --> 00:01:39,740
แต่ถ้าเป็นเท็จ มันก็จะข้ามไปตรวจสอบทางเลือดถัดไป

35
00:01:39,740 --> 00:01:42,290
และทำไปเรื่อย ๆ จนกระทั่งจนครบทุกทางเลือก

36
00:01:42,290 --> 00:01:43,655
และถ้าไม่มีทางเลือกไหนเป็นจริงเลย

37
00:01:43,655 --> 00:01:46,210
ค่าเริ่มต้นก็จะถูกนำมาใช้ ถ้าคุณใส่ค่าเริ่มต้นให้มันด้วย

38
00:01:46,210 --> 00:01:47,510
และนั่นคือ สวิทช์ที่ไม่มีป้่ายบอก

39
00:01:47,510 --> 00:01:48,830
และคุณก็สามารถใช้มันได้เช่นกัน

40
00:01:48,830 --> 00:01:51,030
แทนที่เราจะใช้ชุดคำสั่ง If..else ซ้ำ ๆ กันหลาย ๆ ครั้ง

41
00:01:51,030 --> 00:01:54,385
คุณควรใช้คำสั่ง switch แทน, ซึ่งมันก็คือสวิทช์ไร้ป้าย

42
00:01:54,385 --> 00:01:59,225
คำสั่ง Break และ Continue ถูกนำมาใช้ในการควบคุมทิศทางการไหลเช่นกัน

43
00:01:59,225 --> 00:02:01,480
บางทีเราเจอชุดคำสั่งที่เขียนได้แย่มาก

44
00:02:01,480 --> 00:02:03,850
แต่มันก็ถูกใช้งานและใช้งานได้

45
00:02:03,850 --> 00:02:07,415
เราจะใช้ Break และ Continue สำหรับลูป

46
00:02:07,415 --> 00:02:10,860
การใช้ Break คือการออกจากลูป

47
00:02:10,860 --> 00:02:13,965
ยกตัวอย่างเมื่อคุณอยู่ในลูป

48
00:02:13,965 --> 00:02:17,750
ในกรณีนี้ เราจะได้การทำงานทั้งหมดแค่ 4 ลูป โดยค่า i เริ่มต้นเท่ากับ 0

49
00:02:17,750 --> 00:02:20,310
เมื่อค่า i น้อยกว่า 10 ให้วนลูป และ i เพิ่มขึ้นทีละ 1

50
00:02:20,310 --> 00:02:22,340
ซึ่งนี่คือสิ่งที่จะเกิดขึ้นนี้

51
00:02:22,340 --> 00:02:24,790
เราจะสามารถจินตนาการตามได้ว่าควรจะเกิดขึ้นซ้ำ ๆ 10 ครั้ง

52
00:02:24,790 --> 00:02:26,220
แต่สังเกตุภายในลูป

53
00:02:26,220 --> 00:02:27,980
ได้กล่าวถึง X ไว้ว่า ถ้า

54
00:02:27,980 --> 00:02:30,385
X เท่ากับ 5 ให้หยุด

55
00:02:30,385 --> 00:02:32,670
และเมื่อใดก็ตาม ถ้ามันเข้าเงื่อนไขการหยุด

56
00:02:32,670 --> 00:02:33,980
ซึ่งในกรณี ใช่ คือมันหยุด

57
00:02:33,980 --> 00:02:37,660
เมื่อมันหยุด มันจะออกจากลูปไปเลยทันที

58
00:02:37,660 --> 00:02:40,760
ซึ่งเจ้าลูปนี้ทำงานเมื่อ i เท่ากับ 0

59
00:02:40,760 --> 00:02:42,620
1, 2, 3, 4 และ 5 เท่านั้น

60
00:02:42,620 --> 00:02:45,610
มันวนเข้าไปในลูป และหยุดในลูปรอบที่ 5 ในขณะที่กำลังอยู่ในลูป

61
00:02:45,610 --> 00:02:47,095
มันจะทำงานไม่ครบลูป

62
00:02:47,095 --> 00:02:50,915
ดังนั้น คำสั่ง break มันจะกระโดดออกมาจากลูปทันทีโดยไม่สนใจคำสั่งที่เหลือ

63
00:02:50,915 --> 00:02:53,160
คราวนี้เรามาดูในอีกด้านนึงกันบ้าง

64
00:02:53,160 --> 00:02:54,850
มันใช้คำสั่งวนลูปเหมือนกัน

65
00:02:54,850 --> 00:02:56,560
แต่มันไม่ได้ออกจากลูป

66
00:02:56,560 --> 00:02:59,560
มันแค่ข้ามการทำงานของลูปในรอบนั้น ๆ ไป

67
00:02:59,560 --> 00:03:01,600
เรามาดูตัวอย่างการใช้งานคำสั่ง continue กัน

68
00:03:01,600 --> 00:03:05,015
ชุดคำสั่งเดิม แต่เปลี่ยนจากการใช้ break มาเป็นใช้ continue แทน

69
00:03:05,015 --> 00:03:07,590
ถ้า i มีค่าเท่า 5 ให้เรียกใช้คำสั่ง continue

70
00:03:07,590 --> 00:03:08,960
สำหรับในกรณีนี้

71
00:03:08,960 --> 00:03:11,415
ถ้าไม่มีคำสั่ง if และ continue

72
00:03:11,415 --> 00:03:13,490
มันจะวนลูปจนครบ 10 ครั้ง

73
00:03:13,490 --> 00:03:15,000
เพราะค่า i เริ่มต้นจาก 0

74
00:03:15,000 --> 00:03:18,030
และเพิ่มขึ้นเรื่อย ๆ ตามเงื่อนไข ตราบเท่าที่ i ยังน้อยกว่า 10

75
00:03:18,030 --> 00:03:19,650
ซึ่งมันจะเป็นการวนลูป 10 ครั้งนั่นเอง

76
00:03:19,650 --> 00:03:21,400
แต่สำหรับลูปนี้

77
00:03:21,400 --> 00:03:24,050
มันกล่าวว่า ถ้า i มีค่าเท่ากับ 5 ให้เรียกคำสั่ง continue

78
00:03:24,050 --> 00:03:26,520
ซึ่งในลูปรอบนั้น i มีค่าเท่ากับ 5 จริง

79
00:03:26,520 --> 00:03:31,940
มันจะกระโดดข้ามโค๊ดส่วนที่เหลือและจบรอบลูปรอบนั้นไปเลย

80
00:03:31,940 --> 00:03:36,490
ซึ่งเอาล่ะ ถึงแม้ว่าลูปจะทำงาน

81
00:03:36,490 --> 00:03:38,600
แต่มันไม่ได้ทำงานเท่าจำนวนที่เราต้องการ

82
00:03:38,600 --> 00:03:41,040
เพราะลูปมันจะข้ามไป 1 รอบ

83
00:03:41,740 --> 00:03:47,750
มาที่คำสั่ง scan เป็นคำสั่งที่อ่านการป้อนค่าจากผู้ใช้งาน

84
00:03:47,750 --> 00:03:49,070
ซึ่งมันไม่ใช้คำสั่งในการควบคุมทิศทางการไหลของโปรแกรมหรอกนะ

85
00:03:49,070 --> 00:03:50,460
แต่เราจำเป็นต้องใช้มัน เพราะว่า

86
00:03:50,460 --> 00:03:52,020
เราต้องอ่านค่าบางอย่างจากผู้ใช้งาน

87
00:03:52,020 --> 00:03:54,075
เพื่อใช้ในโค๊ดตัวอย่างที่คุณเขียนขึ้นมา

88
00:03:54,075 --> 00:03:55,740
และทำอะไรบางอย่างง่าย ๆ กับมัน

89
00:03:55,740 --> 00:03:58,170
เช่นคุณต้องการอ่านค่าจากผู้ใช้งาน ผ่านการพิมพ์ด้วยคีย์บอร์ด

90
00:03:58,170 --> 00:04:01,214
ซึ่งมันไม่ใช่คำสั่งในการจัดรูปแบบ

91
00:04:01,214 --> 00:04:05,055
สิ่งทีคำสั่ง scan ทำ คือการรับค่า และส่งไปยังตัวแปรชนิด pointer

92
00:04:05,055 --> 00:04:11,235
ซึ่งสิ่งที่คุณทำ ก็คือให้ตัวแปรนี้ ชี้ไปยังค่าใด ๆ ก็ตามที่ผู้ใช้จะป้อนเข้ามา

93
00:04:11,235 --> 00:04:13,050
เช่น ถ้าผู้ใช้กำลังจะป้อนเลขจำนวนเต็มเข้ามา

94
00:04:13,050 --> 00:04:17,115
คุณก็จะได้รับค่าเลขจำนวนเต็มนั้น ที่ถูกชี้โดย pointer ซึ่งส่งให้กังฟังก์ชั่น scan

95
00:04:17,115 --> 00:04:21,995
เมื่อคุณเรียกใช้คำสั่ง scan มันจะไปเรียกใช้ฟังก์ชั่น ซึ่งจะทำให้โปรแกรมหยุด

96
00:04:21,995 --> 00:04:25,810
และรอจนกระทั่งผู้ใช้พิมพ์บางอย่างเข้ามา แล้วกดปุ่ม Enter

97
00:04:25,810 --> 00:04:29,460
และเมื่อกดปุ่ม Enter ฟังก์ชั่น scan ก็จะเอาค่าอะไรก็ตามที่พิมพ์เข้ามา

98
00:04:29,460 --> 00:04:32,790
ส่งไปยัง pointer ที่กำลังชี้อยู่

99
00:04:32,790 --> 00:04:36,340
จากนั้นก็เอาค่าจากที่พิมพ์เข้ามาส่งต่อให้ ซึ่งในที่นี้คือค่าเลขจำนวนเต็ม

100
00:04:36,340 --> 00:04:38,730
ถ้าเรา pointer ชี้ไปที่ข้อมูลประเภทจำนวนเต็ม มันก็จะได้ค่าเป็นเลขจำนวนเต็ม

101
00:04:38,730 --> 00:04:40,070
เปลี่ยนเป็นข้อมูลประเภทจำนวนเต็ม แล้วชี้

102
00:04:40,070 --> 00:04:42,095
แล้วเอาค่าจำนวนเต็มนั้นไปใส่

103
00:04:42,095 --> 00:04:45,550
และค่าที่ได้ คือค่าของตัวเลข ที่ได้จากการใช้คำสั่ง scan

104
00:04:45,550 --> 00:04:46,970
โดยมันส่งข้อมูลออกมา 2 อย่าง

105
00:04:46,970 --> 00:04:49,640
อย่างแรกคือ จำนวนชิ้นของค่าที่พิมพ์เข้ามา

106
00:04:49,640 --> 00:04:53,520
ซึ่งถ้ามีการป้อนค่า space หรือที่ว่างเข้ามา มันก็จะส่งรายงานความผิดพลาด

107
00:04:53,520 --> 00:04:54,870
อย่างที่สองที่มันส่งออกมา คือ ข้อความแจ้งความผิดพลาด

108
00:04:54,870 --> 00:04:57,180
ถ้าหากมีความผิดพลาดใด ๆ มันจะส่งค่าออกมา ที่ไม่ใช่ nil

109
00:04:57,180 --> 00:04:59,560
แต่ถ้าไม่มีข้อผิดพลาด มันจะส่งค่า nil ออกมาแทน

110
00:04:59,560 --> 00:05:03,350
ถ้าในกรณีที่มันส่งค่า error หรือค่ารหัสความผิดพลาดออกมา เราต้องตรวจสอบ

111
00:05:03,350 --> 00:05:05,570
เราลองไปดูโค๊ดตัวอย่างกัน

112
00:05:05,570 --> 00:05:10,360
สมมุติว่า ถ้าเราสร้างตัวแปร ชื่อ appleNum เป็นชนิดเลขจำนวนเต็ม

113
00:05:10,360 --> 00:05:13,130
และเราต้องการแสดงค่าจำนวนผลแอปเปิ้ลอกมา

114
00:05:13,130 --> 00:05:16,160
คำถามที่จะถามผู้ใช้งานคือ มีแอปเปิ้ลจำนวนกี่ลูก

115
00:05:16,160 --> 00:05:19,150
ซึ่งเราคิดหวังว่าผู้ใช้จะป้อนค่าเลขจำนวนเต็มเข้ามา สมมุติว่าเป็น 5

116
00:05:19,150 --> 00:05:20,920
ในบรรทัดต่อมา

117
00:05:20,920 --> 00:05:22,610
มีการเรียกใช้ฟังก์ชั่น scan

118
00:05:22,610 --> 00:05:25,120
ซึ่งโปรแกรมจะหยุดรอ

119
00:05:25,120 --> 00:05:29,250
ค้างอยู่ตรงนั้นจนกว่าผู้ใช้จะป้อนบางอย่างเข้ามาและกดปุ่ม Enter

120
00:05:29,250 --> 00:05:31,475
ซึ่งเราสมมุติว่าป้อนเลข 5 เข้ามาและกดปุ่ม Enter

121
00:05:31,475 --> 00:05:36,305
ให้สังเกตุว่าค่าที่รับมาจากคำสั่ง scan จะถูกส่งต่อไปยังตัวแปร &appleNum

122
00:05:36,305 --> 00:05:39,110
ซึ่งหมายถึงที่อยู่ของตัวแปร appleNum

123
00:05:39,110 --> 00:05:43,800
ดังนั้น เมื่อป้อนค่า 5 เข้ามาและกด Enter

124
00:05:43,800 --> 00:05:45,790
ฟังก์ชั่น scan ก็จะไปเอาค่า 5 มาเก็บไว้

125
00:05:45,790 --> 00:05:47,555
และส่งต่อไปให้กับตัวแปร appleNum

126
00:05:47,555 --> 00:05:50,560
ส่วนบรรทัดถัดมา เราเรียกใช้คำสั่ง printf appleNum

127
00:05:50,560 --> 00:05:54,470
มันจะแสดงค่า 5 หรือค่าใด ๆ ก็ตามที่คีย์เข้ามา ออกมา