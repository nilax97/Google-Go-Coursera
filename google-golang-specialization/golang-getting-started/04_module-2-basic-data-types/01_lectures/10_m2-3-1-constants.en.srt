1
00:00:10,520 --> 00:00:14,030
So, let's talk a little bit about a constant.

2
00:00:14,030 --> 00:00:16,750
So, constant it's pretty obvious what the constant is.

3
00:00:16,750 --> 00:00:19,540
It is an expression whose value is known at compile time.

4
00:00:19,540 --> 00:00:21,690
Right. So, you know it and it never changes.

5
00:00:21,690 --> 00:00:24,620
So, you can just basically declare a variable to be

6
00:00:24,620 --> 00:00:28,345
a certain value and it holds that value for all the time,

7
00:00:28,345 --> 00:00:29,945
as long as the program is running.

8
00:00:29,945 --> 00:00:34,110
The type is inferred from the righthand side of the assignment.

9
00:00:34,110 --> 00:00:38,695
So, for instance, here we say const x equals 1.3.

10
00:00:38,695 --> 00:00:43,940
So, that's going to set x to the value 1.3 and the compiler looks at 1.3,

11
00:00:43,940 --> 00:00:47,520
sees that that's a floating point and so x becomes a floating point.

12
00:00:47,520 --> 00:00:50,000
So, it infers from the right hand side of the assignment

13
00:00:50,000 --> 00:00:54,200
what the type of the variable needs to be and it is held constant, can't be changed.

14
00:00:54,200 --> 00:00:56,160
You can assign many at once.

15
00:00:56,160 --> 00:01:00,180
So, constant we have y equals four, z equals hi.

16
00:01:00,180 --> 00:01:02,380
Alright. You can give a long list if you want to.

17
00:01:02,380 --> 00:01:04,215
So, that's what a constant is.

18
00:01:04,215 --> 00:01:08,765
Now, iota is a function used to generate constants.

19
00:01:08,765 --> 00:01:10,175
It's interesting.

20
00:01:10,175 --> 00:01:13,500
So, it generates a set of related but distinct constants.

21
00:01:13,500 --> 00:01:15,080
So, when do you use this?

22
00:01:15,080 --> 00:01:17,945
You use this when you have to represent

23
00:01:17,945 --> 00:01:23,020
some property or some property that has several different distinct possible value.

24
00:01:23,020 --> 00:01:24,870
So, this is also known as one-hot.

25
00:01:24,870 --> 00:01:28,265
So, basically if you have a variable and you know it's going to be one-hot coded.

26
00:01:28,265 --> 00:01:31,950
Right. This variable can have one to five values let's say.

27
00:01:31,950 --> 00:01:36,920
So, you want each one of these five values to be a distinct constant.

28
00:01:36,920 --> 00:01:38,830
Right. Now, in a situation like this,

29
00:01:38,830 --> 00:01:41,320
just examples of such things, days of the week.

30
00:01:41,320 --> 00:01:44,910
Right. You got seven days of the week and you want each day of the week.

31
00:01:44,910 --> 00:01:48,495
If you want to define a constant for each day of the week, Monday, Tuesday, Wednesday,

32
00:01:48,495 --> 00:01:50,855
you want them all to be constants which are different

33
00:01:50,855 --> 00:01:53,030
but which are different and you don't

34
00:01:53,030 --> 00:01:55,275
particularly care what the value of the constant is,

35
00:01:55,275 --> 00:01:58,620
as long as Monday is different from Tuesday which is different from Wednesday.

36
00:01:58,620 --> 00:02:00,330
Months of the year same thing.

37
00:02:00,330 --> 00:02:03,620
Right. So, key thing about these constants is,

38
00:02:03,620 --> 00:02:06,080
when you use iota to generate these constants,

39
00:02:06,080 --> 00:02:08,570
the constants need to be different but

40
00:02:08,570 --> 00:02:11,065
the actual value of the constants is not important.

41
00:02:11,065 --> 00:02:15,650
So, if I have Monday, Tuesday Wednesday as my constants,

42
00:02:15,650 --> 00:02:20,205
I don't care if Monday is 500 or 5,000 or two or something.

43
00:02:20,205 --> 00:02:22,450
As long as Monday is not the same as Tuesday,

44
00:02:22,450 --> 00:02:23,995
which is not the same as Wednesday.

45
00:02:23,995 --> 00:02:26,730
Right. So, that's the case where you can use iota.

46
00:02:26,730 --> 00:02:28,190
If that's the case, you need to represent

47
00:02:28,190 --> 00:02:31,004
some set of constants with all different values,

48
00:02:31,004 --> 00:02:33,380
you don't care exactly what the value is but as long as they

49
00:02:33,380 --> 00:02:36,310
are distinct constants then you can use iota.

50
00:02:36,310 --> 00:02:38,240
This is essentially just like

51
00:02:38,240 --> 00:02:41,430
an enumerated type in other languages like C or something like that.

52
00:02:41,430 --> 00:02:42,470
It's the same idea.

53
00:02:42,470 --> 00:02:46,760
So, they give you a nice little shorthand for defining these set of constants.

54
00:02:46,760 --> 00:02:50,440
So, here's a little example of how you might define something using iota.

55
00:02:50,440 --> 00:02:52,530
Say I wanted to find some grades.

56
00:02:52,530 --> 00:02:55,015
So, I make a type called grades. I make it an int.

57
00:02:55,015 --> 00:02:57,950
I want to represent my grades as integers.

58
00:02:57,950 --> 00:03:01,100
I want to have these five grades A, B, C,

59
00:03:01,100 --> 00:03:03,900
D and F. I know that I want A,

60
00:03:03,900 --> 00:03:06,185
B, C, D and F to be all different grades.

61
00:03:06,185 --> 00:03:08,700
Right. So, they should be represented by different integers.

62
00:03:08,700 --> 00:03:11,430
But, I don't particularly care what integers they are represented by.

63
00:03:11,430 --> 00:03:15,470
I just want A to be something different than B and C and D and F. So,

64
00:03:15,470 --> 00:03:17,640
I declare the constants A, B, C,

65
00:03:17,640 --> 00:03:19,495
D and F. The first one,

66
00:03:19,495 --> 00:03:21,935
I say A give the type grades.

67
00:03:21,935 --> 00:03:24,745
Right. Which is actually an int, alias for int.

68
00:03:24,745 --> 00:03:26,925
A grades equal iota.

69
00:03:26,925 --> 00:03:29,185
I say that in the first constant definition.

70
00:03:29,185 --> 00:03:31,145
Then for B, C, D and F,

71
00:03:31,145 --> 00:03:32,445
I don't have to repeat that.

72
00:03:32,445 --> 00:03:34,240
Right. You can see I just say B, C,

73
00:03:34,240 --> 00:03:35,480
D and F. I don't give the type,

74
00:03:35,480 --> 00:03:37,265
I don't say iota, none of that.

75
00:03:37,265 --> 00:03:41,300
They just do it on the top and what will happen is automatically iota

76
00:03:41,300 --> 00:03:43,370
will assign a value to the first

77
00:03:43,370 --> 00:03:45,680
constant and then it will assign a different one to the next one,

78
00:03:45,680 --> 00:03:47,395
a different one to the next and so on.

79
00:03:47,395 --> 00:03:50,340
Actually, what it does what the implementation does is that,

80
00:03:50,340 --> 00:03:51,750
it assign it starts at one.

81
00:03:51,750 --> 00:03:54,110
So, A would be one, B would be two, C will be three,

82
00:03:54,110 --> 00:03:56,990
but you should not depend on that. Right. That's not.

83
00:03:56,990 --> 00:03:59,745
So, you don't know the idea behind using iota is it,

84
00:03:59,745 --> 00:04:02,850
you don't care what the actual values of the constants are.

85
00:04:02,850 --> 00:04:05,590
You just want the constant values to be different from one another.

86
00:04:05,590 --> 00:04:09,170
So, it happens that the current implementation starts off at one in increments,

87
00:04:09,170 --> 00:04:11,760
but you can't guarantee that in the future maybe that's going to be changed.

88
00:04:11,760 --> 00:04:15,630
Right. Just all you know that iota is that they're going to be different.