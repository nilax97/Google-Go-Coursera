Module two, functions and organization. Topic 2.1 variadic and deferred. So, we've been talking about functions generally, we're going to talk about a few more variations on functions about how you can pass the arguments and how you can get them to execute different times. One useful tool is to be able to pass a variable number of arguments to the function. So, normally when you define a function, you have to hard code the arguments that it takes. So, if it takes three arguments, you list them, comma-separated inside parentheses. But sometimes you want to make a function that takes a variable number of arguments. So, there are a lot of functions like this, maybe you want to take a number of integers and you don't know how many integers. If you take two, you take 10, you can still work with them and do the same thing with the whole set of integers regardless of how many is taken. So, in that case, you'd like to be able to pass it a variable number of arguments, you can do that using this ellipsis character, not character really but ellipsis it's just three dots. Three period dots in a row and you put that there inside the argument list to specify that you want to have a variable number of arguments. Inside the function when you get this argument it looks like a slice. So, if we look at the function there, it's called getMax and its supposed to get the maximum integer out of a set of integers that you pass it as an argument. So, if you pass it two integers to 10 integers or whatever it is, it should go through all those integers, find the greatest one and return that. So, we want to be able to take a variable number of arguments, so you can see highlighted in red. I say, vals...int. So, it takes an integer but that "..." before integer, means it can take as many integers as you want to take. So, then inside the function, this vals argument is treated like a slice of integers. So, the function just basically you can see what it does it, just goes through this whole, you can see the for loop. It goes through the range of vals so it just iterate through all the integers inside vals, finds the biggest one, sets max v to whichever one is the biggest. Then in the end it returns max v. So, this is just a useful tool you can take a variable number of arguments just use this ellipsis is... inside the argument list and you can treat the parameter just like a slice. Now, another variation on that is let's say you got one of these variadic functions, it takes a variable number of arguments, you can pass it a comma-separated list of arguments. So, say for my getMax, I want to pass it five integers. I could pass it one comma, two comma, three comma, four comma, five, as many as I want. Which is what I do actually in this example right here, you can see getMax, one, three, six , four. I can make that list as long as I want. But another way to pass a variable number of arguments is to just pass it a slice. So, that one, three, six, four, that could already be pre-packaged in a slice and then you could pass the slice to this getMax function. So, that's what I'm doing below, vslice myslice is equal to slice of one, three, six, four. Then I pass that in the last line where I do the print line, I call getMax and I pass it vslice which is my slice. Then notice when I do that, that right after the word vslice, I have the ellipses again. So "..." you have to put that there so that it knows it instead of passing a comma separated sequence of arguments, this vslice is meant to be a slice of all the arguments put together. But once you do that, you can just pass the entire slice to the function and it works fine. So, another thing that is sometimes useful with functions is to have a deferred function call. Deferred functions mean that they don't get executed right where they're called, they get executed later. So, when the surrounding function completes, they get executed. So, typically use this for cleanup activities so, say you're doing something opening files or doing whatever you're doing, maybe you'll have a deferred function which closes all the files at the end or something like that. So, this function doesn't actually get called until the surrounding function is done and say you're done with all the files that you're interested in, then it gets called as you're exiting and closes all the files. So, it does some kinda clean up activity, so this is a common thing to use it for, for this type of cleanups afterwards. So, as an example we've got our main function right here. First thing we do, all you do to do the differ, is just put the keyword differ in front of the function call. So, here we got differ print line. So, defer fmt print line bye. Now and then the next line is just fmt println Hello. Now if they were executed in the order that they're written, you'd print bye and then hello. But of course since we deferred it, what will happen is hello will get executed first. Then defer will not be executed until the main function, the surrounding function actually completes. So, what will actually get printed is hello and then bye. So, one thing to remember about these deferred function calls, is that the arguments are not evaluated in a deferred way. The arguments are evaluated immediately but the call is deferred. So, what does that mean? Sometimes it doesn't mean anything. If you just pass the function some kind of a fixed argument that can't change that doesn't meet evaluation, that doesn't mean anything. But if you pass it an argument that needs to be evaluated, you have to note that argument is evaluated right there where the first statement is. Not later when the call actually happens. So, as to show this, you got a main. This main, you can see in there there's a defer print line and then there's the fmt.println at the end. But there's also a variable called i, i set it equal to one. Now when I do the differ, I say print line i +1. Now at the point where that the first statement is, i =1, so i +1=2, so two should get printed. But then noticed that the line after that, I say, i++, then I'd say I print hello. Remember that differ will not be executed until later after the whole main is complete. So, by the time that differed print line executes, the value of i will actually be two. Because i starts off at one as one, it gets incremented plus plus and so it should be two by the time you actually execute that differed statement. Then if you would evaluate the argument at that time, you would say i+1, 2+1, three, a three would get printed. What actually gets printed as a two, because that i +1 is evaluated right there when the first statement, when it hits the differed statement, the i +1 is evaluated and at that time, i is a one, so i +1 is a two. So, later when the differed statement actually gets executed it's still prints a two. Thank you.