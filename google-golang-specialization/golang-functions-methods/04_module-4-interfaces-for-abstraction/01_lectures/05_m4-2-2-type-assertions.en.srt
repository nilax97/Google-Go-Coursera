1
00:00:00,120 --> 00:00:02,450
Module four, Interfaces for Abstraction.

2
00:00:02,450 --> 00:00:04,104
Topic 2.2, Type Assertions.

3
00:00:05,544 --> 00:00:11,350
So a lot of the point of an interface is
to conceal differences between types.

4
00:00:11,350 --> 00:00:14,551
So if you think about it, an interface can
hide the differences between two types.

5
00:00:14,551 --> 00:00:17,110
It basically highlights
the two similarities.

6
00:00:17,110 --> 00:00:21,810
So while in this fit and yard
implementation, there are rectangles and

7
00:00:21,810 --> 00:00:22,610
there are triangles.

8
00:00:22,610 --> 00:00:26,510
But from the inside fit in yard,
they're all treated the same, right?

9
00:00:26,510 --> 00:00:32,110
As long as they both satisfy Shape2D,
I can call s.Area, s.Perimeter, right?

10
00:00:32,110 --> 00:00:36,110
So what you're doing is, what interface
allow you to do is to treat different

11
00:00:36,110 --> 00:00:40,320
types that have some similarities,
some similar methods, treat them the same.

12
00:00:40,320 --> 00:00:43,800
All right, so you are hiding
differences by using interfaces.

13
00:00:43,800 --> 00:00:46,338
But sometimes you need to disambiguate,

14
00:00:46,338 --> 00:00:50,703
sometimes you need to treat different
types in different ways, okay?

15
00:00:50,703 --> 00:00:54,090
So sometimes, like in this function,
we don't, right?

16
00:00:54,090 --> 00:00:55,870
We can just say s.Area, s.Perimeter.

17
00:00:55,870 --> 00:00:58,330
We treat them exactly the same
because they have the same methods.

18
00:00:58,330 --> 00:01:01,720
But sometimes you do need to
differentiate based on the type.

19
00:01:01,720 --> 00:01:05,210
You need to be able to figure out
what is the concrete type, right?

20
00:01:05,210 --> 00:01:08,946
So in this example, s, since you're
just calling area and perimeter,

21
00:01:08,946 --> 00:01:12,211
it doesn't matter exactly what
the concrete type is, right?

22
00:01:12,211 --> 00:01:15,120
The concrete type could be rectangle,
it could be triangle.

23
00:01:15,120 --> 00:01:18,990
It doesn't matter, either way area and
perimeter do what you think.

24
00:01:18,990 --> 00:01:23,660
So in this case, the concrete type
that underlies the interface value,

25
00:01:23,660 --> 00:01:25,560
that doesn't matter, okay?

26
00:01:25,560 --> 00:01:28,980
But there are definitely cases
where the concrete type matters.

27
00:01:28,980 --> 00:01:31,590
In those cases, you're going to have
to expose those type differences.

28
00:01:31,590 --> 00:01:34,360
So you're going to have
to take this interface,

29
00:01:34,360 --> 00:01:39,410
which is hiding the differences between
the types, and peel it apart again,

30
00:01:39,410 --> 00:01:43,040
and say okay, actually, this is really
a rectangle, this is really a triangle.

31
00:01:43,040 --> 00:01:47,310
So situations like that might
be a graphics program, okay?

32
00:01:47,310 --> 00:01:49,460
So I got my graphics program
which I've used many times,

33
00:01:49,460 --> 00:01:54,640
but in my graphics program, this time I
want to write a function called DrawShape.

34
00:01:54,640 --> 00:01:56,580
And it should draw any shape.

35
00:01:56,580 --> 00:02:00,860
So I want to be able to pass it as
an argument any two dimensional shape.

36
00:02:00,860 --> 00:02:04,720
So I declare it sort of the top line I'm
showing right there, func DrawShape.

37
00:02:04,720 --> 00:02:08,390
It takes Shape2D,
that's the type of it's argument, Shape2D.

38
00:02:08,390 --> 00:02:11,430
So it can take any two
dimensional shape as an argument.

39
00:02:11,430 --> 00:02:12,370
So that's good, right?

40
00:02:12,370 --> 00:02:14,690
I've used my interface to generalize and

41
00:02:14,690 --> 00:02:18,280
to hide the differences between the types,
rectangle, triangle, circle,

42
00:02:18,280 --> 00:02:22,540
doesn't matter, for passing it as
an argument to draw shape anyway.

43
00:02:22,540 --> 00:02:27,190
Now, inside DrawShape, though, in this
case, I'm going to have to disambiguate.

44
00:02:27,190 --> 00:02:29,940
I'm going to have to determine this s,
is it a rectangle,

45
00:02:29,940 --> 00:02:31,670
is it a triangle, what is it?

46
00:02:31,670 --> 00:02:34,410
Because maybe in the underlying API

47
00:02:34,410 --> 00:02:37,620
there's some kind of drawing functions
that I'm using in this API, right?

48
00:02:37,620 --> 00:02:40,083
And the underlying drawing functions,

49
00:02:40,083 --> 00:02:43,712
they actually are specific to
the type of shaping drawing.

50
00:02:43,712 --> 00:02:47,609
So for instance, maybe the underlying
API gives me a draw rectangle,

51
00:02:47,609 --> 00:02:49,050
DrawRect, right?

52
00:02:49,050 --> 00:02:51,810
And then another draw triangle,
and a draw circle, and so

53
00:02:51,810 --> 00:02:54,820
on, which is not uncommon in
these drawing APIs, right?

54
00:02:54,820 --> 00:02:58,420
So you got draw rectangle,
draw triangle, draw circle, all those.

55
00:02:58,420 --> 00:03:02,926
Now, these API functions, my DrawShape
is going to have call these, right?

56
00:03:02,926 --> 00:03:05,747
When it wants to draw a rectangle,
it's going to have to call DrawRectangle.

57
00:03:05,747 --> 00:03:08,130
DrawTriangle to draw triangle.

58
00:03:08,130 --> 00:03:14,100
And these underlying API functions,
they don't take just any shape.

59
00:03:14,100 --> 00:03:15,910
They won't take Shape2D.

60
00:03:15,910 --> 00:03:17,520
DrawRect only takes rectangles.

61
00:03:17,520 --> 00:03:19,020
DrawTriangle only takes triangles.

62
00:03:19,020 --> 00:03:19,786
And so on.

63
00:03:19,786 --> 00:03:23,302
So this is the case where I
want to use my interface so

64
00:03:23,302 --> 00:03:28,098
my DrawShape can take any argument,
any type of reasonable shape.

65
00:03:28,098 --> 00:03:31,860
But inside my DrawShape,
I'm going to have to differentiate.

66
00:03:31,860 --> 00:03:34,870
I'm going to say, look,
if you're a rectangle, call DrawRect.

67
00:03:34,870 --> 00:03:37,470
If you're a triangle,
call DrawTriangle, and so on.

68
00:03:37,470 --> 00:03:41,120
So in this case, inside DrawShape,
I'm going to have to determine

69
00:03:41,120 --> 00:03:45,680
the concrete type that s is based on,
that the shape is based on.

70
00:03:47,230 --> 00:03:50,460
So for that,
I use what's called a type assertion.

71
00:03:50,460 --> 00:03:54,490
So type assertions can be used to
disambiguate between the different

72
00:03:54,490 --> 00:03:58,570
concrete types that actually
satisfy a particular interface.

73
00:03:58,570 --> 00:04:00,960
And you can see that here with DrawShape.

74
00:04:00,960 --> 00:04:02,157
It needs to actually disambiguate.

75
00:04:02,157 --> 00:04:06,790
So if it's a rectangle that's being
passed, it needs to call DrawRect.

76
00:04:06,790 --> 00:04:08,980
If it's a triangle,
it needs to call it DrawTraingle.

77
00:04:08,980 --> 00:04:10,790
So you can see us doing that here.

78
00:04:10,790 --> 00:04:17,170
At the top, you've got that first type
assertion, where it says rect, ok:=,

79
00:04:17,170 --> 00:04:22,680
so that will return a rectangle,
if the s is actually a rectangle.

80
00:04:22,680 --> 00:04:23,540
So if ok is true,

81
00:04:23,540 --> 00:04:27,100
and it found a rectangle,
it will call DrawRect with that rectangle.

82
00:04:27,100 --> 00:04:30,690
Otherwise, the next type assertion

83
00:04:30,690 --> 00:04:35,430
actually checks to see if the type
of the interface of s is a triangle.

84
00:04:35,430 --> 00:04:40,242
So it says, tri,
ok:= s.(Triangle) this time.

85
00:04:40,242 --> 00:04:45,690
And so, ok will be true if
s is actually a triangle.

86
00:04:45,690 --> 00:04:49,700
And in that case,
tri is going to equal that triangle.

87
00:04:49,700 --> 00:04:53,380
And so,
you call DrawTriangle with a triangle.

88
00:04:53,380 --> 00:04:57,513
So either way, we use this type
assertion to disambiguate,

89
00:04:57,513 --> 00:05:03,033
to determine the actual underlying
concrete type for this Shape2D interface.

90
00:05:04,809 --> 00:05:09,687
Now, another way to do this sort of
a common thing that you need to do is what

91
00:05:09,687 --> 00:05:14,191
we just did in the last slide,
we went down a list of possible types.

92
00:05:14,191 --> 00:05:16,250
So rectangle and triangle in this case.

93
00:05:16,250 --> 00:05:22,380
But note that an interface can actually
be satisfied by many different types.

94
00:05:22,380 --> 00:05:25,031
There's an interface that's
satisfied by 10 different types,

95
00:05:25,031 --> 00:05:26,850
you might need to disambiguate all 10.

96
00:05:26,850 --> 00:05:27,920
So to run down the list.

97
00:05:27,920 --> 00:05:29,090
If you're this type, then do this.

98
00:05:29,090 --> 00:05:31,260
If you're that type,
then do that, and so on.

99
00:05:31,260 --> 00:05:35,030
And so, there's a switch construct type
switch which is just for that purpose.

100
00:05:35,030 --> 00:05:39,510
So you got one case for every different
type that you need to deal with.

101
00:05:39,510 --> 00:05:43,290
So in this case, you got two cases,
case Rectangle, case Triangle.

102
00:05:43,290 --> 00:05:47,190
And in each case,
case Rectangle draws the rectangle,

103
00:05:47,190 --> 00:05:49,370
case Triangle draws the triangle.

104
00:05:49,370 --> 00:05:51,960
But right before that,
you start with the switch.

105
00:05:51,960 --> 00:05:56,990
So notice the type Type
assertion says s.type.

106
00:05:56,990 --> 00:06:00,950
In parentheses you just say type,
the generic word type.

107
00:06:00,950 --> 00:06:05,810
And so,
what happens is sh will be whatever the,

108
00:06:05,810 --> 00:06:09,430
it'll be the concrete
type that s represents.

109
00:06:09,430 --> 00:06:16,350
So if s is actually a rectangle,
then sh will be that rectangle, right?

110
00:06:16,350 --> 00:06:19,360
If s is a triangle,
then sh will be that triangle.

111
00:06:19,360 --> 00:06:20,570
And you'll hit the appropriate case.

112
00:06:20,570 --> 00:06:23,860
So if sh is a rectangle,
then you'll execute the case rectangle.

113
00:06:23,860 --> 00:06:27,600
If sh is a triangle,
then you'll execute the case triangle.

114
00:06:27,600 --> 00:06:30,760
So this is just a more convenient
way to sort of run down a list

115
00:06:30,760 --> 00:06:35,680
to disambiguate a whole set of types
that all satisfy a particular interface.

116
00:06:36,910 --> 00:06:37,410
Thank you.