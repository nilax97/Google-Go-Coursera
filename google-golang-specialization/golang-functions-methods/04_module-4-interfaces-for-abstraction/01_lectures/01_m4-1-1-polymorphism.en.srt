1
00:00:00,100 --> 00:00:04,120
Module 4, Interfaces for Abstraction,
Topic 1.1, Polymorphism.

2
00:00:06,180 --> 00:00:09,380
Polymorphism is a property

3
00:00:09,380 --> 00:00:12,770
very commonly associated with
object oriented programming.

4
00:00:12,770 --> 00:00:17,360
It's the ability for an object to have
different forms depending on the context.

5
00:00:17,360 --> 00:00:19,690
Okay, so what does that mean,
different forms?

6
00:00:19,690 --> 00:00:21,914
That could mean a lot of things, but

7
00:00:21,914 --> 00:00:26,973
what it typically means is you can have
a function or method with one name, area.

8
00:00:26,973 --> 00:00:31,360
And it does one thing for
one object and another thing for

9
00:00:31,360 --> 00:00:33,890
another type of object, okay?

10
00:00:33,890 --> 00:00:35,190
So for instance take area, okay?

11
00:00:35,190 --> 00:00:39,265
If you want to compute the area of
a rectangle, that's base times height.

12
00:00:39,265 --> 00:00:44,275
You're going to compute the area of
a triangle as one-half base times height.

13
00:00:44,275 --> 00:00:48,345
A function name is going to do two
different things depending on the context.

14
00:00:48,345 --> 00:00:50,575
If you're doing it with
respect to a rectangle or

15
00:00:50,575 --> 00:00:54,263
with respect to a triangle, so
that's what polymorphism is.

16
00:00:54,263 --> 00:00:57,525
So you would say area is
polymorphic because it

17
00:00:57,525 --> 00:00:59,969
can do two different things
depending on the context.

18
00:01:00,990 --> 00:01:05,680
So another way to think about it is
that these two area implementations,

19
00:01:05,680 --> 00:01:08,100
they are at a high level of abstraction.

20
00:01:08,100 --> 00:01:09,120
They're identical.

21
00:01:09,120 --> 00:01:11,490
What they do is they compute the area,
right?

22
00:01:11,490 --> 00:01:13,550
No matter what the object is,
if it's a rectangle or

23
00:01:13,550 --> 00:01:15,930
if it's a triangle,
the area is what's computed.

24
00:01:15,930 --> 00:01:20,410
So at a high level, forgetting the detail,
they do the same thing.

25
00:01:20,410 --> 00:01:25,480
At the low level and
how they actually compute the area and

26
00:01:25,480 --> 00:01:27,640
they are different, right?

27
00:01:27,640 --> 00:01:32,160
So really polymorphism is a way
of establishing an extraction.

28
00:01:32,160 --> 00:01:35,110
These things are the same at
the high level of extraction.

29
00:01:35,110 --> 00:01:37,600
But underneath they're different, right?

30
00:01:37,600 --> 00:01:38,980
So that's what we want to allow.

31
00:01:38,980 --> 00:01:41,140
It's useful for a lot of reasons.

32
00:01:41,140 --> 00:01:47,250
So we need Golang to have some
type of support for polymorphism.

33
00:01:47,250 --> 00:01:51,550
So what I'll first describe is how
polymorphism is usually implemented in

34
00:01:51,550 --> 00:01:55,460
traditional object oriented languages.

35
00:01:55,460 --> 00:02:00,840
So one thing that is usually used
in object oriented languages

36
00:02:00,840 --> 00:02:05,750
to support polymophism is inheritance,
and Golang does not have inheritance, and

37
00:02:05,750 --> 00:02:09,300
so I'll just say that again,
Golang does not have inheritance.

38
00:02:09,300 --> 00:02:13,990
Inheritance is where you get a series
of classes, and they have this class,

39
00:02:13,990 --> 00:02:17,310
subclass, superclass relationship,
or sometimes you call it parent and

40
00:02:17,310 --> 00:02:19,770
child class, parent class, child class.

41
00:02:19,770 --> 00:02:22,790
So the superclass is the top level class,
and

42
00:02:22,790 --> 00:02:26,880
the subclass extends from the superclass.

43
00:02:26,880 --> 00:02:30,846
And the subclass inherits the methods and
data of the superclass.

44
00:02:30,846 --> 00:02:35,442
So as an example,
maybe I've got a speaker superclass, and

45
00:02:35,442 --> 00:02:41,138
a speaker is supposed to represent
everything that can speak, all right?

46
00:02:41,138 --> 00:02:45,030
Anything that can make noises,
okay, you call that that a speaker.

47
00:02:45,030 --> 00:02:48,850
Now, underneath speaker,
a subclass of that might be cat and

48
00:02:48,850 --> 00:02:49,780
it might be dog right?

49
00:02:49,780 --> 00:02:50,680
because cats can speak.

50
00:02:50,680 --> 00:02:51,790
They can make noise.

51
00:02:51,790 --> 00:02:53,080
Dogs can make noise.

52
00:02:53,080 --> 00:02:56,200
So maybe I've got this subclass cat,
subclass dog.

53
00:02:56,200 --> 00:02:58,910
Both subclasses of this
superclass speaker.

54
00:02:58,910 --> 00:03:03,974
And cat and dog will both inherit
the properties of the superclass.

55
00:03:03,974 --> 00:03:08,120
So my superclass speaker,
let's say it has a method called speak.

56
00:03:08,120 --> 00:03:11,949
And that just prints out whatever
noise the creature makes.

57
00:03:11,949 --> 00:03:16,446
So speaker, since it's generic, and
the superclass, its speak method will

58
00:03:16,446 --> 00:03:20,940
just print out noise,
arbitrary noise because it's generic.

59
00:03:20,940 --> 00:03:24,794
But then the subclasses cat, dog,
they'll also have a speak method.

60
00:03:24,794 --> 00:03:27,600
They'll inherit it from
the speaker superclass.

61
00:03:27,600 --> 00:03:30,419
So they get the same properties,
they extend down.

62
00:03:31,700 --> 00:03:34,400
So cat and
dog are different forms of speaker.

63
00:03:34,400 --> 00:03:37,200
And this is where the polymorphism,
they're different forms of each other,

64
00:03:37,200 --> 00:03:41,070
this is where polymorphism
concepts come into play.

65
00:03:41,070 --> 00:03:43,615
And remember that Go
doesn't have inheritance.

66
00:03:43,615 --> 00:03:46,075
Now, inheritance is one thing that you use

67
00:03:46,075 --> 00:03:49,905
in a regular object oriented language
to support polymorphism, but you also,

68
00:03:49,905 --> 00:03:54,135
on top of that, you're going to
need another property, overriding.

69
00:03:54,135 --> 00:03:56,285
The ability to override a method.

70
00:03:56,285 --> 00:04:00,674
So a method is overridden,
a subclass overrides a method when it

71
00:04:00,674 --> 00:04:05,180
redefines a method that it
inherits from the superclass.

72
00:04:05,180 --> 00:04:08,680
So in the example we're talking about
here, you've got the superclass speaker.

73
00:04:08,680 --> 00:04:11,660
And under that you've got
the subclass cat and subclass dog.

74
00:04:11,660 --> 00:04:18,000
And speaker has this speak method and
cat and dog inherit the speak method too.

75
00:04:18,000 --> 00:04:21,860
But without overriding the speak method,
the cat speak method and the dog speak

76
00:04:21,860 --> 00:04:25,730
method do exactly what the superclass,
what the speaker's speak method does.

77
00:04:25,730 --> 00:04:27,620
They just print out noise, right?

78
00:04:27,620 --> 00:04:29,200
Which is arbitrary.

79
00:04:29,200 --> 00:04:33,810
So what you want is for the cat
speak method to print out meow, and

80
00:04:33,810 --> 00:04:36,210
the dog speaker method to print out woof.

81
00:04:36,210 --> 00:04:40,000
So what happens is,
that's called overriding.

82
00:04:40,000 --> 00:04:45,078
The cat subclass will redefine the speak
method to print out what it wants,

83
00:04:45,078 --> 00:04:46,136
meow, right?

84
00:04:46,136 --> 00:04:51,230
And then the dog subclass will redefine
it to print out what it wants, woof.

85
00:04:51,230 --> 00:04:55,963
So now the speaker class, the speaker
superclass, it has its speak method, and

86
00:04:55,963 --> 00:04:59,175
cat also the speak method,
dog also the speak method.

87
00:04:59,175 --> 00:05:03,986
But the cat speak and the dog speak
do two different things, okay?

88
00:05:03,986 --> 00:05:08,002
So cat and dog classes have overridden
the definition of the speak method with

89
00:05:08,002 --> 00:05:10,880
their own new definition
of the speak method.

90
00:05:10,880 --> 00:05:13,180
So now you can say speak is polymorphic.

91
00:05:13,180 --> 00:05:16,460
Because speak, it has two different
implementations for each class.

92
00:05:16,460 --> 00:05:20,370
So speak in the context of the cat,
it'll print meow.

93
00:05:20,370 --> 00:05:23,320
Context of the dog, it'll print woof.

94
00:05:23,320 --> 00:05:25,810
But the idea is to support
polymorphism which you

95
00:05:25,810 --> 00:05:29,940
normally see in object oriented language,
you see inheritance, and

96
00:05:29,940 --> 00:05:32,296
then you also see the ability
to override a method.

97
00:05:32,296 --> 00:05:36,320
So both the subclasses
inherit the speak method, but

98
00:05:36,320 --> 00:05:39,280
then they can override it and
define it the way they want.

99
00:05:39,280 --> 00:05:43,670
And one thing to note is that
they actually use the same,

100
00:05:43,670 --> 00:05:47,510
even though they're overriding the method,
they use the same signature.

101
00:05:47,510 --> 00:05:50,450
So this function signature is,
the method signature is the same.

102
00:05:50,450 --> 00:05:54,689
So this method speak,
it has the same name, in both cat and

103
00:05:54,689 --> 00:05:58,999
dog class, it has the same arguments and
the same return types.

104
00:05:58,999 --> 00:06:02,357
So the signature will stay the same and
you'd call it polymorphic in that case.

105
00:06:02,357 --> 00:06:02,857
Thank you.