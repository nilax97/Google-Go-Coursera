1
00:00:00,000 --> 00:00:01,997
Module 3: Object-Orientation in Go.

2
00:00:01,997 --> 00:00:04,039
Topic 1.2: Support for Classes.

3
00:00:06,302 --> 00:00:09,787
So there's no Class keyword in Go.

4
00:00:09,787 --> 00:00:12,616
So Go doesn't officially have
anything called classes,

5
00:00:12,616 --> 00:00:16,439
although it has something that's just
like them but it doesn't have a class.

6
00:00:16,439 --> 00:00:18,445
So other object throwing to language or

7
00:00:18,445 --> 00:00:21,012
object to language this
have this class keyword.

8
00:00:21,012 --> 00:00:24,983
And then the data field and the methods
that are associated with the class,

9
00:00:24,983 --> 00:00:28,653
they are defined inside that
the blocks defined by the class, okay?

10
00:00:28,653 --> 00:00:31,276
So the code that I'm
showing here is not Go.

11
00:00:31,276 --> 00:00:34,966
The code is Python, yeah,
the Python that I wrote and

12
00:00:34,966 --> 00:00:39,240
this is to make a point class in
python this is just an example.

13
00:00:39,240 --> 00:00:42,029
So in this case,
you can say class point and

14
00:00:42,029 --> 00:00:46,380
then everything in that block is
associated with the Point class.

15
00:00:46,380 --> 00:00:50,155
Now, I'm defining a function called
init which is its constructor.

16
00:00:50,155 --> 00:00:55,077
And you'll notice inside there,
it defines self.x=, self.y=.

17
00:00:55,077 --> 00:00:59,355
So self.x, self.y, those are the data
that are associated with the point, and

18
00:00:59,355 --> 00:01:02,084
we're assigning them
a initialization function.

19
00:01:02,084 --> 00:01:04,278
So it's assigning to values x and
y values.

20
00:01:04,278 --> 00:01:08,818
But this is normally how it's done
in other object oriented languages.

21
00:01:08,818 --> 00:01:13,533
Go does not do it in the same way,
it doesn't have a class keyword like this,

22
00:01:13,533 --> 00:01:15,610
but you can get a similar effect.

23
00:01:15,610 --> 00:01:21,995
Okay, so in Go, they have a different
way of associating methods with data.

24
00:01:21,995 --> 00:01:25,959
So remember, that's what a class really
is, a class is a bunch of data associated

25
00:01:25,959 --> 00:01:28,324
with a bunch of methods
that operate on the data.

26
00:01:28,324 --> 00:01:32,202
And together, the methods and data make
what you would consider to be a class.

27
00:01:32,202 --> 00:01:37,439
So you need to have a way to associate
a method [COUGH] with some data.

28
00:01:37,439 --> 00:01:41,718
And the way that's done inside
Go is using a receiver type, so

29
00:01:41,718 --> 00:01:46,575
when you define the function you give
it whatâ€™s called a receiver type

30
00:01:46,575 --> 00:01:50,060
which is the type that
method is associated with.

31
00:01:50,060 --> 00:01:52,580
So the data is going to be some type.

32
00:01:52,580 --> 00:01:56,915
And the method, the way you associate the
method with that data is when you define

33
00:01:56,915 --> 00:01:59,232
that function you give it a receiver type.

34
00:01:59,232 --> 00:02:03,121
And that receiver type is the type
that that method is associated with.

35
00:02:03,121 --> 00:02:08,358
And then when you want to call a method
you use standard dot notation to call it.

36
00:02:08,358 --> 00:02:10,205
So let's show an example.

37
00:02:10,205 --> 00:02:14,597
So let's say I make up a new type
called MyInt, and it's just an int.

38
00:02:14,597 --> 00:02:16,129
Okay, so type MyInt int.

39
00:02:16,129 --> 00:02:20,262
But it's MyInt, so
I can make up methods for this type.

40
00:02:20,262 --> 00:02:24,581
By the way, I can't add associated
methods with existing types.

41
00:02:24,581 --> 00:02:28,873
As a rule, whenever you associate
a method with a type like this,

42
00:02:28,873 --> 00:02:32,708
using a receiver ,type
associated with a receiver type.

43
00:02:32,708 --> 00:02:35,971
You gotta make sure that the type
is defined in the same package

44
00:02:35,971 --> 00:02:40,440
as the method that you're associating with
it, they have to be in the same package.

45
00:02:40,440 --> 00:02:44,415
And so you can't do that with a built in
type like int or string o something like

46
00:02:44,415 --> 00:02:47,903
that, you can't just add methods
onto that because they're not,

47
00:02:47,903 --> 00:02:51,661
they're built in they're not defined
in the same package as your code.

48
00:02:51,661 --> 00:02:56,617
So I make my int, now, I make a function,
this function, double.

49
00:02:56,617 --> 00:02:59,950
And I want to associate
double with the MyInt type.

50
00:02:59,950 --> 00:03:03,478
So Double is going to be something
that's going to double an integer and

51
00:03:03,478 --> 00:03:04,617
only works on MyInt.

52
00:03:04,617 --> 00:03:06,365
So when I define the function,

53
00:03:06,365 --> 00:03:10,342
notice it's slightly different
than a normal function definition.

54
00:03:10,342 --> 00:03:14,845
Before the name of the function Double,
to the left of that, highlighted in red,

55
00:03:14,845 --> 00:03:16,749
I have the receiver type defined.

56
00:03:16,749 --> 00:03:22,336
So MyInt is the receiver type and
mi is the variable that refers to

57
00:03:22,336 --> 00:03:29,172
the particular receiver object that this
Double is going to be called on, okay?

58
00:03:29,172 --> 00:03:34,479
Because remember when I call Double, when
I invoke double, I'm going to have to say,

59
00:03:34,479 --> 00:03:38,460
say I have, actually let's look
at the invocation down here.

60
00:03:38,460 --> 00:03:44,415
Actually, if you look at the bottom, func
main, I declare a MyInt v, v := MyInt(3).

61
00:03:44,415 --> 00:03:46,007
So I make it, and that's what v is.

62
00:03:46,007 --> 00:03:51,231
Then when I call, you see highlighted in
red, when I called double, I say v.Double.

63
00:03:51,231 --> 00:03:54,985
And so what happens is, when it's
trying to figure out this double,

64
00:03:54,985 --> 00:03:57,651
it looks back at the things
to the left of the dot.

65
00:03:57,651 --> 00:04:00,745
The object to the left of the dot
looks at what type it is and it knows,

66
00:04:00,745 --> 00:04:04,269
that's the Double that I want, the Double
that's associated with that type.

67
00:04:04,269 --> 00:04:09,149
So that's what the dot notation is for,
basically the object to the left

68
00:04:09,149 --> 00:04:12,589
of the dot tells you what
type you're looking for,

69
00:04:12,589 --> 00:04:16,681
because double could be defined
in lots of different types.

70
00:04:16,681 --> 00:04:20,606
But I'm specifically looking for
Double for v's type which is a MyInt.

71
00:04:20,606 --> 00:04:26,180
So anyway, back to the definition
of the Double function from MyInt,

72
00:04:26,180 --> 00:04:27,792
the double method.

73
00:04:27,792 --> 00:04:32,936
I have to associate it with the MyInt type
by putting the (mi MyInt) in parenthesis,

74
00:04:32,936 --> 00:04:36,580
the highlighted red part,
before the name of the function,

75
00:04:36,580 --> 00:04:40,237
when I defined the function,
when I declared the function.

76
00:04:40,237 --> 00:04:44,308
So and then what happens is
inside the definition, so

77
00:04:44,308 --> 00:04:48,655
if we look inside double
it just returns int (mi*2).

78
00:04:48,655 --> 00:04:54,043
Now, notice that it takes mi, now it
refers to mi, because basically what's

79
00:04:54,043 --> 00:04:59,284
happening is that mi that object to the
left of the dot when you make the call.

80
00:04:59,284 --> 00:05:03,382
That object ends up being an argument and
implicit argument to double.

81
00:05:03,382 --> 00:05:05,019
We'll talk about that in a second.

82
00:05:05,019 --> 00:05:08,008
So this function just takes
mi whatever integer it is and

83
00:05:08,008 --> 00:05:12,092
multiplies it times 2 turns it into
an integer and returns it as an integer.

84
00:05:12,092 --> 00:05:16,172
All right, so then in the main
I can just call v.Double and

85
00:05:16,172 --> 00:05:21,101
it call the Double that is associated
with the type of v which is MyInt.

86
00:05:21,101 --> 00:05:25,638
So, what I'm showing here is just that
this type MyInt is the receiver type for

87
00:05:25,638 --> 00:05:28,265
this function Double, that I have defined.

88
00:05:28,265 --> 00:05:32,835
So whenever I call Double, I have to
prefix it using this dot notation,

89
00:05:32,835 --> 00:05:37,878
I prefix it with an object of that type,
of the MyInt type, so v.Double().

90
00:05:37,878 --> 00:05:41,575
So that the machine knows, okay,
this is the Double that I want,

91
00:05:41,575 --> 00:05:45,355
the one that's associated where
this MyInt is the receiver type.

92
00:05:45,355 --> 00:05:46,992
Implicit Method Argument.

93
00:05:46,992 --> 00:05:48,499
So what I'm saying here,

94
00:05:48,499 --> 00:05:52,472
is that even though it looks like
Double takes no arguments, right?

95
00:05:52,472 --> 00:05:54,492
If I look at the definition of Double,
there's no arguments there.

96
00:05:54,492 --> 00:05:57,036
But there is an implicit argument.

97
00:05:57,036 --> 00:05:59,934
Whenever you have a receiver type,
whenever there's a method,

98
00:05:59,934 --> 00:06:00,995
it has a receiver type.

99
00:06:00,995 --> 00:06:04,396
The object of that receiver type,
that it is to the left of the dot.

100
00:06:04,396 --> 00:06:07,857
That is an implicit argument to
the function, to the method rather.

101
00:06:07,857 --> 00:06:11,909
So even though double looks like it has
no argument, it really has one argument.

102
00:06:11,909 --> 00:06:12,954
Okay, a hidden argument.

103
00:06:12,954 --> 00:06:14,626
You do not pass it explicitly.

104
00:06:14,626 --> 00:06:18,909
So when I call Double I say (v.Double())
in parentheses I have nothing, right?

105
00:06:18,909 --> 00:06:22,763
But that v is going to be
passed to the Double function

106
00:06:22,763 --> 00:06:25,226
when you actually make the call.

107
00:06:25,226 --> 00:06:29,928
So that's passed automatically invisibly,
the programmer doesn't have to see it.

108
00:06:29,928 --> 00:06:33,710
But it's important that you as
a programmer are aware that it is actually

109
00:06:33,710 --> 00:06:34,522
being passed.

110
00:06:34,522 --> 00:06:37,437
Reason why is because it's
passed call by value.

111
00:06:37,437 --> 00:06:41,457
So this is how passing, argument passing
is done and go is call by value.

112
00:06:41,457 --> 00:06:43,477
So what happens is when that v,

113
00:06:43,477 --> 00:06:47,986
that object to the left of that dot
gets passed to Double implicitly,

114
00:06:47,986 --> 00:06:52,049
it is passed by value,
a copy of v is made and passed to Double.

115
00:06:52,049 --> 00:06:54,638
So this impacts what Double can do.

116
00:06:54,638 --> 00:06:55,988
So it's important to realize,

117
00:06:55,988 --> 00:06:59,238
if v is actually being passed, the object
to the left of the dot is being passed

118
00:06:59,238 --> 00:07:02,252
as an argument even if though it
doesn't look like it in an obvious way.

119
00:07:02,252 --> 00:07:02,752
Thank you.