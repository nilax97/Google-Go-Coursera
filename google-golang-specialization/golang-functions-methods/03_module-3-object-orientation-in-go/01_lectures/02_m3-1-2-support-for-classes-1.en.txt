Module 3: Object-Orientation in Go. Topic 1.2: Support for Classes. So there's no Class keyword in Go. So Go doesn't officially have
anything called classes, although it has something that's just
like them but it doesn't have a class. So other object throwing to language or object to language this
have this class keyword. And then the data field and the methods
that are associated with the class, they are defined inside that
the blocks defined by the class, okay? So the code that I'm
showing here is not Go. The code is Python, yeah,
the Python that I wrote and this is to make a point class in
python this is just an example. So in this case,
you can say class point and then everything in that block is
associated with the Point class. Now, I'm defining a function called
init which is its constructor. And you'll notice inside there,
it defines self.x=, self.y=. So self.x, self.y, those are the data
that are associated with the point, and we're assigning them
a initialization function. So it's assigning to values x and
y values. But this is normally how it's done
in other object oriented languages. Go does not do it in the same way,
it doesn't have a class keyword like this, but you can get a similar effect. Okay, so in Go, they have a different
way of associating methods with data. So remember, that's what a class really
is, a class is a bunch of data associated with a bunch of methods
that operate on the data. And together, the methods and data make
what you would consider to be a class. So you need to have a way to associate
a method [COUGH] with some data. And the way that's done inside
Go is using a receiver type, so when you define the function you give
it whatâ€™s called a receiver type which is the type that
method is associated with. So the data is going to be some type. And the method, the way you associate the
method with that data is when you define that function you give it a receiver type. And that receiver type is the type
that that method is associated with. And then when you want to call a method
you use standard dot notation to call it. So let's show an example. So let's say I make up a new type
called MyInt, and it's just an int. Okay, so type MyInt int. But it's MyInt, so
I can make up methods for this type. By the way, I can't add associated
methods with existing types. As a rule, whenever you associate
a method with a type like this, using a receiver ,type
associated with a receiver type. You gotta make sure that the type
is defined in the same package as the method that you're associating with
it, they have to be in the same package. And so you can't do that with a built in
type like int or string o something like that, you can't just add methods
onto that because they're not, they're built in they're not defined
in the same package as your code. So I make my int, now, I make a function,
this function, double. And I want to associate
double with the MyInt type. So Double is going to be something
that's going to double an integer and only works on MyInt. So when I define the function, notice it's slightly different
than a normal function definition. Before the name of the function Double,
to the left of that, highlighted in red, I have the receiver type defined. So MyInt is the receiver type and
mi is the variable that refers to the particular receiver object that this
Double is going to be called on, okay? Because remember when I call Double, when
I invoke double, I'm going to have to say, say I have, actually let's look
at the invocation down here. Actually, if you look at the bottom, func
main, I declare a MyInt v, v := MyInt(3). So I make it, and that's what v is. Then when I call, you see highlighted in
red, when I called double, I say v.Double. And so what happens is, when it's
trying to figure out this double, it looks back at the things
to the left of the dot. The object to the left of the dot
looks at what type it is and it knows, that's the Double that I want, the Double
that's associated with that type. So that's what the dot notation is for,
basically the object to the left of the dot tells you what
type you're looking for, because double could be defined
in lots of different types. But I'm specifically looking for
Double for v's type which is a MyInt. So anyway, back to the definition
of the Double function from MyInt, the double method. I have to associate it with the MyInt type
by putting the (mi MyInt) in parenthesis, the highlighted red part,
before the name of the function, when I defined the function,
when I declared the function. So and then what happens is
inside the definition, so if we look inside double
it just returns int (mi*2). Now, notice that it takes mi, now it
refers to mi, because basically what's happening is that mi that object to the
left of the dot when you make the call. That object ends up being an argument and
implicit argument to double. We'll talk about that in a second. So this function just takes
mi whatever integer it is and multiplies it times 2 turns it into
an integer and returns it as an integer. All right, so then in the main
I can just call v.Double and it call the Double that is associated
with the type of v which is MyInt. So, what I'm showing here is just that
this type MyInt is the receiver type for this function Double, that I have defined. So whenever I call Double, I have to
prefix it using this dot notation, I prefix it with an object of that type,
of the MyInt type, so v.Double(). So that the machine knows, okay,
this is the Double that I want, the one that's associated where
this MyInt is the receiver type. Implicit Method Argument. So what I'm saying here, is that even though it looks like
Double takes no arguments, right? If I look at the definition of Double,
there's no arguments there. But there is an implicit argument. Whenever you have a receiver type,
whenever there's a method, it has a receiver type. The object of that receiver type,
that it is to the left of the dot. That is an implicit argument to
the function, to the method rather. So even though double looks like it has
no argument, it really has one argument. Okay, a hidden argument. You do not pass it explicitly. So when I call Double I say (v.Double())
in parentheses I have nothing, right? But that v is going to be
passed to the Double function when you actually make the call. So that's passed automatically invisibly,
the programmer doesn't have to see it. But it's important that you as
a programmer are aware that it is actually being passed. Reason why is because it's
passed call by value. So this is how passing, argument passing
is done and go is call by value. So what happens is when that v, that object to the left of that dot
gets passed to Double implicitly, it is passed by value,
a copy of v is made and passed to Double. So this impacts what Double can do. So it's important to realize, if v is actually being passed, the object
to the left of the dot is being passed as an argument even if though it
doesn't look like it in an obvious way. Thank you.