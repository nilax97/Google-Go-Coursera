Module 3, Object-Orientation in Go,
Topic 2.2, Point Receivers. So we've been talking about methods,
defining methods for an association with
different receiver types. So there are a few limitations to this
process that we may need to overcome. So remember [COUGH] that this
receiver type is implicitly passed. The receiver object is implicitly
passed as an argument to the method. So even though it's not explicitly passed,
it is implicitly passed. And remember that argument passing in
Go is passed by value, called by value. So that means that the method can't modify
the data inside the receiver object. So as an example, let's say we
had some mythical OffsetX, and it should increase the x
coordinate of a point, right? We wanted to add some constant to
the x coordinate at some point. So in our function main, we say pl
:= Point (3, 4), we make a point. Now we say pl.OffsetX, and we pass it 5 is
the value that we want to add to the X. That won't change the X. It can't change the X coordinate. The reason why is because this
OffsetX is being passed a copy of p1, not appointed a p1, a copy of p1. And so as it gets a copy of p1,
it can change it's copy, so it gets its own p1.x copy,
it can change that from 3 to 8. But that goes away as soon as soon
as the function is done executing. So as Offset as x is done executing,
that goes away, because it's in its environment is gone. So what we want in this case is to be able
to change the actual values inside p1, but you can't, because they get the p1. The p1,
the object is actually passed by value. Another problem with that is
if the receiver is large, a lot of copying happens
when you make a call. So when you call by value and the receiver
object is passed as an argument, the whole thing has to get copied
onto the stack internally. And if it's a large receiver object,
then there's a lot of copying. So in this case, I've got my type Image
[COUGH] and this type is a 100 by 100 array events, which is actually small for
an image, okay? So that's 10,000 int. So when I call this BlurImage
[COUGH] which is some method that's associated with whose
receiver type is this image. When I call BlurImage, the i1, this image, actually has to get passed
to the BlurImage method. And that's 10,000 ints that you've
got to copy out of the stack and that can take a long time. And images actually
are a sort of worse case, because they can get gigantic, right? 100 by 100 is not even big, so
that can waste a lot of time. So this is the problem. So what do you do? Well, we do what we did before with
method argument, not even with method, with regular functions. We can just pass, instead of passing,
calling by value, you can call by reference. So you explicitly pass the appointed to
the object, rather than the object itself. So the way you manage this is
when you declare the function. Like we're seeing here,
we're declaring this OffsetX. See this receiver type to the left
of the name of the function. So in parentheses is p *Point. I say *Point this time, *Point, right? Instead if I said p *Point, then I'm
passing the point called by value. But if I say p *Point,
then now p is a pointer to a point, right? So now, and when I implicitly
pass this p value to offset x, it's going to pass a pointer to
the point type that we're talking about. So now inside the function, I say p.x
= p.x + v and that'll actually work, because p.x is now, since p is
actually a pointer to this structure. p.x points to the actual
x value in memory. So you can actually modify it now,
because you didn't call it by reference. Thank you.