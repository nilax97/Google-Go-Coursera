Module 3 or Object Orientation in Go. Topic 2.1, Encapsulation. So Go provides a lot of
different support for encapsulation and keeping private data. But you want to be able to have
controlled access of the data. So typically, even if you have
private data in some package, you probably don't want to
hide it completely. All right, or
else why are you even importing it anyway? You hide it but
you want to have controlled access to it. So what that means is you want people
to be able to use that data but only in the way that you define, okay? Using your methods or functions. So what you can do is you can define
a set of functions, public functions, that allow another package, an external
package, to access the hidden data. So as an example,
say I got my data package right there, package data,
got my hidden variable x int= 1. And then I can define inside that same
package a function called PrintX. And PrintX just prints x, okay? It does exactly what it says. Now PrintX,
notice it starts with a capital letter, so that means it gets exported. So if my main package decides to import
the data package, the main package will be able to access this PrintX method even
though it can't directly access the x. Okay, and so now what happens is I
can access the main method, the main function can access the x variable
only through this PrintX function. So if I want to see the x value,
I have to call PrintX. So if I look in my main code,
I import the data and then in my main I can call data.PrintX and
then I can see the value of x. Even though I couldn't directly
access x from my main, I can indirectly access it
through these public functions. So this is generally how we're
going to control access to data that we want to hide. You want to give access but
only in a controlled fashion. We let them see what we want them to see,
is the idea. Also, to modify code, to modify x, right. I mean as it is,
x cannot be modified externally. There's no way the main can
directly see x or modify it. But if I wanted to allow
the main to be able to modify x, I could make some kind of
a function inside the package, start it with a capital letter that
main could call to access the variable. So we can do this with structures too. So say we have some kind
of type that's a structure. Like a point type. We put that in our data package again,
right? And maybe the x and the y and coordinates,
we don't want the outside user, the person who is using this type to
be able to directly modify x and y. We want to be able to
control their observation and their modifications to x and y. So we give them lower-case names,
lower-case x, lower-case y. But we define a set of
functions inside that package, the data package, that are public, and allow another package to use to
actually access x and y in some way. So for instance, first one you might want to define is
InitMe that I'm defining down here. And that, notice it is associated with the
point type, the receiver type is Point, so p *Point. I call InitMe and InitMe just allows
me to initialize x and y, right? That's something clearly
you're going to want to do. You make a point,
you want to initialize the x and y values. So I do it through this InitMe
method that I'm defining. And it just sets p.x equal
to the first argument, p.y equal to the second argument. So in this way, using this function,
this InitMe function, I can modify x and y, even though I can't directly touch x
and y I can do it through this function. Then a few more functions that you might
want to add to allow access to the x and y, they're hidden. This is Scale. So Scale, again, it's associated with
Point, its receiver type is Point. And Scale, you pass it a floating point
number v, and it just scales x and y together, so it multiplies p.x times
the scale factor, p.y times scale factor. Again, we're not trusting
the programmer to do this, we're scaling both of them together. So if they want to scale,
they have to call our scale function and they can scale them both. Also, print me, maybe I want to be
able to print the x and y values. And since another package
can't directly access x and y to call Println on it, we have to
provide a function for that, PrintMe. And it just goes in there and it prints
out the x and y, prints out p.x, p.y. So now we define a set of functions,
a set of methods, really, because they're all associated
with the type Point. And these methods are all public because
we started them with capital letters, Print and Scale, they're all capital. So we can access them outside in,
say, our main package. So in our main package we can use them,
so for instance, in this main we make a point,
data.Point call p. Then we call p.InitMe,
it initializes x and y to 3 and 4. Then we call p.Scale to scale it, to multiply 3 and 4 times 2,
so it should be 6 and 8. Then we call p.PrintMe, it prints 6 and 8. So if we ran this it would work. And in this way even though
we can't from the main, we can't directly access x and y,
we can't say p.x= bam p.y=, right? But we can access them
through these methods that are provided to us in a controlled way. Thank you.