1
00:00:00,002 --> 00:00:06,466
Module 3, Object-Orientation in Go,
Topic 2.2, Point Receivers.

2
00:00:06,466 --> 00:00:09,850
So we've been talking about methods,
defining methods for

3
00:00:09,850 --> 00:00:13,310
an association with
different receiver types.

4
00:00:13,310 --> 00:00:17,800
So there are a few limitations to this
process that we may need to overcome.

5
00:00:17,800 --> 00:00:22,294
So remember [COUGH] that this
receiver type is implicitly passed.

6
00:00:22,294 --> 00:00:26,210
The receiver object is implicitly
passed as an argument to the method.

7
00:00:26,210 --> 00:00:30,170
So even though it's not explicitly passed,
it is implicitly passed.

8
00:00:30,170 --> 00:00:38,410
And remember that argument passing in
Go is passed by value, called by value.

9
00:00:38,410 --> 00:00:45,032
So that means that the method can't modify
the data inside the receiver object.

10
00:00:45,032 --> 00:00:48,198
So as an example, let's say we
had some mythical OffsetX, and

11
00:00:48,198 --> 00:00:51,022
it should increase the x
coordinate of a point, right?

12
00:00:51,022 --> 00:00:54,830
We wanted to add some constant to
the x coordinate at some point.

13
00:00:54,830 --> 00:01:00,980
So in our function main, we say pl
:= Point (3, 4), we make a point.

14
00:01:00,980 --> 00:01:06,350
Now we say pl.OffsetX, and we pass it 5 is
the value that we want to add to the X.

15
00:01:06,350 --> 00:01:08,470
That won't change the X.

16
00:01:08,470 --> 00:01:10,490
It can't change the X coordinate.

17
00:01:10,490 --> 00:01:15,947
The reason why is because this
OffsetX is being passed a copy of p1,

18
00:01:15,947 --> 00:01:18,834
not appointed a p1, a copy of p1.

19
00:01:18,834 --> 00:01:22,323
And so as it gets a copy of p1,
it can change it's copy, so

20
00:01:22,323 --> 00:01:25,980
it gets its own p1.x copy,
it can change that from 3 to 8.

21
00:01:25,980 --> 00:01:31,690
But that goes away as soon as soon
as the function is done executing.

22
00:01:31,690 --> 00:01:34,020
So as Offset as x is done executing,
that goes away,

23
00:01:34,020 --> 00:01:35,980
because it's in its environment is gone.

24
00:01:35,980 --> 00:01:43,881
So what we want in this case is to be able
to change the actual values inside p1,

25
00:01:43,881 --> 00:01:48,214
but you can't, because they get the p1.

26
00:01:48,214 --> 00:01:51,670
The p1,
the object is actually passed by value.

27
00:01:51,670 --> 00:01:55,600
Another problem with that is
if the receiver is large,

28
00:01:55,600 --> 00:01:58,300
a lot of copying happens
when you make a call.

29
00:01:58,300 --> 00:02:04,320
So when you call by value and the receiver
object is passed as an argument,

30
00:02:04,320 --> 00:02:09,020
the whole thing has to get copied
onto the stack internally.

31
00:02:09,020 --> 00:02:12,340
And if it's a large receiver object,
then there's a lot of copying.

32
00:02:12,340 --> 00:02:17,172
So in this case, I've got my type Image
[COUGH] and this type is a 100 by 100

33
00:02:17,172 --> 00:02:20,923
array events, which is actually small for
an image, okay?

34
00:02:20,923 --> 00:02:22,822
So that's 10,000 int.

35
00:02:22,822 --> 00:02:26,511
So when I call this BlurImage
[COUGH] which is some method

36
00:02:26,511 --> 00:02:30,609
that's associated with whose
receiver type is this image.

37
00:02:30,609 --> 00:02:34,216
When I call BlurImage, the i1, this image,

38
00:02:34,216 --> 00:02:38,298
actually has to get passed
to the BlurImage method.

39
00:02:38,298 --> 00:02:40,985
And that's 10,000 ints that you've
got to copy out of the stack and

40
00:02:40,985 --> 00:02:42,300
that can take a long time.

41
00:02:42,300 --> 00:02:43,944
And images actually
are a sort of worse case,

42
00:02:43,944 --> 00:02:45,250
because they can get gigantic, right?

43
00:02:45,250 --> 00:02:48,740
100 by 100 is not even big, so
that can waste a lot of time.

44
00:02:49,810 --> 00:02:50,590
So this is the problem.

45
00:02:51,730 --> 00:02:52,382
So what do you do?

46
00:02:52,382 --> 00:02:57,085
Well, we do what we did before with
method argument, not even with method,

47
00:02:57,085 --> 00:02:59,190
with regular functions.

48
00:02:59,190 --> 00:03:01,880
We can just pass, instead of passing,
calling by value,

49
00:03:01,880 --> 00:03:03,098
you can call by reference.

50
00:03:03,098 --> 00:03:08,220
So you explicitly pass the appointed to
the object, rather than the object itself.

51
00:03:08,220 --> 00:03:12,852
So the way you manage this is
when you declare the function.

52
00:03:12,852 --> 00:03:15,890
Like we're seeing here,
we're declaring this OffsetX.

53
00:03:15,890 --> 00:03:19,050
See this receiver type to the left
of the name of the function.

54
00:03:19,050 --> 00:03:21,250
So in parentheses is p *Point.

55
00:03:21,250 --> 00:03:24,260
I say *Point this time, *Point, right?

56
00:03:24,260 --> 00:03:29,000
Instead if I said p *Point, then I'm
passing the point called by value.

57
00:03:29,000 --> 00:03:33,710
But if I say p *Point,
then now p is a pointer to a point, right?

58
00:03:33,710 --> 00:03:39,344
So now, and when I implicitly
pass this p value to offset x,

59
00:03:39,344 --> 00:03:45,610
it's going to pass a pointer to
the point type that we're talking about.

60
00:03:45,610 --> 00:03:52,470
So now inside the function, I say p.x
= p.x + v and that'll actually work,

61
00:03:52,470 --> 00:03:57,285
because p.x is now, since p is
actually a pointer to this structure.

62
00:03:57,285 --> 00:04:02,140
p.x points to the actual
x value in memory.

63
00:04:02,140 --> 00:04:05,325
So you can actually modify it now,
because you didn't call it by reference.

64
00:04:07,185 --> 00:04:07,685
Thank you.