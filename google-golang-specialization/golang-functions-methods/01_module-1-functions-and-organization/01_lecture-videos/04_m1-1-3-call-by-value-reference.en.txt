Module 1, Functions and Organization. Topic 1.3, Call by Value and Reference. So call by value describes how
arguments are passed to parameters during a function call. So in a function call,
when you call a function, you gotta pass it a set of arguments
that are bound to the parameters inside the function when
you execute the function. But different languages can pass
arguments in different ways. Call by value is how it's done in go. So what call by value means is that the
arguments that are passed as parameters, they are copied to the parameters. So the data that the function is using, it's using the data that's
assigned to the parameters, right? Well, the data that it uses is a copy
of the original, it's not the original. So that matters, because that means
that the function that's being called can't interfere with the original
variables in the calling function. So modifying parameters has no
effect on the outside function, on the calling function. So it's easier if we show an example,
so say we got this function foo. This function foo,
it takes one int argument y. Why y is its parameter? It's an integer and
it just, it says y = y + 1. So all it does is take y add one to it. Now this is admittedly a dumb procedure,
because it's going to have no effect. But let's just imagine for argument's sake that this is
the function that we want to write. So it takes y add 1 to it. Now main,
what it does is it has a variable x, sets it equal to 2,
then it calls foo with x. Now what will happen is that
2 will get passed to foo. So x = 2, 2 gets passed to foo,
but it gets copied to foo. So y when you executing foo, that
parameter y = 2, it's a copy of 2 though. It's not the same 2 that x is pointing at. The x defined in main is a completely
separate variable than the y defined inside foo. So when foo takes y which is equal to 2,
and adds 1 to it, it is changing y but
it is not changing x from the main. Okay, so that's the point to make, right? The call function cannot change
the variables inside the calling function, like x in this case. So if you go back to the main,
after I say foo x, when I print out the x, it prints out what x originally was which
was 2 because x has not been changed. Even though foo the function said, y =
y + 1, that in no way touched x, right? because y was only a copy of what x is. So that's call by value,
that the call function can't affect, it's just get a copy of
the variable of parameters. So tradeoffs of call by value,
advantage is data encapsulation. So the fact that the function
cannot alter the variables inside the caller is often
considered a good thing, because it limits the propagation
of errors, right? So the called function, it can make
a mistake and can do something wrong but it can't change the caller environment,
right? It can't go and mess up
the variable that called it, right? And that would just allow bugs
to spread out more fully across the different functions inside the code. So function errors are more localized and
encapsulated when you use a call by value. Now a disadvantage is copying time. So what that means is, call by value, you have to actually copy
the arguments into the parameters. So for instance, in the last example,
this foo had a parameter y. So this value for x which is equal to 2,
that 2 had to get copied into y. So that the function has
a copy of the argument, right? So that take time,
it took some amount to copy. Now, if it's just an integer, who cares? But if the argument is something big,
like some gigantic slice or something like that,
then it's a serious problem. So that's a disadvantage of call by value. So an alternative to that is
called call by reference. Now call by reference is not
built into this language, meaning there's no feature built into it,
but you can do it manually, okay? All you have to do is pass a pointer. So instead of passing the argument that
you want to pass, you pass a pointer. Now remember, so
a reference is a pointer, right? What I mean by this is let's say you
want the function to actually alter the variables that are passed to it. So in the last example,
it was that variable x in the main and the foo could not alter that. But let's say I wanted the foo
to alter that variable. So let's just look at this example,
it's easier if I show it again. We got this function foo, and
it's basically saying y = y + 1. But this time, notice that it doesn't
take an integer as an argument, y is now a pointer to an integer *int,
okay? So it assumes that y is a pointer to
an integer and then it says *y = *y + 1. So that means it takes the contents of
what y is pointing to and adds 1 to that. So it still does the same thing, but it takes a pointer to y
instead of an actual y. So it takes a point to an integer
instead of an actual integer. Now, in the main,
if I look at the main, when I call it. Instead of saying foo x,
passing it a copy of x, I say foo(&x). So what that does, it is passes
a point to 2x, passes that to foo. So now foo has a pointer to x. So foo has a copy of the location
in memory where x is. So when foo modifies, it says *y = *y + 1,
it's modifying the data at that location. So it's modifying the actual x. And then when you print out
in the bottom of the main, when it prints out x,
x would actually be equal to 3 after this. So this is a call by reference because
you're not passing the actual integer or the actual data to foo, to the function. You're passing a reference to it,
a pointer to it. And when you pass the pointer,
when foo gets a copy of the pointer, it knows where that value is in memory. So it can directly go into that
location of memory and alter it. So then foo now has the ability to alter
this variable x, even though x wasn't initially defined inside the scope of foo,
it was defined in the scope of main. So tradeoffs are basically the opposite
of call by value tradeoffs. So the advantage is copying time. So you don't need to copy the arguments. So you still need to copy
the pointer that you're passing, and that takes a certain amount time. But if your argument is some big slice
with a hundred thousand elements in it. You don't have to copy that whole slice. You don't have to copy that whole
structure or whatever it is, so that can save you a lot of time. A disadvantage is data encapsulation. So actually the advantage of call by
values, the disadvantage of by reference. Now if there's a bug inside foo,
it can alter the variables inside main whichever variables you
pass to it anyway, by reference. So that may be what you want,
but it may not be what you want. And you just have to pay attention
to that when you writing your code. You only pass by reference,
if you definitely want the function to modify the variables in
the calling function. Thank you.