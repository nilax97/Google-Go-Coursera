Module 1, Functions and Organization. Topic 1.4, Passing Arrays and Slices. So say you want to pass an array
as an argument to a function. Maybe you want to do some
processing on the array or something like that inside a function. So the arguments are all copied,
because this is called by value, so the whole array has to be
copied to the parameters. And if the array is big, then it's a
problem, it'll take a lot of time to copy, also use an excessive amount of space. So as an example of that,
we've got this function, foo, and it takes as an argument
an array of three integers. Three is small, but
this is just an example. You could imagine that could be 300,000,
right? So it takes in an array of three integers,
and so that's declared there, (x [3] int) and
it returns an integer. And just returns the first
element of the array, x [0]. So the function main,
that first defines an array, a: = [3]int(1, 2, 3). And then it prints out
whatever foo it returns. So it calls foo with that array, a,
which returns the first element, which would be a 1,
then it prints that out. So in this case it has to
copy that whole array over, when it makes a function call, it copies
that into x, the parameter of foo. And that wastes time if it's a long array. So what do you do? So one thing you can do about
that is you can employ, basically call by reference, right? So you can,
instead of passing the array to foo. You can change food so
that it takes a pointer to an array. So that's what we've done here. Function foo, if you look at its argument, it's parameter list,
it says foo(x*[3]int). So as a pointer to a three
element array of integers. And then inside the function
foo all it does is, it takes *x which is pointed to the array,
so *x is x of the array, right? And it looks at the zeroth element and
adds one to it. So it increments,
it should increment to zeroth element. Then if I look at the main,
it defines the array, a. Then when it calls foo, it doesn't
pass at a, it passes at ampersand a, it passes on the point into a,
and then it just prints out a. And what should happen is
since foo got the pointer to a it can actually modify that array, a. And it should modify it by
incrementing the first value. So if the array starts out as 1, 2, 3, it
should increment that 1 so it's 2, 2, 3, and then prints out, prints the array
when prints it, it prints 2, 2, 3. So you could this,
you could deference use referencing and dereferencing operations to pass array
pointers and use array pointers. But that's messy and
it is not necessary in GO lang. This isn't the way,
the neat way to do it in GO. So the way you do it in GO,
is you use slices instead. In fact, in general in GO get used
to using slices instead of arrays, just in general. So a slice is like window on an array,
right? But remember that when you declare a
slice, if you declare a slice from scratch or however you make it, it'll make
the backing array behind it, right? So you can almost always use
a slice instead of an array. So passing a slice copies the pointer. So we pass an array,
it copies the whole array. But a slice is not actually an array. It's really a structure
that contains three things. A pointer to the array or a pointer to
the start to the slice in the array, and the length, and the capacity, okay? So it is really a structure with
those three pieces of data, one of which is a pointer, okay? So so still rhe GO lang is still call
by value, but when you pass a slice, since the slice contains pointer
your copying the pointer. So the called function, when you pass
a slice you actually gets the pointer and also the length and the capacity. So it can use that pointer directly to
modify the slice without you having to explicitly dereference and reference
like we did with the array example. So here's an example like that. Here with this foo function, this time
it takes a slice, I'm calling sli. And notice that when you declare the
slice, you don't have to specify the size. In fact you can't specify the size. You just give the square brackets. So it says sli [ int ], there's no
number inside the square brackets, because that means it's a slice. So you do that and it knows, okay, this function foo takes
a slice as its parameter. And then what it does, it takes a slice
and just adds one to slice element 0. Then if we look at the main,
this time what we do is, when we declare, we don't declare an array,
we declare a slice. And it's only slightly different. So this time when we declare a,
make that array, or rather not a, and not array, it is a slice now. A := []int(1, 2, 3), the only difference
is I didn't specify a size, right? Inside the square brackets I didn't put
a 3 like I did when I declared an array. This time I just put square brackets so now it recognizes that
a is actually a slice. So then I can just call foo past
the slice of a, which now slice and it works exactly the same
as the last program. And so when you print a, it will
have incremented the first element, which was 1 and now is 2, so
it'll print that 2, 2, 3. So in general, in GO,
try to use slices instead of arrays, okay? And specifically when you want to
pass an argument, an array argument, don't pass an array argument,
pass a slice argument. Because then you don't have to do all
the copying that would be associated with an array. Thank you.