1
00:00:00,066 --> 00:00:02,796
Module 1, Functions and Organization.

2
00:00:02,796 --> 00:00:05,533
Topic 1.3, Call by Value and Reference.

3
00:00:08,392 --> 00:00:13,185
So call by value describes how
arguments are passed to parameters

4
00:00:13,185 --> 00:00:15,021
during a function call.

5
00:00:15,021 --> 00:00:17,120
So in a function call,
when you call a function,

6
00:00:17,120 --> 00:00:19,990
you gotta pass it a set of arguments
that are bound to the parameters

7
00:00:19,990 --> 00:00:22,261
inside the function when
you execute the function.

8
00:00:22,261 --> 00:00:26,046
But different languages can pass
arguments in different ways.

9
00:00:26,046 --> 00:00:28,723
Call by value is how it's done in go.

10
00:00:28,723 --> 00:00:34,266
So what call by value means is that the
arguments that are passed as parameters,

11
00:00:34,266 --> 00:00:36,758
they are copied to the parameters.

12
00:00:36,758 --> 00:00:39,549
So the data that the function is using,

13
00:00:39,549 --> 00:00:44,890
it's using the data that's
assigned to the parameters, right?

14
00:00:44,890 --> 00:00:49,274
Well, the data that it uses is a copy
of the original, it's not the original.

15
00:00:49,274 --> 00:00:54,526
So that matters, because that means
that the function that's being

16
00:00:54,526 --> 00:01:00,607
called can't interfere with the original
variables in the calling function.

17
00:01:00,607 --> 00:01:04,225
So modifying parameters has no
effect on the outside function,

18
00:01:04,225 --> 00:01:05,701
on the calling function.

19
00:01:05,701 --> 00:01:09,510
So it's easier if we show an example,
so say we got this function foo.

20
00:01:09,510 --> 00:01:13,216
This function foo,
it takes one int argument y.

21
00:01:13,216 --> 00:01:14,870
Why y is its parameter?

22
00:01:14,870 --> 00:01:17,885
It's an integer and
it just, it says y = y + 1.

23
00:01:17,885 --> 00:01:20,050
So all it does is take y add one to it.

24
00:01:20,050 --> 00:01:23,822
Now this is admittedly a dumb procedure,
because it's going to have no effect.

25
00:01:23,822 --> 00:01:24,898
But let's just imagine for

26
00:01:24,898 --> 00:01:27,910
argument's sake that this is
the function that we want to write.

27
00:01:27,910 --> 00:01:29,446
So it takes y add 1 to it.

28
00:01:29,446 --> 00:01:33,418
Now main,
what it does is it has a variable x,

29
00:01:33,418 --> 00:01:37,406
sets it equal to 2,
then it calls foo with x.

30
00:01:37,406 --> 00:01:41,389
Now what will happen is that
2 will get passed to foo.

31
00:01:41,389 --> 00:01:45,482
So x = 2, 2 gets passed to foo,
but it gets copied to foo.

32
00:01:45,482 --> 00:01:50,861
So y when you executing foo, that
parameter y = 2, it's a copy of 2 though.

33
00:01:50,861 --> 00:01:53,810
It's not the same 2 that x is pointing at.

34
00:01:53,810 --> 00:01:58,737
The x defined in main is a completely
separate variable than the y defined

35
00:01:58,737 --> 00:01:59,639
inside foo.

36
00:01:59,639 --> 00:02:02,534
So when foo takes y which is equal to 2,
and

37
00:02:02,534 --> 00:02:07,780
adds 1 to it, it is changing y but
it is not changing x from the main.

38
00:02:07,780 --> 00:02:09,598
Okay, so that's the point to make, right?

39
00:02:09,598 --> 00:02:14,622
The call function cannot change
the variables inside the calling function,

40
00:02:14,622 --> 00:02:16,320
like x in this case.

41
00:02:16,320 --> 00:02:20,670
So if you go back to the main,
after I say foo x, when I print out the x,

42
00:02:20,670 --> 00:02:25,326
it prints out what x originally was which
was 2 because x has not been changed.

43
00:02:25,326 --> 00:02:30,725
Even though foo the function said, y =
y + 1, that in no way touched x, right?

44
00:02:30,725 --> 00:02:33,265
because y was only a copy of what x is.

45
00:02:33,265 --> 00:02:37,812
So that's call by value,
that the call function can't affect,

46
00:02:37,812 --> 00:02:42,080
it's just get a copy of
the variable of parameters.

47
00:02:42,080 --> 00:02:47,049
So tradeoffs of call by value,
advantage is data encapsulation.

48
00:02:47,049 --> 00:02:51,563
So the fact that the function
cannot alter the variables

49
00:02:51,563 --> 00:02:55,788
inside the caller is often
considered a good thing,

50
00:02:55,788 --> 00:03:00,170
because it limits the propagation
of errors, right?

51
00:03:00,170 --> 00:03:04,546
So the called function, it can make
a mistake and can do something wrong but

52
00:03:04,546 --> 00:03:07,546
it can't change the caller environment,
right?

53
00:03:07,546 --> 00:03:13,838
It can't go and mess up
the variable that called it, right?

54
00:03:13,838 --> 00:03:18,553
And that would just allow bugs
to spread out more fully across

55
00:03:18,553 --> 00:03:21,893
the different functions inside the code.

56
00:03:21,893 --> 00:03:29,251
So function errors are more localized and
encapsulated when you use a call by value.

57
00:03:29,251 --> 00:03:31,921
Now a disadvantage is copying time.

58
00:03:31,921 --> 00:03:33,959
So what that means is, call by value,

59
00:03:33,959 --> 00:03:37,296
you have to actually copy
the arguments into the parameters.

60
00:03:37,296 --> 00:03:42,910
So for instance, in the last example,
this foo had a parameter y.

61
00:03:42,910 --> 00:03:47,428
So this value for x which is equal to 2,
that 2 had to get copied into y.

62
00:03:47,428 --> 00:03:52,040
So that the function has
a copy of the argument, right?

63
00:03:52,040 --> 00:03:54,510
So that take time,
it took some amount to copy.

64
00:03:54,510 --> 00:03:56,857
Now, if it's just an integer, who cares?

65
00:03:56,857 --> 00:04:00,558
But if the argument is something big,
like some gigantic slice or

66
00:04:00,558 --> 00:04:03,601
something like that,
then it's a serious problem.

67
00:04:03,601 --> 00:04:06,030
So that's a disadvantage of call by value.

68
00:04:07,560 --> 00:04:10,461
So an alternative to that is
called call by reference.

69
00:04:10,461 --> 00:04:14,818
Now call by reference is not
built into this language,

70
00:04:14,818 --> 00:04:21,084
meaning there's no feature built into it,
but you can do it manually, okay?

71
00:04:21,084 --> 00:04:24,110
All you have to do is pass a pointer.

72
00:04:24,110 --> 00:04:27,779
So instead of passing the argument that
you want to pass, you pass a pointer.

73
00:04:27,779 --> 00:04:31,870
Now remember, so
a reference is a pointer, right?

74
00:04:31,870 --> 00:04:36,632
What I mean by this is let's say you
want the function to actually alter

75
00:04:36,632 --> 00:04:39,147
the variables that are passed to it.

76
00:04:39,147 --> 00:04:42,908
So in the last example,
it was that variable x in the main and

77
00:04:42,908 --> 00:04:44,850
the foo could not alter that.

78
00:04:44,850 --> 00:04:48,328
But let's say I wanted the foo
to alter that variable.

79
00:04:48,328 --> 00:04:51,550
So let's just look at this example,
it's easier if I show it again.

80
00:04:51,550 --> 00:04:55,664
We got this function foo, and
it's basically saying y = y + 1.

81
00:04:55,664 --> 00:04:59,635
But this time, notice that it doesn't
take an integer as an argument,

82
00:04:59,635 --> 00:05:02,820
y is now a pointer to an integer *int,
okay?

83
00:05:02,820 --> 00:05:09,667
So it assumes that y is a pointer to
an integer and then it says *y = *y + 1.

84
00:05:09,667 --> 00:05:16,170
So that means it takes the contents of
what y is pointing to and adds 1 to that.

85
00:05:16,170 --> 00:05:19,686
So it still does the same thing, but

86
00:05:19,686 --> 00:05:24,149
it takes a pointer to y
instead of an actual y.

87
00:05:24,149 --> 00:05:27,830
So it takes a point to an integer
instead of an actual integer.

88
00:05:27,830 --> 00:05:31,771
Now, in the main,
if I look at the main, when I call it.

89
00:05:31,771 --> 00:05:38,430
Instead of saying foo x,
passing it a copy of x, I say foo(&x).

90
00:05:38,430 --> 00:05:44,252
So what that does, it is passes
a point to 2x, passes that to foo.

91
00:05:44,252 --> 00:05:46,602
So now foo has a pointer to x.

92
00:05:46,602 --> 00:05:50,676
So foo has a copy of the location
in memory where x is.

93
00:05:50,676 --> 00:05:57,690
So when foo modifies, it says *y = *y + 1,
it's modifying the data at that location.

94
00:05:57,690 --> 00:06:00,333
So it's modifying the actual x.

95
00:06:00,333 --> 00:06:02,916
And then when you print out
in the bottom of the main,

96
00:06:02,916 --> 00:06:06,120
when it prints out x,
x would actually be equal to 3 after this.

97
00:06:06,120 --> 00:06:11,406
So this is a call by reference because
you're not passing the actual integer or

98
00:06:11,406 --> 00:06:14,221
the actual data to foo, to the function.

99
00:06:14,221 --> 00:06:17,540
You're passing a reference to it,
a pointer to it.

100
00:06:17,540 --> 00:06:21,308
And when you pass the pointer,
when foo gets a copy of the pointer,

101
00:06:21,308 --> 00:06:23,543
it knows where that value is in memory.

102
00:06:23,543 --> 00:06:26,540
So it can directly go into that
location of memory and alter it.

103
00:06:26,540 --> 00:06:31,480
So then foo now has the ability to alter
this variable x, even though x wasn't

104
00:06:31,480 --> 00:06:36,582
initially defined inside the scope of foo,
it was defined in the scope of main.

105
00:06:36,582 --> 00:06:40,860
So tradeoffs are basically the opposite
of call by value tradeoffs.

106
00:06:40,860 --> 00:06:42,464
So the advantage is copying time.

107
00:06:42,464 --> 00:06:44,727
So you don't need to copy the arguments.

108
00:06:44,727 --> 00:06:48,106
So you still need to copy
the pointer that you're passing, and

109
00:06:48,106 --> 00:06:49,970
that takes a certain amount time.

110
00:06:49,970 --> 00:06:54,796
But if your argument is some big slice
with a hundred thousand elements in it.

111
00:06:54,796 --> 00:06:56,805
You don't have to copy that whole slice.

112
00:06:56,805 --> 00:06:59,995
You don't have to copy that whole
structure or whatever it is, so

113
00:06:59,995 --> 00:07:01,511
that can save you a lot of time.

114
00:07:01,511 --> 00:07:03,781
A disadvantage is data encapsulation.

115
00:07:03,781 --> 00:07:09,010
So actually the advantage of call by
values, the disadvantage of by reference.

116
00:07:09,010 --> 00:07:13,721
Now if there's a bug inside foo,
it can alter the variables inside

117
00:07:13,721 --> 00:07:18,282
main whichever variables you
pass to it anyway, by reference.

118
00:07:18,282 --> 00:07:21,860
So that may be what you want,
but it may not be what you want.

119
00:07:21,860 --> 00:07:25,675
And you just have to pay attention
to that when you writing your code.

120
00:07:25,675 --> 00:07:30,659
You only pass by reference,
if you definitely want the function to

121
00:07:30,659 --> 00:07:34,220
modify the variables in
the calling function.

122
00:07:34,220 --> 00:07:34,720
Thank you.