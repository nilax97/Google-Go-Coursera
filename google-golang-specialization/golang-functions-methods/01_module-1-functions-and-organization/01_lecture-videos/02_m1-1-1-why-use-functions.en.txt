Module 1: Functions and Organization,
Topic 1.1: Why Use Functions? So we're going to talk a little
bit about functions right now. We've been using functions since
the start because you basically have to. You can't write code,
at least in Go lang, without a function. So we've been using functions
already in passing. But now folks, a little bit more on how
they're used, or how you define them, how you use them, and be a little bit more
specific about the meaning of a function. So what is a function? A function is really just a set
of instructions with a name. And the name is actually optional,
as we'll see later in a few more lectures. We'll see that you don't
actually need the name, but it's a bunch of instructions
that are grouped together. Okay, and usually with a name or
certainly for now with a name. So we can see first,
we've got this first function over here, main, all right, func main. We're defining a function and
that's it's name, main. And we've, all of our programs so
far, they all have a main. In fact, all programs in Go have
to have a main function, right? That's where execution starts. We already said that but
I'll just remind you again. So there's always at least this function,
main. Now if you look at the way
we define that function, it says func main () and
then there's a curly bracket, right? So and then between the curly brackets, so there's open curly bracket and
a closed curly bracket. Between that is the contents
of the function. So those instructions in there
are the instructions that are part of the function. Now this main on top,
it's a very simple main. All it has is one line of code,
fmt.Printf ("Hello, world."). But you could put any number
of lines of code in there and they would be all grouped together
in this function called main. So this is really the simplest way
you can define a function at all. Now the main function is actually
a special function in the sense that you never call this function. So when you run your program from
the command line say, when you run the program, the main function gets
called and invoked immediately. So calling a function means
to execute that function. And that happens automatically with main. As soon as you run it, it goes
straight to main, calls that function. But for any other function you define,
you have to call that code explicitly. You have to call the function explicitly. So take a look at
the example on the bottom. We got two functions here. The top one is called PrintHello,
and the bottom one's called main. So let's look at the main for a second. The main, if you look at main, all it
has is one line, it calls PrintHello. So it says PrintHello(). That is a function call. So that's where we call PrintHello. And at that point in execution,
it will go to PrintHello and execute whatever PrintHello,
whatever instructions PrintHello contains. Now if you look above at PrintHello, you
can see that it's just one instruction, just Hello, world, right,
just prints Hello, world. So the two programs that we have, the top
main and then the bottom program with the main and the PrintHello,
they do the same thing, right? It's just that the bottom function,
actually the bottom program has a function call in it,
an explicit function call inside main. It calls PrintHello. So this is really, what you're seeing
here is really the simplest kind of function you can ever have. And so function declaration is
where you define the function. So a function declaration in Go lang
starts with that keyword func, F-U-N-C. And then you have the name of
the function after that in the line. You have open paren, close paren. You might have arguments in there,
we'll talk about that soon. And you can also have return values,
we'll talk about that too. And then there's curly brackets, inside the curly brackets
are the contents of the function. And functions can also be called, in fact,
they have to be called, except for the main, which doesn't get called,
it just gets executed automatically. So why use a function? There are a lot of reasons. One reason right off
the top is reusability. So what that means is, you don't have to
rewrite the same code over and over again. So if you have a function,
and you define a function, you only need to define that function,
or declare that function one time. And then you can call it and
run it as many times as you want. So maybe you write this function once,
and then you need to invoke it 100 times. Maybe you need to do this
operation 100 different times. So then you can write it once, but you only write it once,
then you call it 100 times. And it saves you, it basically
shrinks the size of your source code. Okay, so and you can reuse it, you can
actually reuse it across projects too. So people can use your function. They can import the library and
use your function and your code too. So it's good for reuse. Good for commonly used
operations in this way, right? So things that you do a lot,
you might want to make them a function and give them a name, so that you don't have
to keep rewriting that code over and over. You can just call the code. So as a few examples of
functions you might make, say you're writing some kind
of graphics editing program. You might have a function
called threshold image. So not to go too much in
the graphic editing, but there are a lot of operations in graphics. So you got an image, it is often,
it's common to threshold an image. So basically if the brightness is above
a threshold, then you make it black. If it's below a threshold,
you make it white, okay? Common operation, you do it a lot so
you might write a function just for that purpose and
then you can call it 100 times. Whenever in your code you need to do it,
you call it. Say you got a database program. You might have a QueryDbase function. Querying a database is probably the main
thing you do with a database, right? You got a database, you want to get some
data out of it, you query the database. So that type of thing,
you might want to write it as a function, because you know you're going to
do it over and over again. And then you just call the function. Also another little example,
say you've got some music program, or a music editing program. ChangeKey (), which is a function I thought of, there
are many functions you can do with music. But changing key, maybe you want to
change a key from A to C, so maybe you have a function for that
purpose, right, because you do it a lot. These function titles is that
they're specific to the application. So in graphics,
your function might threshold an image, which is specific to graphics. Database program, you might query
a database specific to that domain, also changing keys specific to music. So this is something you're going to have
to think about when you make bigger pieces of code, and we'll talk more
about this later in the module. But when you're organizing your code,
your code will usually have lots of functions and they'll be organized
in some sort of a calling hierarchy. And you'll have to think about what you
want to put together in a function and what you don't. So another reason, another very important
reason to use functions, is for the purpose of abstraction. So abstraction is the designer's friend,
and not just in computer science,
but just all over the place. Any kind of design,
certainly for engineers, but I don't even think it's
limited to engineering. Abstraction is just hiding
details that are less important. I don't want to say unimportant
because details count. But hiding details that
are less important so you don't have to focus
on them all the time. Because generally the problem with
big designs is that there are so many details that a human can't keep
all these details in his or her mind. So you've got to do
something to simplify it. You've got to work with complicated code,
but it's got to be simple or else your mind just can't hold it. So abstraction is the way you do that. Abstraction is, you group things and
you hide the details and functions are exactly for this. So with a function,
you have some complicated behavior maybe, written in the function,
then you give that function a name. And once you've written that function and
you've debugged it, you know it works. You don't have to worry about all
the details of what goes on inside that function. All you need to do is call the function. So as long as you understand
the input-output behavior. So you understand a particular
function does a particular, if it gets these inputs,
it produces these outputs. Then you don't have to worry about how. So for instance, sorting, right? Say I want to make a sort function
that will sort some slice or something like that. I don't care how I sort it. There are many algorithms for
sorting, right? I can do a bubble sort. I can do insertion sort. I could do all kinds of sorts. Who cares, right? Hey, I can just say,
there are reasons why you would care but generally, you don't care,
you just want it sorted. So you just call this sort function. And you don't have to think about exactly
what it's doing inside there, do the sort, you just know given a slice,
the result is a sorted slice. So functions allow you to use abstraction. They're a way to implement abstraction,
and it improves understandability of the code. So for instance here,
we've got this example. I got some function called FindPupil. I bring this up because I'm actually working on a function
that does something like this. It basically looks at an eye,
a close-up picture of an eye, and it has to find the pupil,
find the center of the pupil. So this function, FindPupil,
is actually quite complicated. But to understand every
single step at one, and so I say I get show you the foreign
code, it is very nasty looking, okay? It would take you a while to figure
out what the heck was going on. But if I write it in
the way that I have here, where I have grouped things into a set
of functions, with nice names, right, GrabImage, FilterImage,
FindEllipses, right? Each one of those functions,
you have an idea what that does. So at a glance,
you can look at this function and get some understanding of how it works. Now, of course, you won't get a full
understanding just at a glance, but you get some part of
understanding right there, right? So this helps understandability, and
understandability is key in design. Now also I should note that
the naming is important for this, for this understandability, right? You need a good name, GrabImage,
FilterImage, FindEllipses. The name has to be good. If I just call those x, y, and z,
you would have no idea what those were. But if they have good names and
you group things appropriately, it's easier to understand
the code when you need to. Thank you.